<script>
  import {
    graphViewConfigStore,
    hoverTokenStore,
    wordToSubwordMapStore,
    instanceIDStore,
    mapHeadStore,
  } from './store';
  import * as d3 from 'd3';
  import { onMount } from 'svelte';

  export let attentionDataDir;
  export let saliencyDataFilepath;

  // Shared states
  let graphViewCompConfig = undefined;
  let instanceID = 1562;
  let curLayer = 9;
  let curHead = 8;
  let mapHead = { layer: 9, head: 8 };

  let graphSVG = null;
  let graphData = null;
  let saliencyData = null;
  let wordToSubwordMap = null;

  let SVGWidth = undefined;
  let SVGHeight = undefined;

  let curHoverToken = null;

  // View configs
  const SVGPadding = { top: 3, left: 3, right: 3, bottom: 3 };

  const minNodeRadius = 19;
  const maxNodeRadius = 40;

  // const minNodeRadius = 10;
  // const maxNodeRadius = 20;

  const radialRadius = 225;
  const radialCurveAlpha = 0.3;

  const gridRowSize = 8;
  const gridRowGap = 35;
  const gridColumnGap = 35;

  // Graph vis variables
  let tokenSize = null;
  let originalNodes = null;

  let curLinkI = 1;
  let weightThresholdMin = 0.02;
  let weightThresholdMax = 0.1;
  let weightThresholdSteps = 6;
  let weightThresholdGap =
    (weightThresholdMax - weightThresholdMin) / (weightThresholdSteps - 1);
  let weightThreshold = weightThresholdMin + weightThresholdGap * curLinkI;

  let linkArrays = {};
  let simulation = null;
  let intermediateNodeMap = new Map();
  let linkWidth = null;

  let linkColor = 'hsl(0, 0%, 76%)';
  let linkHoverColor = 'hsl(36, 100%, 55%)';
  let nodeRadiusScale = null;
  // linkHoverColor = 'hsl(174, 65%, 48%)';

  // Control panel variables
  let settingIconActive = false;

  // Data
  let mounted = false;
  let attentionData = null;

  const ease = d3.easeCubicInOut;
  const animationTime = 300;

  const layoutOptions = {
    force: {
      value: 'force',
      name: 'Force Layout',
    },
    radial: {
      value: 'radial',
      name: 'Radial Layout',
    },
    grid: {
      value: 'grid',
      name: 'Grid Layout',
    },
  };

  let config = {
    borderConstraint: true,
    showHiddenLink: false,
    showHiddenNode: false,
    autoAttention: true,
    defaultLayout: layoutOptions.radial,
  };

  let forceStrength = {
    force: {
      manyBody: -840,
      attention: 0.5,
      textOrder: 1.6,
      collideRadius: 1,
    },
    radial: {
      textOrder: 0.5,
      radial: 1,
    },
    grid: {
      collideRadius: 7,
    },
  };

  let currentLayout = config.defaultLayout;

  const round = (num, decimal) => {
    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;
  };

  const padZeroLeft = (num, digit) => {
    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;
  };

  const drag = () => {
    const dragstarted = (event) => {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;

      // Add a marker to indicate that the node is fixed
      d3.select(event.sourceEvent.originalTarget.parentNode)
        .append('rect')
        .attr('class', 'fixed-marker')
        .attr('x', -3)
        .attr('y', 6)
        .attr('width', 6)
        .attr('height', 5)
        .style('fill', 'white');
    };

    const dragged = (event) => {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    };

    const dragended = (event) => {
      if (!event.active) simulation.alphaTarget(0);
      // event.subject.fx = null;
      // event.subject.fy = null;
    };

    return d3
      .drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended);
  };

  const borderConstraint = (d, nodeRadiusScale) => {
    let curRadius = minNodeRadius;
    if (!d.hidden) {
      curRadius = nodeRadiusScale(+d.saliency);
    }

    let width = SVGWidth - SVGPadding.left - SVGPadding.right;
    let height = SVGHeight - SVGPadding.top - SVGPadding.bottom;

    const left = Math.max(
      SVGPadding.left + curRadius,
      Math.min(width - curRadius, d.x)
    );
    const top = Math.max(
      SVGPadding.top + curRadius,
      Math.min(height - curRadius, d.y)
    );

    if (config.borderConstraint) {
      return { top: top, left: left };
    } else {
      return { top: d.y, left: d.x };
    }
  };

  const bindSlider = (name, min, max, defaultValue, nodeRadiusScale = null) => {
    let slider = d3
      .select(`#${name}`)
      .property('value', ((defaultValue - min) / (max - min)) * 1000);

    slider.on('input', () => {
      let sliderValue = +slider.property('value');
      let value = (sliderValue / 1000) * (max - min) + min;
      let step = sliderValue / 200;
      forceStrength.force[name] = value;

      switch (name) {
        case 'attention':
          simulation.force('attentionLink').strength(value);
          // Disable the auto attention
          d3.select('#checkbox-auto-attention').property('checked', false);
          config.autoAttention = false;
          break;
        case 'textOrder':
          simulation
            .force('textLink')
            .strength((d) => (d.target.index === 0 ? 0 : value));
          break;
        case 'manyBody':
          simulation.force('charge').strength(value);
          break;
        case 'collideRadius':
          simulation
            .force('collide')
            .radius((d) => nodeRadiusScale(d.saliency) + value);
          break;
        case 'threshold':
          weightThreshold = weightThresholdMin + step * weightThresholdGap;
          weightThresholdUpdated(step, nodeRadiusScale);
          break;
      }

      simulation.restart();
    });

    slider.on('mousedown', (event) => {
      if (!event.active) simulation.alphaTarget(0.2).restart();
    });

    slider.on('mouseup', (event) => {
      if (!event.active) simulation.alphaTarget(0);
    });
  };

  const resetSimulation = () => {
    simulation.force('collide', null);
    simulation.force('attentionLink', null);
    simulation.force('charge', null);
    simulation.force('center', null);
    simulation.force('textLink', null);
    simulation.force('hiddenTextLink', null);
    simulation.force('posX', null);
    simulation.force('posY', null);
    simulation.force('grid', null);
  };

  const bindSelect = (nodeRadiusScale) => {
    currentLayout = config.defaultLayout;
    let selectOption = d3
      .select('#select-layout')
      .property('value', config.defaultLayout.value);

    selectOption.on('change', () => {
      let newLayoutValue = selectOption.property('value');

      // Need to switch layout
      if (newLayoutValue !== currentLayout.value) {
        resetSimulation();

        switch (newLayoutValue) {
          case 'force':
            currentLayout = layoutOptions.force;
            initForceSim(nodeRadiusScale);
            simulation.alpha(1).restart();
            break;

          case 'radial':
            currentLayout = layoutOptions.radial;
            initRadialSim();
            simulation.alpha(1).restart();
            break;

          case 'grid':
            currentLayout = layoutOptions.grid;
            initGridSim();
            simulation.alpha(1).restart();
            break;
        }

        updateNodeRadius(nodeRadiusScale);
      }
      simulation.alpha(1).restart();
    });
  };

  const bindLayerHeadSelect = () => {
    let layerSelectOption = d3
      .select('#select-layer')
      .property('value', curLayer);

    let headSelectOption = d3.select('#select-head').property('value', curHead);

    layerSelectOption.on('change', () => {
      let newLayerValue = layerSelectOption.property('value');

      // Need to switch layout
      if (newLayerValue !== curLayer) {
        // console.log(newLayerValue);
        curLayer = newLayerValue;
        updateLayerHead();

        mapHead.layer = +curLayer;
        mapHead.head = +curHead;
        mapHeadStore.set(mapHead);
      }
    });

    headSelectOption.on('change', () => {
      let newHeadValue = headSelectOption.property('value');

      // Need to switch layout
      if (newHeadValue !== curHead) {
        // console.log(newHeadValue);
        curHead = newHeadValue;
        updateLayerHead();

        mapHead.layer = +curLayer;
        mapHead.head = +curHead;
        mapHeadStore.set(mapHead);
      }
    });
  };

  mapHeadStore.subscribe((value) => {
    mapHead = value;

    if (mapHead.layer !== curLayer || mapHead.head !== curHead) {
      // console.log('change');
      d3.select('#select-layer').property('value', mapHead.layer);

      d3.select('#select-head').property('value', mapHead.head);

      curLayer = mapHead.layer;
      curHead = mapHead.head;

      updateLayerHead();
    }
  });

  const updateNodeRadius = (nodeRadiusScale) => {
    d3.select(graphSVG)
      .select('g.node-group')
      .selectAll('circle')
      .transition('node-radius')
      .duration(animationTime)
      .ease(ease)
      .attr('r', (d) =>
        currentLayout.value === 'force'
          ? nodeRadiusScale(+d.saliency)
          : minNodeRadius
      );
  };

  const initForceSim = (nodeRadiusScale) => {
    // Force 1 (ManyBody force)
    simulation.force(
      'charge',
      d3.forceManyBody().strength(forceStrength.force.manyBody)
    );

    // Force 2 (Center force)
    simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));

    // Force 3 (Link force)
    simulation.force(
      'attentionLink',
      d3.forceLink(linkArrays[curLinkI].links).id((d) => d.id)
    );

    // Force 4 (Text order link force)
    simulation.force(
      'textLink',
      d3
        .forceLink(linkArrays[curLinkI].hiddenLinks)
        .id((d) => d.id)
        .strength((d) =>
          d.target.index === 0 ? 0 : forceStrength.force.textOrder
        )
    );

    // Force 5 (Collide force)
    simulation.force(
      'collide',
      d3
        .forceCollide()
        .radius(
          (d) => nodeRadiusScale(d.saliency) + forceStrength.force.collideRadius
        )
    );
  };

  const initRadialSim = () => {
    // Force 1 (Tex order link force)
    simulation.force(
      'textLink',
      d3
        .forceLink(linkArrays[curLinkI].hiddenLinks)
        .id((d) => d.id)
        .strength(forceStrength.radial.textOrder)
    );

    // Force 2 (Custom radial force)
    simulation.force(
      'posY',
      d3
        .forceY()
        .y((d, i) => {
          let curLen = originalNodes.filter((d) => !d.hidden).length;
          let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / curLen);
          return SVGHeight / 2 + Math.sin(curAngle) * radialRadius;
        })
        .strength(forceStrength.radial.radial)
    );

    simulation.force(
      'posX',
      d3
        .forceX()
        .x((d, i) => {
          let curLen = originalNodes.filter((d) => !d.hidden).length;
          let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / curLen);
          return SVGWidth / 2 + Math.cos(curAngle) * radialRadius;
        })
        .strength(forceStrength.radial.radial)
    );
  };

  const initGridSim = () => {
    let curGridRowSize = gridRowSize;
    let gridColumnSize = Math.ceil(tokenSize / curGridRowSize);

    let rowLength =
      gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;
    let columnLength =
      gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;

    // Check if we need to increase the row size
    while (columnLength > SVGHeight) {
      curGridRowSize = gridRowSize + 1;
      rowLength =
        gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;
      columnLength =
        gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;

      if (rowLength > SVGWidth) {
        console.log('Failed to initialize grid layout');
        break;
      }
    }

    let xs = Math.floor((SVGWidth - rowLength) / 2);
    let ys = Math.floor((SVGHeight - columnLength) / 2);

    // Force 3 (Grid force)
    simulation.force(
      'grid',
      d3
        .forceLink(linkArrays[curLinkI].gridLinks)
        .iterations(80)
        .distance(50)
        .id((d) => d.id)
    );

    // Force 4 (Orientation force)
    simulation.force(
      'posX',
      d3
        .forceX()
        .x(
          (d, i) =>
            xs +
            (i % gridRowSize) * (2 * minNodeRadius + gridColumnGap) +
            minNodeRadius
        )
        .strength((d) => (d.id === undefined ? 0 : 1))
    );

    simulation.force(
      'posY',
      d3
        .forceY()
        .y(
          (d, i) =>
            ys +
            Math.floor(i / gridRowSize) * (2 * minNodeRadius + gridRowGap) +
            minNodeRadius
        )
        .strength((d) => (d.id === undefined ? 0 : 1))
    );
  };

  const initCurrentSim = (nodeRadiusScale) => {
    switch (currentLayout.value) {
      case 'force':
        initForceSim(nodeRadiusScale);
        break;
      case 'radial':
        initRadialSim();
        break;
      case 'grid':
        initGridSim();
        break;
    }
  };

  const tickLinkForce = (d, nodeRadiusScale) => {
    const sCoord = borderConstraint(d[0], nodeRadiusScale);
    const tCoord = borderConstraint(d[1], nodeRadiusScale);

    if (d.selfLoop) {
      const iCoord = borderConstraint(d[2], nodeRadiusScale);

      // Shorten the distance from source to intermediate point
      let interLen =
        Math.sqrt(
          (tCoord.left - iCoord.left) ** 2 + (tCoord.top - iCoord.top) ** 2
        ) - nodeRadiusScale(d[0].saliency);

      iCoord.left = tCoord.left + ((iCoord.left - tCoord.left) / interLen) * 80;
      iCoord.top = tCoord.top + ((iCoord.top - tCoord.top) / interLen) * 80;

      // Need to handle the arc manually if there is a self loop
      const iVec = [iCoord.left - sCoord.left, iCoord.top - sCoord.top];
      const iVecNorm = Math.sqrt(iVec[0] ** 2 + iVec[1] ** 2);

      // Rotate 90 degree
      // Normalized the rotate direction, use alpha to control magnitude
      const alpha = 50;
      const iVecClock90 = [
        (-iVec[1] / iVecNorm) * alpha,
        (iVec[0] / iVecNorm) * alpha,
      ];
      const iVecCounterClock90 = [
        (iVec[1] / iVecNorm) * alpha,
        (-iVec[0] / iVecNorm) * alpha,
      ];

      const leftControl = [
        sCoord.left + iVec[0] + iVecClock90[0],
        sCoord.top + iVec[1] + iVecClock90[1],
      ];
      const rightControl = [
        sCoord.left + iVec[0] + iVecCounterClock90[0],
        sCoord.top + iVec[1] + iVecCounterClock90[1],
      ];

      // We need to shorten the path to leave space for arrow
      let halfLen = Math.sqrt(
        (tCoord.left - rightControl[0]) ** 2 +
          (tCoord.top - rightControl[1]) ** 2
      );
      let theta = (nodeRadiusScale(d[0].saliency) + 10) / halfLen;
      let modTCoord = {
        left: tCoord.left + (rightControl[0] - tCoord.left) * theta,
        top: tCoord.top + (rightControl[1] - tCoord.top) * theta,
      };

      // Draw a bezier curve with two control points (which are left and right
      // perpendicular to the self loop node -> intermediate node vector)
      return (
        'M' +
        sCoord.left +
        ',' +
        sCoord.top +
        'C' +
        leftControl[0] +
        ',' +
        leftControl[1] +
        ' ' +
        rightControl[0] +
        ',' +
        rightControl[1] +
        ' ' +
        modTCoord.left +
        ',' +
        modTCoord.top
      );
    } else {
      // We need to shorten the path to leave space for arrow
      let vecLen = Math.sqrt(
        (tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2
      );
      let theta = (nodeRadiusScale(d[1].saliency) + 10) / vecLen;
      let modTCoord = {
        left: tCoord.left + (sCoord.left - tCoord.left) * theta,
        top: tCoord.top + (sCoord.top - tCoord.top) * theta,
      };
      return (
        'M' +
        sCoord.left +
        ',' +
        sCoord.top +
        'L' +
        modTCoord.left +
        ',' +
        modTCoord.top
      );
    }
  };

  const tickNodeForce = (d, nodeRadiusScale) => {
    // Maker sure the nodes are inside the box
    const coord = borderConstraint(d, nodeRadiusScale);
    return `translate(${coord.left}, ${coord.top})`;
  };

  const tickLinkRadial = (d, nodeRadiusScale) => {
    const sCoord = borderConstraint(d[0], nodeRadiusScale);
    const tCoord = borderConstraint(d[1], nodeRadiusScale);

    let source = { x: sCoord.left, y: sCoord.top };
    let target = { x: tCoord.left, y: tCoord.top };
    let center = { x: SVGWidth / 2, y: SVGHeight / 2 + 40 };

    // We need to shorten the path to leave space for arrow
    let theta = 1 - (minNodeRadius + 10) / radialRadius;
    let modTarget = {
      x: center.x + (target.x - center.x) * theta,
      y: center.y + (target.y - center.y) * theta,
    };

    let modSource = {
      x: center.x + (source.x - center.x) * theta,
      y: center.y + (source.y - center.y) * theta,
    };

    // Two control points symmetric regarding the center point
    let controlP1 = {
      x: center.x + (modSource.x - center.x) * radialCurveAlpha,
      y: center.y + (modSource.y - center.x) * radialCurveAlpha,
    };

    let controlP2 = {
      x: center.x + (modTarget.x - center.x) * radialCurveAlpha,
      y: center.y + (modTarget.y - center.x) * radialCurveAlpha,
    };

    return `M ${modSource.x},${modSource.y} C${controlP1.x}, ${controlP1.y},
      ${controlP2.x}, ${controlP2.y}, ${modTarget.x},${modTarget.y}`;
  };

  const tickLinkGrid = (d, nodeRadiusScale) => {
    const sCoord = borderConstraint(d[0], nodeRadiusScale);
    const tCoord = borderConstraint(d[1], nodeRadiusScale);

    // We need to shorten the path to leave space for arrow
    let halfLen = Math.sqrt(
      (tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2
    );

    let theta = (minNodeRadius + 10) / halfLen;
    let modTCoord = {
      left: tCoord.left + (sCoord.left - tCoord.left) * theta,
      top: tCoord.top + (sCoord.top - tCoord.top) * theta,
    };

    return (
      'M' +
      sCoord.left +
      ',' +
      sCoord.top +
      'L' +
      modTCoord.left +
      ',' +
      modTCoord.top
    );
  };

  const weightThresholdUpdated = (step) => {
    curLinkI = step;

    // Update the svg
    let linkLines = d3
      .select(graphSVG)
      .select('g.attention-link-group')
      .selectAll('path.link')
      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`);

    // Enter
    linkLines
      .enter()
      .append('path')
      .attr('marker-end', 'url(#arrow)')
      .attr('class', 'link')
      .attr('id', (d) => `link-${d[0].id}-${d[1].id}`)
      .style('stroke', 'hsl(150, 74%, 51%)')
      .style('stroke-width', (d) => linkWidth(d.attention))
      .transition()
      .duration(animationTime * 3)
      .ease(ease)
      .style('stroke', linkColor);

    // Exit
    linkLines
      .exit()
      .style('stroke', 'hsl(349, 81%, 57%)')
      .transition()
      .duration(animationTime * 3)
      .ease(ease)
      .style('opacity', 0)
      .on('end', (d, i, g) => {
        d3.select(g[i]).remove();
      });

    // Update the simulation
    simulation.nodes(linkArrays[curLinkI].nodes);
    simulation.alpha(1).restart();
  };

  // Create related link arrays (hiddenLinks, biLinks, and gridLinks)
  const createGraphLinks = (curLinks, nodeByID, nodeIndexArray) => {
    curLinks = curLinks.map((d) => Object.create(d));
    let curNodes = originalNodes.slice();

    // Add text order hidden links
    let curHiddenLinks = [];
    for (let i = 0; i < curNodes.length - 1; i++) {
      let hiddenLink = {
        source: +curNodes[i].id,
        target: +curNodes[i + 1].id,
      };
      curHiddenLinks.push(hiddenLink);
    }

    // Add a connection between the first and last token
    curHiddenLinks.push({
      source: +curNodes[curNodes.length - 1].id,
      target: curNodes[0].id,
    });

    curHiddenLinks = curHiddenLinks.map((d) => Object.create(d));

    // Add intermediate nodes to create bezier curves
    let curBiLinks = [];

    curLinks.forEach((d) => {
      let source = nodeByID.get(d.source);
      let target = nodeByID.get(d.target);
      let curBilink = [source, target];
      curBilink.selfLoop = false;
      curBilink.attention = +d.weight;

      // Add a hidden node if there is a self-loop
      if (source === target) {
        curBilink.selfLoop = true;

        // We cannot keep creating new intermediate nodes (need to be the same
        // object for each source across different threshold)
        let intermediate = { hidden: true };

        if (intermediateNodeMap.has(source)) {
          intermediate = intermediateNodeMap.get(source);
        } else {
          intermediateNodeMap.set(source, intermediate);
        }

        curBilink.push(intermediate);
        curNodes.push(intermediate);
        curLinks.push({ source: intermediate, target: source });
      }

      curBiLinks.push(curBilink);
    });

    // Create grid links
    let curGridLinks = [];
    nodeIndexArray.sort((a, b) => +a - +b);
    for (let i = 0; i < curNodes.length; i++) {
      if ((i % gridRowSize !== gridRowSize - 1) & nodeByID.has(i + 1)) {
        curGridLinks.push({
          source: nodeByID.get(i),
          target: nodeByID.get(i + 1),
        });
      }
      if (nodeByID.has(i + gridRowSize)) {
        curGridLinks.push({
          source: nodeByID.get(i),
          target: nodeByID.get(i + gridRowSize),
        });
      }
    }

    return {
      links: curLinks,
      hiddenLinks: curHiddenLinks,
      biLinks: curBiLinks,
      gridLinks: curGridLinks,
      nodes: curNodes,
    };
  };

  const graphNodeDoubleClickHandler = (
    e,
    nodeGroup,
    linkLineGroup,
    nodeIndexArray,
    nodeIndices,
    nodeRadiusScale,
    nodeByID,
    simulation
  ) => {
    let curNode = d3.select(e.target);
    let curID = curNode.data()[0].id;

    // Delete the node from the nodes array
    for (let i = linkArrays[curLinkI].nodes.length - 1; i >= 0; i--) {
      if (linkArrays[curLinkI].nodes[i].id === curID) {
        linkArrays[curLinkI].nodes.splice(i, 1);
      }
    }

    // Remove the node element on screen
    nodeGroup
      .selectAll('g.node')
      .data(
        linkArrays[curLinkI].nodes.filter((d) => d.id !== undefined),
        (d) => d.id
      )
      .exit()
      .remove();

    // Delete all links connecting to this node
    for (let i = linkArrays[curLinkI].biLinks.length - 1; i >= 0; i--) {
      if (
        (linkArrays[curLinkI].biLinks[i][0].id === curID) |
        (linkArrays[curLinkI].biLinks[i][1].id === curID)
      ) {
        linkArrays[curLinkI].biLinks.splice(i, 1);
      }
    }

    // Delete all attention links connecting to this node
    for (let i = linkArrays[curLinkI].links.length - 1; i >= 0; i--) {
      if (
        (linkArrays[curLinkI].links[i].source.id === curID) |
        (linkArrays[curLinkI].links[i].target.id === curID)
      ) {
        linkArrays[curLinkI].links.splice(i, 1);
      }
    }

    // Rewire the text order link array
    for (let i = linkArrays[curLinkI].hiddenLinks.length - 1; i >= 0; i--) {
      if (linkArrays[curLinkI].hiddenLinks[i].source.id === curID) {
        linkArrays[curLinkI].hiddenLinks.splice(i, 1);
      } else if (linkArrays[curLinkI].hiddenLinks[i].target.id === curID) {
        if (i + 1 < linkArrays[curLinkI].hiddenLinks.length) {
          linkArrays[curLinkI].hiddenLinks[i].target =
            linkArrays[curLinkI].hiddenLinks[i + 1].source;
        } else {
          linkArrays[curLinkI].hiddenLinks[i].target =
            linkArrays[curLinkI].hiddenLinks[0].source;
        }
      }
    }

    // Need to reconstruct the grid links
    linkArrays[curLinkI].gridLinks = [];
    nodeIndices = new Set();
    linkArrays[curLinkI].nodes.forEach((d) => {
      if (d.id !== undefined) nodeIndices.add(+d.id);
    });
    nodeIndexArray = Array.from(nodeIndices);
    nodeIndexArray.sort((a, b) => +a - +b);

    for (let i = 0; i < nodeIndexArray.length - 1; i++) {
      let curI = nodeIndexArray[i];
      if (
        (i % gridRowSize !== gridRowSize - 1) &
        nodeByID.has(nodeIndexArray[i + 1])
      ) {
        linkArrays[curLinkI].gridLinks.push({
          source: nodeByID.get(curI),
          target: nodeByID.get(nodeIndexArray[i + 1]),
        });
      }
      if (nodeByID.has(nodeIndexArray[i + gridRowSize])) {
        linkArrays[curLinkI].gridLinks.push({
          source: nodeByID.get(curI),
          target: nodeByID.get(nodeIndexArray[i + gridRowSize]),
        });
      }
    }

    linkLineGroup
      .selectAll('path.link')
      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`)
      .exit()
      .remove();

    initCurrentSim(nodeRadiusScale);
    simulation.alpha(0.3).restart();
  };

  const simulationTick = (nodeRadiusScale) => {
    // console.log('Tick');

    let linkLines = d3
      .select(graphSVG)
      .select('g.attention-link-group')
      .selectAll('path.link');

    // Update the attention links
    switch (currentLayout.value) {
      case 'force':
        linkLines.attr('d', (d) => tickLinkForce(d, nodeRadiusScale));
        break;
      case 'radial':
        linkLines.attr('d', (d) => tickLinkRadial(d, nodeRadiusScale));
        break;
      case 'grid':
        linkLines.attr('d', (d) => tickLinkGrid(d, nodeRadiusScale));
        break;
      default:
        console.log('Unexpected case.');
    }

    // Update the nodes
    d3.select(graphSVG)
      .select('g.node-group')
      .selectAll('g.node')
      .attr('transform', (d) => tickNodeForce(d, nodeRadiusScale));
  };

  const drawSaliencyLegend = (
    legendGroup,
    legendPos,
    largestAbs,
    leftColor = '#eb2f06',
    rightColor = '#4690C2'
  ) => {
    // Define the gradient
    let legendGradientDef = legendGroup
      .append('defs')
      .append('linearGradient')
      .attr('x1', 0)
      .attr('y1', 1)
      .attr('x2', 0)
      .attr('y2', 0)
      .attr('id', 'legend-gradient-graph');

    legendGradientDef
      .append('stop')
      .attr('stop-color', leftColor)
      .attr('offset', 0);

    legendGradientDef
      .append('stop')
      .attr('stop-color', rightColor)
      .attr('offset', 1);

    legendGroup
      .append('rect')
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', legendPos.width)
      .attr('height', legendPos.height)
      .style('fill', 'url(#legend-gradient-graph)')
      .style('stroke', 'black');

    // Draw the legend axis
    let legendScale = d3
      .scaleLinear()
      .domain([0, largestAbs])
      .range([legendPos.height, 0])
      .nice();

    legendGroup
      .append('g')
      .attr('transform', `translate(${legendPos.width}, ${0})`)
      .call(d3.axisRight(legendScale).ticks(5));

    legendGroup
      .append('text')
      .attr('x', 0)
      .attr('y', legendPos.height + 8)
      .style('font-size', '12px')
      .style('fill', 'hsl(0, 0%, 40%)')
      .style('dominant-baseline', 'hanging')
      .style('text-anchor', 'left')
      .text('Semantic Saliency Score');
  };

  const initGraph = () => {
    let svg = d3.select(graphSVG);

    // Map nodes and links to arrays of objects
    let nodes = graphData.nodes.map((d) => Object.create(d));
    nodes.sort((a, b) => +a.id - +b.id);

    // Give each saliency token a unique name
    let tokenCount = {};
    nodes.forEach((d) => {
      let curCount = 0;
      if (tokenCount[d.token] === undefined) {
        tokenCount[d.token] = curCount + 1;
      } else {
        curCount = tokenCount[d.token];
        tokenCount[d.token] += 1;
      }
      d.name = `${tokenIDName(d.token)}-${curCount}`;
    });

    originalNodes = nodes.slice();

    // Maintain a set of all existing node indices
    let nodeIndices = new Set();
    graphData.nodes.forEach((d) => nodeIndices.add(+d.id));
    let nodeIndexArray = Array.from(nodeIndices);

    let nodeByID = new Map(nodes.map((d) => [d.id, d]));

    // Create link arrays at different range steps
    linkArrays = {};
    for (let i = 0; i < weightThresholdSteps; i++) {
      let curWeightThreshold = round(
        weightThresholdMin + i * weightThresholdGap,
        2
      );
      let links = graphData.links.filter((d) => d.weight > curWeightThreshold);
      let linkResult = createGraphLinks(links, nodeByID, nodeIndexArray);

      linkArrays[i] = {
        links: linkResult.links.slice(),
        hiddenLinks: linkResult.hiddenLinks.slice(),
        biLinks: linkResult.biLinks.slice(),
        gridLinks: linkResult.gridLinks.slice(),
        nodes: linkResult.nodes.slice(),
      };
    }

    // Create a scale for the node radius
    let allSaliencyScores = nodes.map((d) => +d.saliency);
    // console.log(d3.extent(allSaliencyScores));
    nodeRadiusScale = d3
      .scaleLinear()
      .domain(d3.extent(allSaliencyScores))
      .range([minNodeRadius, maxNodeRadius])
      .unknown(0)
      .nice();

    // Create a scale for the node color
    let largestAbs = d3.max(allSaliencyScores.map(Math.abs));
    let rightColor = '#E50035';
    let leftColor = '#ffffff';

    let nodeSaliencyColorScale = d3
      .scaleLinear()
      .domain([0, largestAbs])
      .range([d3.rgb(leftColor), d3.rgb(rightColor)])
      .unknown(d3.rgb('white'));

    // Create a scale for link stroke width
    let attentionWeights = linkArrays[0].links.map((d) => +d.weight);
    linkWidth = d3
      .scaleLinear()
      .domain(d3.extent(attentionWeights))
      .range([0.5, 3])
      .nice();

    // Add attention links
    let linkLineGroup = svg
      .append('g')
      .attr('class', 'attention-link-group')
      .attr('stroke', linkColor);

    linkLineGroup
      .selectAll('path.link')
      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`)
      .join('path')
      .attr('class', 'link')
      .attr('id', (d) => `link-${d[0].name}-${d[1].name}`)
      .attr('marker-end', 'url(#arrow)')
      .style('stroke-width', (d) => linkWidth(d.attention));

    // Add token nodes
    let nodeGroup = svg.append('g').attr('class', 'node-group');

    let nodeGroups = nodeGroup
      .selectAll('g.node')
      // Need to filter out intermediate nodes
      .data(
        linkArrays[curLinkI].nodes.filter((d) => d.id !== undefined),
        (d) => d.id
      )
      .join('g')
      .attr('class', 'node')
      .attr('id', (d) => `node-${d.name}`)
      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)
      .call(drag())
      // Hover over effect
      .on('mouseover', (e, d) => {
        curHoverToken = d.name;
        hoverTokenStore.set(curHoverToken);
        highLightLink(curHoverToken);
      })
      .on('mouseleave', () => {
        dehighlightLink(curHoverToken);
        curHoverToken = null;
        hoverTokenStore.set(curHoverToken);
      })
      // Single click to remove fixing
      .on('click', (e, d) => {
        if (d.fx !== null && d.fy !== null) {
          // Unfix the node
          delete d.fx;
          delete d.fy;

          // Remove the fixing marker
          d3.select(e.target.parentNode)
            .selectAll('rect.fixed-marker')
            .remove();

          simulation.alpha(0.2).restart();
        }
      })
      // Double click to remove the node
      .on('dblclick', (e) =>
        graphNodeDoubleClickHandler(
          e,
          nodeGroup,
          linkLineGroup,
          nodeIndexArray,
          nodeIndices,
          nodeRadiusScale,
          nodeByID,
          simulation
        )
      );

    // Add circle to each node
    // Create a color scale to represent the text order
    let colorScale = d3
      .scaleLinear()
      .domain(d3.extent(nodeIndices))
      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);

    nodeGroups
      .append('circle')
      .attr('class', 'node-circle')
      .attr('r', (d) =>
        currentLayout.value === 'force'
          ? nodeRadiusScale(+d.saliency)
          : minNodeRadius
      )
      // .style('fill', d => colorScale(d.id))
      .style('fill', (d) => nodeSaliencyColorScale(+d.saliency))
      .style('opacity', 1)
      .clone(true)
      .attr('r', (d) =>
        currentLayout.value === 'force'
          ? nodeRadiusScale(+d.saliency)
          : minNodeRadius
      )
      .style('fill', linkHoverColor)
      .attr('class', 'shadow-circle');

    // Create legend for the saliency map view
    let legendGroup = svg
      .append('g')
      .attr('class', 'legend-group')
      .attr(
        'transform',
        `translate(${SVGPadding.left + 3}, ${SVGHeight - 130})`
      );

    let legendPos = { width: 10, height: 100 };

    drawSaliencyLegend(
      legendGroup,
      legendPos,
      largestAbs,
      leftColor,
      rightColor
    );

    // Add token text to each node
    let texts = nodeGroups
      .append('text')
      .attr('class', 'node-text')
      .style('font-weight', 600)
      .text((d) => d.token);

    texts
      .filter((d) => d3.hcl(nodeSaliencyColorScale(+d.saliency)).l < 66)
      .clone(true)
      .lower()
      .style('stroke-linejoin', 'round')
      .attr('stroke-width', 4)
      .attr('stroke', 'white');

    nodeGroups.selectAll('circle').lower();

    nodeGroups.append('title').text((d) => d.token);

    // Define the force
    // Use the min threshold to init the simulation (it includes the most hidden nodes)
    if (simulation == null) {
      simulation = d3.forceSimulation(linkArrays[curLinkI].nodes);
      // Change the min alpha so that the nodes do not shake at the end (end earlier)
      // The default alphaMin is 0.000
      // simulation.alphaMin(0.001);
    } else {
      simulation.nodes(linkArrays[curLinkI].nodes);
      simulation.alpha(1).restart();
    }

    switch (currentLayout.value) {
      case 'force':
        initForceSim(nodeRadiusScale);
        break;
      case 'radial':
        initRadialSim();
        break;
      case 'grid':
        initGridSim();
        break;
    }

    // Simulation tick updates
    simulation.on('tick', () => simulationTick(nodeRadiusScale));

    return nodeRadiusScale;
  };

  const drawGraph = () => {
    // Filter the links based on the weight
    // weightThreshold = 0.05;

    let svg = d3
      .select(graphSVG)
      .attr('width', SVGWidth)
      .attr('height', SVGHeight);

    // Add a border
    svg
      .append('rect')
      .attr('class', 'border-rect')
      .attr('width', SVGWidth)
      .attr('height', SVGHeight)
      .style('stroke', 'black')
      .style('fill', 'none');

    // Add arrow markers
    svg
      .append('defs')
      .append('marker')
      .attr('id', 'arrow')
      .attr('viewBox', [0, 0, 10, 10])
      .attr('refX', 0)
      .attr('refY', 5)
      .attr('markerWidth', 12)
      .attr('markerHeight', 9)
      .attr('orient', 'auto')
      .attr('stroke-width', 1)
      .attr('markerUnits', 'userSpaceOnUse')
      .append('path')
      .attr('d', 'M 0 0 L 10 5 L 0 10 z')
      .attr('stroke', linkColor)
      .attr('fill', linkColor);

    // Create a different arrow marked used when user hovers over a node
    svg
      .append('defs')
      .append('marker')
      .attr('id', 'arrow-hover')
      .attr('viewBox', [0, 0, 10, 10])
      .attr('refX', 0)
      .attr('refY', 5)
      .attr('markerWidth', 12)
      .attr('markerHeight', 9)
      .attr('orient', 'auto')
      .attr('stroke-width', 1)
      .attr('markerUnits', 'userSpaceOnUse')
      .append('path')
      .attr('d', 'M 0 0 L 10 5 L 0 10 z')
      .attr('stroke', linkHoverColor)
      .attr('fill', linkHoverColor);

    nodeRadiusScale = initGraph();

    // Register UI elements from the control panel
    bindSlider('attention', 0, 10, forceStrength.force.attention);
    bindSlider('textOrder', 0, 10, forceStrength.force.textOrder);
    bindSlider('manyBody', -2000, 0, forceStrength.force.manyBody);
    bindSlider(
      'collideRadius',
      0,
      20,
      forceStrength.force.collideRadius,
      nodeRadiusScale
    );
    bindSlider(
      'threshold',
      weightThresholdMin,
      weightThresholdMax,
      weightThreshold,
      nodeRadiusScale
    );

    bindSelect(nodeRadiusScale);

    // Bind the layer and head selects
    bindLayerHeadSelect();
  };

  const updateLayerHead = () => {
    // Remove nodes and links
    d3.select(graphSVG).select('g.node-group').remove();

    d3.select(graphSVG).select('g.attention-link-group').remove();

    d3.select(graphSVG).select('g.legend-group').remove();

    // Update the graph data
    graphData = createGraphData(curLayer, curHead);

    initGraph();
  };

  /** Create CSS selector compatible name */
  const tokenIDName = (tokenID) => {
    if (tokenID == null) {
      return null;
    } else {
      return tokenID
        .replace(/\./g, '\\.')
        .replace(/,/g, '\\,')
        .replace(/#/g, '')
        .replace(/\[/g, '\\[')
        .replace(/\]/g, '\\]');
    }
  };

  const highLightLink = (hoverToken) => {
    d3.select(graphSVG)
      .select('.attention-link-group')
      .selectAll('path.link')
      // TODO
      // .style('opacity', 0.05);
      .style('opacity', 0.2);

    d3.select(graphSVG)
      .select('.attention-link-group')
      .selectAll('path.link')
      .filter((d, i, g) =>
        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)
      )
      .attr('marker-end', 'url(#arrow-hover)')
      .classed('highlighted', true)
      .style('stroke', null)
      .style('stroke-width', 2)
      .style('opacity', 0.8)
      .raise();
    // TODO
    // .style('opacity', 0.9)
    // .style('stroke-width', 2)
    // .raise();

    d3.select(graphSVG)
      .select('.node-group')
      .selectAll('.node')
      .filter((d, i, g) =>
        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)
      )
      .raise()
      .select('.shadow-circle')
      .attr('r', (d) =>
        currentLayout.value === 'force'
          ? nodeRadiusScale(+d.saliency) + 5
          : minNodeRadius + 5
      )
      .style('stroke', 'white')
      .style('stroke-width', 1.5);
  };

  const dehighlightLink = (hoverToken) => {
    // TODO
    // return;
    // if (hoverToken.includes('jagged')) {
    //   return;
    // }

    d3.select(graphSVG)
      .select('.attention-link-group')
      .selectAll('path.link')
      .style('opacity', null);

    d3.select(graphSVG)
      .select('.attention-link-group')
      .selectAll('path.link')
      .filter((d, i, g) =>
        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)
      )
      .classed('highlighted', false)
      .attr('marker-end', 'url(#arrow)')
      .style('stroke', linkColor)
      .style('stroke-width', (d) => linkWidth(d.attention))
      .style('opacity', null);

    d3.select(graphSVG)
      .select('.node-group')
      .selectAll('.node')
      .filter((d, i, g) =>
        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)
      )
      .select('.shadow-circle')
      .attr('r', (d) =>
        currentLayout.value === 'force'
          ? nodeRadiusScale(+d.saliency)
          : minNodeRadius
      )
      .style('stroke', null)
      .style('stroke-width', null)
      .lower();
  };

  const createGraphData = (layer, head) => {
    let curAttention = attentionData[layer][head];
    let curAttentionData = { nodes: [], links: [] };
    let curPredictedLabel =
      saliencyData[String(instanceID)]['meta']['predicted_label'];

    // Add nodes
    saliencyData[String(instanceID)]['tokens'].forEach((d, i) => {
      curAttentionData.nodes.push({
        token: d.token,
        saliency: d[curPredictedLabel],
        id: i,
      });
    });

    // Add links
    for (let i = 0; i < curAttentionData.nodes.length; i++) {
      for (let j = 0; j < curAttentionData.nodes.length; j++) {
        curAttentionData.links.push({
          source: i,
          target: j,
          weight: curAttention[i][j],
        });
      }
    }

    return curAttentionData;
  };

  const settingIconClicked = () => {
    if (settingIconActive) {
      settingIconActive = false;
    } else {
      settingIconActive = true;
    }
  };

  hoverTokenStore.subscribe((value) => {
    if (value != null) {
      curHoverToken = value;

      // Check if the coming word has split subwords in graph vis
      if (
        wordToSubwordMap[curHoverToken.replace(/(.*)-\d*/, '$1')] !== undefined
      ) {
        wordToSubwordMap[curHoverToken.replace(/(.*)-\d*/, '$1')].forEach(
          (t) => {
            highLightLink(t);
          }
        );
      } else {
        highLightLink(curHoverToken);
      }
    } else {
      if (curHoverToken != null) {
        // Check if the coming word has split subwords in graph vis
        if (
          wordToSubwordMap[curHoverToken.replace(/(.*)-\d*/, '$1')] !==
          undefined
        ) {
          wordToSubwordMap[curHoverToken.replace(/(.*)-\d*/, '$1')].forEach(
            (t) => {
              dehighlightLink(t);
            }
          );
        } else {
          dehighlightLink(curHoverToken);
        }
      }

      curHoverToken = value;
    }
  });

  const renderGraph = async () => {
    // console.log('loading matrix');

    // Load data from files if they have not been loaded
    if (attentionData == null) {
      attentionData = await d3.json(
        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`
      );
    }
    if (saliencyData == null) {
      saliencyData = await d3.json(saliencyDataFilepath);
      tokenSize = saliencyData[instanceID].tokens.length;
    }

    // Create graph data
    graphData = createGraphData(curLayer, curHead);

    // graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');
    // console.log('loaded matrix');

    drawGraph();
  };

  onMount(async () => {
    if (attentionData == null) {
      attentionData = await d3.json(
        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`
      );
    }

    if (saliencyData == null) {
      saliencyData = await d3.json(saliencyDataFilepath);
      tokenSize = saliencyData[instanceID].tokens.length;
    }

    // gradSortedIndexes = await d3.json('PUBLIC_URL/data/sst2-sorted-grad-heads.json');
    // gradSortedIndexes = gradSortedIndexes[instanceID];
    // relevantAttentions = loadAttentionMatrix();
    // console.log(relevantAttentions, saliencyData);
    // console.log(tokenSize);

    mounted = true;
  });

  graphViewConfigStore.subscribe((value) => {
    if (value.compHeight !== undefined && value.compWidth !== undefined) {
      if (
        graphViewCompConfig === undefined ||
        (graphViewCompConfig.compHeight !== value.compHeight &&
          graphViewCompConfig.compWidth !== value.compWidth)
      ) {
        // Update the height and width
        graphViewCompConfig = value;
        SVGHeight = graphViewCompConfig.compHeight;
        SVGWidth = graphViewCompConfig.compWidth;
        renderGraph();
      }
    }
  });

  wordToSubwordMapStore.subscribe((value) => {
    wordToSubwordMap = value;
  });

  instanceIDStore.subscribe((value) => {
    // console.log('Instance changed!!');
    if (value !== instanceID) {
      d3.select(graphSVG).selectAll('*').remove();

      attentionData = null;
      saliencyData = null;

      instanceID = value;

      renderGraph();
    }
  });
</script>

<style lang="scss">
  @import 'define';

  .graph-view {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100%;
  }

  :global(.node-circle) {
    stroke: #fff;
    stroke-width: 1.5;
  }

  :global(.node-text) {
    dominant-baseline: middle;
    text-anchor: middle;
    font-size: 10px;
    cursor: default;
  }

  :global(.link) {
    fill: none;
  }

  :global(.link.highlighted) {
    stroke: hsl(36, 100%, 55%);
  }

  :global(.border-rect) {
    display: none;
  }

  .graph-label {
    position: absolute;
    color: hsl(0, 0%, 50%);
    font-size: 1.3rem;
    margin: 5px 20px 0 20px;
  }

  .svg-container {
    position: relative;
  }

  .svg-control-panel {
    position: absolute;
    top: 40px;
    left: 0;
    width: 200px;
    cursor: default;

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;

    font-size: 0.9em;
    border-radius: 5px;
    border: 1px solid change-color($brown-dark, $lightness: 90%);
    box-shadow: 0 3px 3px change-color($brown-dark, $alpha: 0.05);
    background: hsla(0, 0%, 100%, 0.65);

    .name {
      font-size: 1em;
      width: 94%;
      padding: 5px 0px;
      display: flex;
      flex-direction: row;
      justify-content: space-around;
    }
  }

  .sep-line-horizontal {
    height: 0;
    width: 95%;
    border: 1px solid $gray-sep;
  }

  .sep-line-vertical {
    height: 20px;
    width: 0;
    border: 1px solid $gray-sep;
  }

  select {
    height: 1.8em;
    background: inherit;
    border-color: hsla(0, 0%, 0%, 0);
    padding: 0 1em 0 0.4em;

    &.select-num {
      padding: 0 8px 0 0;
      height: auto;
      border-bottom: 3px solid change-color($brown-icon, $alpha: 0.2);
    }
  }

  .select-num-div::after {
    top: 50%;
    z-index: 0;
  }

  .select:not(.is-multiple) {
    height: 1.8em;
  }

  .select:not(.is-multiple):not(.is-loading)::after {
    right: 0.2em;
    border-color: $brown-icon;
    z-index: 0;
  }

  .select:not(.is-multiple).select-num-div {
    height: auto;

    select {
      margin: 0;
    }
  }

  .select:not(.is-multiple).select-num-div::after {
    right: 0.1em;
    z-index: 0;
  }

  .select-row {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    width: 94%;
    padding: 3px 0;
  }

  .setting-icon {
    padding: 0.1em 0.4em;
    margin: 0 0.2em;
    font-size: 1.1em;
    color: $brown-icon;
    cursor: pointer;
    border-radius: 3px;

    transition: background 100ms ease-in-out;

    &:hover {
      background: change-color($brown-icon, $alpha: 0.1);
    }

    &.active {
      background: change-color($brown-icon, $alpha: 0.2);

      &:hover {
        background: change-color($brown-icon, $alpha: 0.2);
      }
    }
  }

  .slider-container {
    font-size: 0.9em;
    padding: 0 15px 0 15px;

    display: flex;
    flex-direction: column;
    align-items: center;

    max-height: 0;
    overflow: hidden;
    transition: max-height 150ms ease-in-out;

    input {
      width: 130px;
    }

    .sep-line-horizontal {
      width: 70%;
      margin: 3px 0 10px 0;

      &.longer-line {
        width: 115%;
        margin: 0 0 10px 0;
      }
    }

    &.active {
      max-height: 500px;
      transition: max-height 300ms ease-in-out;
    }
  }

  .slider {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .slider-title {
    color: change-color(black, $alpha: 0.5);
  }

  .slider-text {
    display: flex;
    flex-direction: row;

    label {
      margin-right: 5px;
    }
  }

  .slider-value {
    border-radius: 3px;
    padding: 0 3px;
    background: change-color($brown-icon, $alpha: 0.2);
    color: change-color($brown-icon, $lightness: 40%);
  }
</style>

<div class="graph-view">
  <div class="svg-container">
    <div class="graph-label">Semantic Attention Graph</div>

    <!-- Control panel on top of the SVG -->
    <div class="svg-control-panel">
      <div class="name">
        <div>
          Layer
          <div class="select select-num-div">
            <select name="layer" class="select-num" id="select-layer">
              {#each [...Array(12).keys()] as num}
                <option value={num}>{num + 1}</option>
              {/each}
            </select>
          </div>
        </div>

        <div>
          Head
          <div class="select select-num-div">
            <select name="layer" class="select-num" id="select-head">
              {#each [...Array(12).keys()] as num}
                <option value={num}>{num + 1}</option>
              {/each}
            </select>
          </div>
        </div>
      </div>

      <div class="sep-line-horizontal" />

      <div class="select-row">
        <div
          class="setting-icon"
          on:click={settingIconClicked}
          class:active={settingIconActive}
        >
          <i class="fas fa-sliders-h" />
        </div>

        <div class="sep-line-vertical" />

        <div class="select">
          <select name="layout" id="select-layout">
            {#each Object.values(layoutOptions) as opt}
              <option value={opt.value}>{opt.name}</option>
            {/each}
          </select>
        </div>
      </div>

      <!-- Slider panel -->
      <div class="slider-container" class:active={settingIconActive}>
        <div class="sep-line-horizontal longer-line" />

        <div class="slider-title">Edge Force</div>

        <div class="sep-line-horizontal" />

        <div class="slider">
          <div class="slider-text">
            <label for="attention">Attention</label>
            <div class="slider-value">
              {config.autoAttention
                ? 'auto'
                : round(forceStrength.force.attention, 2)}
            </div>
          </div>

          <input
            type="range"
            min="0"
            max="1000"
            value="500"
            class="slider"
            id="attention"
          />
        </div>

        <div class="slider">
          <div class="slider-text">
            <label for="textOrder">Text Order</label>
            <div class="slider-value">
              {round(forceStrength.force.textOrder, 2)}
            </div>
          </div>

          <input
            type="range"
            min="0"
            max="1000"
            value="500"
            class="slider"
            id="textOrder"
          />
        </div>

        <div class="slider">
          <div class="slider-text">
            <label for="manyBody">ManyBody</label>
            <div class="slider-value">
              {round(forceStrength.force.manyBody, 2)}
            </div>
          </div>

          <input
            type="range"
            min="0"
            max="1000"
            value="500"
            class="slider"
            id="manyBody"
          />
        </div>

        <div class="slider">
          <div class="slider-text">
            <label for="collide">Node Distance</label>
            <div class="slider-value">
              {round(forceStrength.force.collideRadius, 2)}
            </div>
          </div>

          <input
            type="range"
            min="0"
            max="1000"
            value="500"
            class="slider"
            id="collideRadius"
          />
        </div>

        <div class="slider-title">Edge Threshold</div>

        <div class="sep-line-horizontal" />

        <div class="slider">
          <div class="slider-text">
            <label for="threshold">Attention > </label>
            <div class="slider-value">
              {round(weightThreshold, 2)}
            </div>
          </div>

          <input
            type="range"
            min="0"
            max="1000"
            value="500"
            step="200"
            class="slider"
            id="threshold"
          />
        </div>
      </div>
    </div>

    <svg class="graph-svg" bind:this={graphSVG} />
  </div>
</div>
