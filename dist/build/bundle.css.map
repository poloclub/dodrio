{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "Atlas.svelte",
    "AtlasSide.svelte",
    "CircleView.svelte",
    "GraphView.svelte",
    "GridView.svelte",
    "Header.svelte",
    "LowerAtlas.svelte",
    "Main.svelte",
    "RadialView.svelte",
    "Saliency.svelte",
    "TableModal.svelte",
    "TableView.svelte",
    "TextClassificationStats.svelte",
    "Tooltip.svelte",
    "TooltipGlobal.svelte",
    "Dependency.svelte",
    "RadialModal.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { onMount } from 'svelte';\n  import { mapViewConfigStore, sideStore, instanceIDStore,\n    attentionHeadColorStore, tooltipConfigStore, mapHeadStore } from './store';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  let svg = null;\n  let atlasData = null;\n  let attentions = null;\n  let saliencies = null;\n  let tokenSize = null;\n\n  // Tooltip variables\n  let tooltipConfig = null;\n  tooltipConfigStore.subscribe(value => {tooltipConfig = value;});\n\n  let sideInfo = null;\n\n  let viewContainer = null;\n  let mapHead = {layer: 9, head: 8};\n  let curLayer = 9;\n  let curHead = 8;\n\n  const red = d3.hcl(23, 85, 56);\n  const purple = d3.hcl(328, 85, 56);\n  const blue = d3.hcl(274, 85, 56);\n\n  let instanceID = 1562;\n\n  const dispatch = createEventDispatcher();\n  let isShown = true;\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n\n  const SVGPadding = {top: 40, left: 10, right: 10, bottom: 3};\n\n  const ease = d3.easeCubicInOut;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const createGraph = () => {\n\n    const layerNum = attentions.length;\n    const headNum = attentions[0].length;\n    const layerNameWidth = 47;\n    const headNameHeight = 20;\n\n    // console.log(SVGWidth, SVGHeight);\n\n    let availableWidth = SVGWidth - 210 - layerNameWidth - SVGPadding.left - SVGPadding.right;\n    let availableHeight = SVGHeight - SVGPadding.top - SVGPadding.bottom - headNameHeight;\n\n    let availableLength = Math.min(availableHeight, availableWidth);\n    // console.log(SVGHeight, availableLength, availableWidth, availableHeight);\n    const gridGap = 8;\n\n    const gridLength = Math.floor((availableHeight - (layerNum - 1) * gridGap) / layerNum);\n    const maxOutRadius = gridLength / 2;\n    const minOutRadius = 10;\n\n    let adjustedRowGap = Math.floor((availableWidth - maxOutRadius - headNum * gridLength) / (layerNum - 1));\n    let adjustedColGap = Math.floor((availableHeight - layerNum * gridLength) / (layerNum - 1));\n\n    svg = d3.select('.atlas-svg-full')\n      .attr('viewbox', `0 0 ${availableWidth + layerNameWidth} ${availableHeight}`)\n      .attr('width', availableWidth + layerNameWidth)\n      .attr('height', availableHeight + headNameHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', availableLength)\n      .attr('height', availableLength)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    let donutGroup = svg.append('g')\n      .attr('class', 'donut-group')\n      .attr('transform', `translate(${SVGPadding.left + maxOutRadius + layerNameWidth},\n        ${maxOutRadius + headNameHeight})`);\n    \n    // Create color scale\n    let hueScale = d3.scaleLinear()\n      .domain([-1, 0, 1])\n      .range([red, purple, blue]);\n\n    let lightnessScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([130, 40]);\n\n    // Use square root scale\n    let outRadiusScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([minOutRadius, maxOutRadius]);\n\n    let ringRadiusScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([4, 7]);\n\n    let scales = {\n      hueScale: hueScale,\n      lightnessScale: lightnessScale,\n      outRadiusScale: outRadiusScale,\n      ringRadiusScale: ringRadiusScale\n    };\n\n    let donuts = donutGroup.selectAll('g.donut')\n      .data(atlasData)\n      .join('g')\n      .attr('class', 'donut')\n      .attr('transform', d => `translate(${d.head * (maxOutRadius * 2 + adjustedRowGap)},\n        ${(layerNum - d.layer - 1) * (maxOutRadius * 2 + adjustedColGap)})`)\n      .style('pointer-events', 'fill')\n      .style('cursor', 'pointer');\n\n    // Draw the donuts\n    donuts.each((d, i, g) => drawDonut(d, i, g, scales));\n\n    donuts.on('mouseover',\n      (e, d) => {\n        // Show the tooltip\n        let node = e.currentTarget;\n        let position = node.getBoundingClientRect();\n        let curWidth = position.right - position.left;\n\n        let tooltipCenterX = position.x + curWidth / 2;\n        let tooltipCenterY = position.y - 90;\n\n        tooltipConfig.html = `\n        <div class='tooltip-tb' style='display: flex; flex-direction: column;\n          justify-content: center; font-weight: 600;'>\n          <div> Layer ${d.layer + 1} Head ${d.head + 1} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Semantic: ${round(d.semantic, 2)} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Syntactic ${round(d.syntactic, 2)} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Importance: ${round(d.confidence, 2)} </div>\n        </div>\n        `;\n        tooltipConfig.width = 130;\n        tooltipConfig.maxWidth = 130;\n        tooltipConfig.left = tooltipCenterX - tooltipConfig.width / 2;\n        tooltipConfig.top = tooltipCenterY;\n        tooltipConfig.fontSize = '0.8em';\n        tooltipConfig.show = true;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Show the background rect\n        let curDonut = d3.select(e.currentTarget);\n\n        if (!curDonut.classed('selected')){\n          curDonut.select('.donut-rect')\n            .style('opacity', 1);\n        }\n      })\n      .on('mouseleave', (e) => {\n        // TODO\n        // let datum = d3.select(e.target).data()[0];\n        // if (datum.layer === 2 && datum.head === 9) {\n        //   return;\n        // }\n\n        tooltipConfig.show = false;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Hide the background rect\n        let curDonut = d3.select(e.currentTarget);\n        if (!curDonut.classed('selected')){\n          curDonut.select('.donut-rect')\n            .style('opacity', 0);\n        }\n\n      })\n      .on('click', (e, d) => {\n        sideInfo.show = true;\n        sideInfo.attention = attentions[d.layer][d.head];\n        sideInfo.tokens = saliencies.tokens.map(d => { return { 'token': d.token }; });\n        sideInfo.layer = d.layer;\n        sideInfo.head = d.head;\n        sideStore.set(sideInfo);\n      })\n      .on('dblclick', (e) => {\n        // console.log('double!');\n        let curDonut = d3.select(e.currentTarget);\n        if (curDonut.classed('selected')) {\n          // pass\n        } else {\n          // Restore the currently selected rect\n          let preDonut = d3.select(\n            donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n              .node().parentNode\n          );\n\n          preDonut.select('.donut-rect')\n            .style('fill', 'hsl(0, 0%, 80%)')\n            .style('opacity', 0);\n          \n          preDonut.classed('selected', false);\n\n          // Style the new rect\n          curDonut.select('.donut-rect')\n            .style('fill', 'hsl(27, 47%, 13%)')\n            .style('opacity', 1);\n          \n          curDonut.classed('selected', true);\n\n          curLayer = +curDonut.data()[0].layer;\n          curHead = +curDonut.data()[0].head;\n\n          mapHead.layer = curLayer;\n          mapHead.head = curHead;\n          mapHeadStore.set(mapHead);\n        }\n      });\n\n    // Draw horizontal lines between rows\n    donutGroup.selectAll('g.row-line-group')\n      .data(Array(layerNum - 1).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'row-line-group')\n      .append('path')\n      .attr('d', d => {\n        return `M${-maxOutRadius}\n        ${(layerNum - d - 1 - 1/2) * (maxOutRadius * 2 + adjustedColGap)}\n        L${headNum * (maxOutRadius * 2 + adjustedRowGap) - maxOutRadius}\n        ${(layerNum - d - 1 - 1/2) * (maxOutRadius * 2 + adjustedColGap)}`;\n      })\n      .style('stroke', 'hsla(0, 0%, 0%, 0.1)');\n\n    // Draw the label names\n    let nameGroup = svg.append('g')\n      .attr('class', 'name-group')\n      .attr('transform', `translate(${SVGPadding.left}, ${maxOutRadius + headNameHeight})`);\n    \n    nameGroup.selectAll('g.layer-name-group')\n      .data(Array(layerNum).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'layer-name-group')\n      .attr('transform', d => `translate(${layerNameWidth - 10},\n        ${(layerNum - d - 1) * (maxOutRadius * 2 + adjustedColGap)})`)\n      .append('text')\n      .text(d => d > 0 ? d + 1 : `Layer ${d + 1}`);\n\n    let headNameGroup = svg.append('g')\n      .attr('class', 'name-group')\n      .attr('transform', `translate(${SVGPadding.left + layerNameWidth + maxOutRadius},\n        ${9})`);\n\n    headNameGroup.selectAll('g.head-name-group')\n      .data(Array(layerNum).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'head-name-group')\n      .attr('transform', d => `translate(${d * (maxOutRadius * 2 + adjustedRowGap)},\n        ${0})`)\n      .append('text')\n      .text(d => d > 0 ? d + 1 : `Head ${d + 1}`);\n\n    d3.select(viewContainer)\n      .select('.head-arrow')\n      .style('top', `${70 - 40}px`)\n      .style('left', `${availableWidth - 170}px`);\n\n    d3.select(viewContainer)\n      .select('.layer-arrow')\n      .style('top', `${70}px`)\n      .style('left', `${availableWidth + 10}px`);\n\n    let curDonut = d3.select(\n      donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n        .node().parentNode\n    );\n\n    // Style the new rect\n    curDonut.select('.donut-rect')\n      .style('fill', 'hsl(27, 47%, 13%)')\n      .style('opacity', 1);\n    \n    curDonut.classed('selected', true);\n  };\n\n  const drawDonut = (d, i, g, scales) => {\n    let donut = d3.select(g[i]);\n\n    let outRadius = scales.outRadiusScale(d.confidence);\n    let ringRadius = scales.ringRadiusScale(d.confidence);\n    let inRadius = Math.max(0, outRadius - ringRadius);\n\n    // Draw the background rect\n    let maxLength = 2 * scales.outRadiusScale.range()[1];\n    donut.append('rect')\n      .attr('class', 'donut-rect')\n      .attr('id', `donut-rect-${d.layer}-${d.head}`)\n      .attr('x', - maxLength / 2)\n      .attr('y', - maxLength / 2)\n      .attr('rx', 5)\n      .attr('width', maxLength)\n      .attr('height', maxLength)\n      .style('fill', 'hsl(0, 0%, 80%)')\n      .style('opacity', 0);\n\n    // Draw an invisible circle for interaction\n    donut.append('circle')\n      .attr('cx', 0)\n      .attr('cy', 0)\n      .attr('r', outRadius)\n      .style('fill', '#FDFCFC')\n      .style('opacity', 1);\n\n    // Draw the rings\n    // Arc's center is at (0, 0) on the local coordinate\n    let arc = d3.arc()\n      .outerRadius(outRadius)\n      .innerRadius(inRadius)\n      .startAngle(0)\n      .endAngle(Math.PI * 2);\n\n    let color = d3.hcl(scales.hueScale(d.syntactic - d.semantic));\n    color.l = scales.lightnessScale(Math.max(d.semantic, d.syntactic));\n\n    donut.append('path')\n      .attr('class', 'donut-chart')\n      .attr('d', arc)\n      .style('fill', color);\n\n    // Draw the edges\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < tokenSize; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / tokenSize);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        token: d.token,\n        id: i\n      });\n    }\n\n    // Create the links\n    let links = [];\n\n    // Todo\n    // let threshold = 0.2;\n    let threshold = 0;\n\n    for (let i = 0; i < tokenSize; i++) {\n      for (let j = 0; j < tokenSize; j++) {\n        let curAttention = attentions[d.layer][d.head][i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3.scaleLinear()\n      .domain(d3.extent(links.map(d => d.attention)))\n      .range([0.2, 0.7]);\n\n    let linkOpacityScale = d3.scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n\n    // Draw the links as bezier curves\n    donut.selectAll('path.donut-link')\n      .data(links, d => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('d', d => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = {x: 0, y: 0};\n        const radialCurveAlpha = 2 / 5;\n        \n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha\n        };\n        \n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('stroke-width', d => linkWidthScale(d.attention))\n      .style('opacity', d => linkOpacityScale(d.attention));\n\n  };\n\n  const initData = async (attentionFile, saliencyFile, atlasFile) => {\n    // Init attention data\n    attentions = await d3.json(attentionFile);\n\n    // init atlas data\n    atlasData = await d3.json(atlasFile);\n    \n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n    tokenSize = saliencies.tokens.length;\n  };\n\n  const closeClicked = () => {\n    sideInfo.show = false;\n    sideStore.set(sideInfo);\n    dispatch('close');\n  };\n\n  const badgeClicked = () => {\n    if (isShown) {\n      dispatch('close');\n      isShown = false;\n\n      d3.select(viewContainer)\n        .select('.svg-container')\n        .transition('move')\n        .duration(700)\n        .ease(ease)\n        .style('opacity', 0);\n\n      // Change the badge style\n      d3.timer(() => {\n        let badge = d3.select(viewContainer)\n          .select('.badge')\n          .style('border-left', '1px solid hsl(0, 0%, 90.2%)')\n          .style('border-radius', '5px')\n          .style('box-shadow', '-3px 3px 3px hsla(0, 0%, 0%, 0.06)')\n          .style('margin-left', '5px');\n        \n        badge.select('.badge-title')\n          .style('visibility', 'hidden');\n\n        badge.select('.icon-wrapper > img')\n          .attr('src', 'PUBLIC_URL/figures/map-marked-alt-solid.svg');\n      }, 400);\n    } else {\n      dispatch('open');\n      isShown = true;\n\n      d3.select(viewContainer)\n        .select('.svg-container')\n        .transition('move')\n        .duration(700)\n        .ease(ease)\n        .style('opacity', 1);\n\n      // Change the badge style\n      d3.timer(() => {\n        let badge = d3.select(viewContainer)\n          .select('.badge')\n          .style('border-left', null)\n          .style('border-radius', '0 5px 5px 0')\n          .style('box-shadow', null)\n          .style('margin-left', null);\n        \n        badge.select('.badge-title')\n          .style('visibility', 'visible');\n\n        badge.select('.icon-wrapper > img')\n          .attr('src', 'PUBLIC_URL/figures/chevron-right-solid.svg');\n      }, 400);\n    }\n  };\n\n  onMount(async () => {\n    // Load the attention and atlas data\n    if (attentions == null || atlasData == null || saliencies == null) {\n      initData(\n        `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`,\n        'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n        'PUBLIC_URL/data/sst2-atlas.json'\n      );\n    }\n  });\n\n  instanceIDStore.subscribe(async value => {\n    if (value !== instanceID) {\n      instanceID = value;\n      saliencies = await d3.json('PUBLIC_URL/data/sst2-saliency-list-grad-l1.json');\n      saliencies = saliencies[instanceID];\n      tokenSize = saliencies.tokens.length;\n      svg.select('*').remove();\n      createGraph();\n    }\n  });\n\n  sideStore.subscribe(value => {sideInfo = value;});\n\n  mapViewConfigStore.subscribe(async value => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined){\n      if (instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n        instanceViewConfig.compWidth !== value.compWidth)\n      ){\n        instanceViewConfig = value;\n        \n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight;\n\n        // Load the attention and atlas data\n        if (attentions == null || atlasData == null || saliencies == null) {\n          initData(\n            `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`,\n            'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n            'PUBLIC_URL/data/sst2-atlas.json'\n          ).then(createGraph);\n        } else {\n          createGraph();\n        }\n      }\n    }\n  });\n  \n\n</script>\n\n<style type='text/scss'>.svg-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  align-items: flex-end;\n}\n\n.atlas-view {\n  display: flex;\n  flex-direction: row;\n  max-width: 100%;\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n  transition: max-width 1000ms ease-in-out;\n  border-radius: 10px 0 0 10px;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  box-shadow: -3px -3px 3px rgba(0, 0, 0, 0.1);\n  background: #fdfcfc;\n}\n.atlas-view .triangle {\n  content: \"\";\n  position: absolute;\n  top: 500px;\n  left: 0;\n  border-top: 20px solid transparent;\n  border-bottom: 20px solid transparent;\n  border-left: 20px solid #f2f2f2;\n}\n\n.legend-container {\n  padding-bottom: 25px;\n  padding-top: 50px;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  pointer-events: none;\n}\n.legend-container :first-child {\n  margin-bottom: 35px;\n}\n\n.bottom-images {\n  display: flex;\n  flex-direction: column;\n}\n.bottom-images :first-child {\n  margin-bottom: 35px;\n}\n\n.atlas-svg-container {\n  position: relative;\n}\n.atlas-svg-container svg {\n  border-right: 1px solid #e6e6e6;\n}\n\n.head-arrow {\n  position: absolute;\n  width: 160px;\n  pointer-events: none;\n}\n\n.layer-arrow {\n  position: absolute;\n  height: 160px;\n  pointer-events: none;\n}\n\n.control-row {\n  position: absolute;\n  top: 0;\n  left: 0;\n  cursor: default;\n  padding-top: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  user-select: none;\n  font-size: 0.9rem;\n  z-index: 5;\n}\n\n.lower-atlas-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 20px 0 10px;\n  display: flex;\n  flex-direction: row;\n}\n\n.expand-button {\n  padding: 3px 5px;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 10px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 0.5;\n  transform: rotate(45deg);\n}\n.icon-wrapper img {\n  height: 1.2em;\n}\n\n.hidden {\n  visibility: hidden;\n}</style>\n\n<div class='atlas-view' bind:this={viewContainer}>\n\n  <div class='triangle' class:hidden={!sideInfo.show}></div>\n\n  <div class='control-row'>\n\n    <div class='lower-atlas-label'>\n      <div class='select-row'>\n        <div class='relation-container' on:click={closeClicked}>\n          <div class='expand-button'>\n            <div class='icon-wrapper'>\n              <img src='PUBLIC_URL/figures/arrow-forward-outline.svg' alt='expanding icon'>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      Attention Head Overview\n    </div>\n\n  </div>\n\n  <div class='svg-container'>\n\n    <div class='atlas-svg-container'>\n      <svg class='atlas-svg-full'></svg>\n    </div>\n\n    <div class='legend-container'>\n      <div>\n        <img src='PUBLIC_URL/figures/click.png' width='180px' alt='click guide'>\n      </div>\n      <div class='bottom-images'>\n        <img src='PUBLIC_URL/figures/size-legend.png' width='160px' alt='size legend'>\n        <img src='PUBLIC_URL/figures/legend.png' width='200px' alt='color legend'>\n      </div>\n    </div>\n\n  </div>\n  \n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import { sideStore, attentionHeadColorStore } from './store';\n  import { getTokenWidth } from './dependency-view/utils';\n  import * as d3 from 'd3';\n\n  let modalComponent = null;\n  let svg = null;\n  let donut = null;\n  let svgVirtualLength = 500;\n  let svgLength = 480;\n  let markerDef = null;\n\n  let attentionHeadColor = new Map();\n  attentionHeadColorStore.subscribe(value => {attentionHeadColor = value;});\n\n  let modalInfo = {};\n\n  sideStore.subscribe(value => {\n    modalInfo = value;\n\n    if (modalInfo.attention != null) {\n      donut.selectAll('*').remove();\n      drawDonut(donut);\n    }\n  });\n\n  const drawDonut = (donut) => {\n    \n    let color = attentionHeadColor.get([modalInfo.layer, modalInfo.head].toString());\n\n    svg.select('#atlas-side-arrow')\n      .select('path')\n      .attr('fill', color)\n      .attr('stroke', color);\n\n    // Pre-draw the text\n    let tempSVG = d3.select(document.body)\n      .append('svg')\n      .attr('height', 200)\n      .attr('width', 200)\n      .style('visibility', 'hidden');\n\n    const result = getTokenWidth(modalInfo.tokens.map(d => d.token), tempSVG, '0.9em');\n    const maxTextWidth = d3.max(Object.entries(result.textTokenWidths).map(d => d[1]));\n    let inRadius = svgVirtualLength / 2 - maxTextWidth;\n    \n    tempSVG.remove();\n\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i\n      });\n    }\n\n    // Create the links\n    let links = [];\n    let threshold = 0;\n\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      for (let j = 0; j < modalInfo.tokens.length; j++) {\n        let curAttention = modalInfo.attention[i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3.scaleLinear()\n      .domain(d3.extent(links.map(d => d.attention)))\n      .range([0.5, 2]);\n\n    let linkOpacityScale = d3.scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n    \n    // Draw the texts (will re-draw again later after getting the optimal circle size)\n    let textTokenGroup = donut.append('g')\n      .attr('class', 'token-text-group')\n      .style('font-size', '0.9em')\n      .style('cursor', 'default');\n\n    textTokenGroup.selectAll('text')\n      .data(tokenPos, d => d.id)\n      .join('text')\n      .attr('data-angle', d => d.angle)\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', d => d.angle < Math.PI / 2 ? 6 : -6)\n      .attr('text-anchor', d => d.angle < Math.PI / 2 ? 'start' : 'end')\n      .text(d => d.token);\n\n    // Optimize the circle size (maximize the inner bbox)\n    // Need to create a temp svg to work around the drawing delay\n    let textClone = donut.select('.token-text-group').clone(true).remove();\n\n    tempSVG = d3.select(document.body)\n      .append('svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', svgLength)\n      .attr('height', svgLength)\n      .style('visibility', 'hidden');\n    \n\n    tempSVG.append(() => textClone.node());\n    let innerBox = tempSVG.select('.token-text-group').node().getBBox();\n    tempSVG.remove();\n\n    let top = svgVirtualLength / 2 + innerBox.y;\n    let bottom = svgVirtualLength - top - innerBox.height;\n    let left = svgVirtualLength / 2 + innerBox.x;\n    let right = svgVirtualLength - left - innerBox.width;\n\n    let radiusGrow = Math.min(top, bottom, left, right);\n\n    // Grow the radius and redraw text, circles and paths\n    inRadius += Math.floor(radiusGrow);\n\n    // Figure out the token positions\n    tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i\n      });\n    }\n\n    // Draw invisible background for interaction\n    textTokenGroup.selectAll('rect')\n      .data(tokenPos, d => d.id)\n      .join('rect')\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n        `;\n      })\n      .attr('x', 0)\n      .attr('y', -5)\n      .attr('width', 50)\n      .attr('height', 15)\n      .style('fill', 'white')\n      .style('opacity', 0)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-side-arrow')\n          .select('path')\n          .attr('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .filter(dd => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-side-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-side-arrow')\n          .select('path')\n          .attr('opacity', null);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-side-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', d => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Update text position\n    textTokenGroup.selectAll('text')\n      .data(tokenPos, d => d.id)\n      .join('text')\n      .attr('data-angle', d => d.angle)\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', d => d.angle < Math.PI / 2 ? 6 : -6)\n      .attr('text-anchor', d => d.angle < Math.PI / 2 ? 'start' : 'end')\n      .text(d => d.token)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-side-arrow')\n          .select('path')\n          .attr('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .filter(dd => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-side-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-side-arrow')\n          .select('path')\n          .attr('opacity', null);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-side-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', d => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Draw the links as bezier curves\n    donut.append('g')\n      .attr('class', 'path-group')\n      .selectAll('path.donut-link')\n      .data(links, d => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('marker-end', 'url(#atlas-side-arrow)')\n      .attr('d', d => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = {x: 0, y: 0};\n        const radialCurveAlpha = 2 / 5;\n        \n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha\n        };\n        \n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('stroke-width', d => linkWidthScale(d.attention))\n      .style('opacity', d => linkOpacityScale(d.attention));\n    \n    // Draw the circles\n    donut.append('g')\n      .attr('class', 'token-dot-group')\n      .selectAll('circle.token-dot')\n      .data(tokenPos, d => d.id)\n      .join('circle')\n      .attr('class', 'token-dot')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', 1);\n\n  };\n\n  const drawRadial = () => {\n    svg.append('rect')\n      .attr('width', svgVirtualLength)\n      .attr('height', svgVirtualLength)\n      .style('fill', 'hsla(0, 0%, 100%, 0)');\n    \n    donut = svg.append('g')\n      .attr('class', 'donut')\n      .attr('transform', 'translate(250, 250)');\n\n    markerDef = svg.append('defs')\n      .attr('id', 'atlas-side-arrow-def')\n      .append('marker')\n      .attr('id', 'atlas-side-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'gray')\n      .attr('fill', 'gray');\n\n    markerDef = svg.append('defs')\n      .attr('id', 'atlas-side-arrow-def-hover')\n      .append('marker')\n      .attr('id', 'atlas-side-arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'hsl(24, 95%, 59%)')\n      .attr('fill', 'hsl(24, 95%, 59%)');\n\n    // drawDonut(donut);\n  };\n\n  onMount(() => {\n    // Bind drag event\n    let container = d3.select(modalComponent)\n      .select('.svg-container');\n\n    svg = container.select('svg.side-svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', '100%')\n      .attr('height', '100%');\n\n    drawRadial();\n\n  });\n\n  const getColor = (layer, head) => {\n    if (attentionHeadColor == null || attentionHeadColor.has === undefined ||\n      !attentionHeadColor.has([layer, head].toString())) {\n      return 'black';\n    } else {\n      return attentionHeadColor.get([layer, head].toString());\n    }\n  };\n\n</script>\n\n<style type='text/scss'>.atlas-side {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n\n.side-svg {\n  width: 100%;\n  height: 100%;\n}\n\n.side-title {\n  font-size: 1.3em;\n  cursor: default;\n  pointer-events: none;\n}</style>\n\n\n<div class='atlas-side' bind:this={modalComponent}>\n\n  <div class='side-title'\n    style={`color: ${getColor(modalInfo.layer, modalInfo.head)}`}>\n    Layer {modalInfo.layer + 1} Head {modalInfo.head + 1}\n  </div>\n\n  <div class='svg-container'>\n    <svg class='side-svg'></svg>\n  </div>\n\n\n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = {top: 3, left: 3, right: 3, bottom: 3};\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n  };\n\n  let forceStrength = {manyBody: 0, attention: 0, textOrder: 0};\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const createCircleLayout = (nodes, center, radius) => {\n    let nodeIndexArray = nodes.map(d => +d.id);\n\n    // Create a scale to map index to radial\n    let extent = d3.extent(nodeIndexArray);\n\n    // Need to add an extra index to play around 0 = 2 * PI overlapping\n    extent[1] += 1;\n\n    let radialScale = d3.scaleLinear()\n      .domain(extent)\n      .range([Math.PI, -Math.PI]);\n    \n    // Add position to the node objects\n    nodes.forEach(d => {\n      let alpha = radialScale(d.id);\n      d.x = round(center.x + radius * Math.sin(alpha), 2);\n      d.y = round(center.y + radius * Math.cos(alpha), 2);\n      d.headX = round(center.x + (radius - minNodeRadius * 1.1) * Math.sin(alpha), 2);\n      d.headY = round(center.x + (radius - minNodeRadius * 1.1) * Math.cos(alpha), 2);\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3.select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter(d => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map(d => Object.create(d));\n    links = links.map(d => Object.create(d));\n\n    // Calculate the node positions\n    createCircleLayout(\n      nodes,\n      {x: SVGWidth / 2, y: SVGHeight / 2},\n      SVGWidth / 2 - minNodeRadius - SVGPadding.left\n    );\n    \n    // Create links\n    let nodeByID = new Map(nodes.map(d => [d.id, d]));\n    let bilinks = [];\n\n    links.forEach(d => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      \n      bilinks.push({source: source, target: target, selfLoop: source === target});\n    });\n\n    // console.log(bilinks);\n\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach(d => nodeIndices.add(+d.id));\n\n    createCircleLayout(\n      nodes,\n      {x: SVGWidth / 2, y: SVGHeight / 2},\n      SVGWidth / 2 - minNodeRadius - SVGPadding.left\n    );\n\n    // console.log(nodes);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg.append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    const drawLines = d => {\n      return `M ${d.source.headX} ${d.source.headY} L ${d.target.headX} ${d.target.headY}`;\n    };\n\n    const bezierCurveFunc = d => {\n      let center = {x: SVGWidth / 2, y: SVGHeight / 2};\n      let controlAlpha = 4 / 5;\n\n      // Two control points symmetric regarding the center point\n      let controlP1 = {\n        x: center.x + (d.source.headX - center.x) * controlAlpha,\n        y: center.y + (d.source.headY - center.x) * controlAlpha\n      };\n\n      let controlP2 = {\n        x: center.x + (d.target.headX - center.x) * controlAlpha,\n        y: center.y + (d.target.headY - center.x) * controlAlpha\n      };\n\n      return `M ${d.source.headX},${d.source.headY} C${controlP1.x}, ${controlP1.y},\n       ${controlP2.x}, ${controlP2.y}, ${d.target.headX},${d.target.headY}`;\n    };\n    \n    // Draw edges\n    let linkLines = svg.append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('d', bezierCurveFunc)\n      //.attr('d', drawLines)\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg.append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      .data(nodes)\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', d => `translate(${d.x}, ${d.y})`);\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3.scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n    \n    nodeGroups.append('circle')\n      .attr('class', 'node-circle')\n      .attr('r', minNodeRadius)\n      .style('fill', d => colorScale(d.id));\n    \n    // Add token text to each node\n    nodeGroups.append('text')\n      .attr('class', 'node-text')\n      .text(d => d.token);\n\n    nodeGroups.append('title')\n      .text(d => d.token);\n\n    // Register UI elements from the control panel\n    // bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    // bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    // bindSlider('manyBody', simulation, -1000, 0, initManyBodyStrength);\n\n    // bindCheckBox(simulation, links);\n\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style type=\"text/scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n  opacity: 0.5;\n}</style>\n\n<div class='graph-view'>\n  <div class='control-panel'>\n    <!-- Sliders -->\n    <div class='slider'>\n      <label for='attention'>Attention Strength\n        [{config.autoAttention ? 'auto' : round(forceStrength.attention, 2)}]\n      </label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"attention\">\n    </div>\n\n    <div class='slider'>\n      <label for='textOrder'>Text Order Strength [{round(forceStrength.textOrder, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"textOrder\">\n    </div>\n\n    <div class='slider'>\n      <label for='manyBody'>ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"manyBody\">\n    </div>\n\n    <!-- Checkboxes -->\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\">\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\">\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\">\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-border\">\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n    \n  </div>\n\n  <div class='svg-container'>\n    <svg class='graph-svg' bind:this={graphSVG}></svg>\n  </div>\n  \n</div>",
    "<script>\n  import { graphViewConfigStore, hoverTokenStore, wordToSubwordMapStore,\n    instanceIDStore, mapHeadStore } from './store';\n  import * as d3 from 'd3';\n  import { onMount } from 'svelte';\n  \n  // Shared states\n  let graphViewCompConfig = undefined;\n  let instanceID = 1562;\n  let curLayer = 9;\n  let curHead = 8;\n  let mapHead = {layer: 9, head: 8};\n\n  let graphSVG = null;\n  let graphData = null;\n  let saliencyData = null;\n  let wordToSubwordMap = null;\n\n  let SVGWidth = undefined;\n  let SVGHeight = undefined;\n\n  let curHoverToken = null;\n  \n  // View configs\n  const SVGPadding = {top: 3, left: 3, right: 3, bottom: 3};\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  // const minNodeRadius = 10;\n  // const maxNodeRadius = 20;\n  \n  const radialRadius = 225;\n  const radialCurveAlpha = 0.3;\n\n  const gridRowSize = 8;\n  const gridRowGap = 35;\n  const gridColumnGap = 35;\n\n  // Graph vis variables\n  let tokenSize = null;\n  let originalNodes = null;\n\n  let curLinkI = 1;\n  let weightThresholdMin = 0.02;\n  let weightThresholdMax = 0.1;\n  let weightThresholdSteps = 6;\n  let weightThresholdGap = (weightThresholdMax - weightThresholdMin) / (weightThresholdSteps - 1);\n  let weightThreshold = weightThresholdMin + weightThresholdGap * curLinkI;\n\n  let linkArrays = {};\n  let simulation = null;\n  let intermediateNodeMap = new Map();\n  let linkWidth = null;\n\n  let linkColor = 'hsl(0, 0%, 76%)';\n  let linkHoverColor = 'hsl(36, 100%, 55%)';\n  let nodeRadiusScale = null;\n  // linkHoverColor = 'hsl(174, 65%, 48%)';\n\n  // Control panel variables\n  let settingIconActive = false;\n\n  // Data\n  let mounted = false;\n  let attentionData = null;\n\n  const ease = d3.easeCubicInOut;\n  const animationTime = 300;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout'\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout'\n    },\n    grid: {\n      value: 'grid',\n      name: 'Grid Layout'\n    } \n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.radial\n  };\n\n  let forceStrength = {\n    force: {\n      manyBody: -840,\n      attention: 0.5,\n      textOrder: 1.6,\n      collideRadius: 1\n    },\n    radial: {\n      textOrder: 0.5,\n      radial: 1\n    },\n    grid: {\n      collideRadius: 7\n    }\n  };\n\n  let currentLayout = config.defaultLayout;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const drag = () => {\n  \n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n\n      // Add a marker to indicate that the node is fixed\n      d3.select(event.sourceEvent.originalTarget.parentNode)\n        .append('rect')\n        .attr('class', 'fixed-marker')\n        .attr('x', -3)\n        .attr('y', 6)\n        .attr('width', 6)\n        .attr('height', 5)\n        .style('fill', 'white');\n    };\n    \n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n    \n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      // event.subject.fx = null;\n      // event.subject.fy = null;\n    };\n    \n    return d3.drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (!d.hidden) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGHeight - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(SVGPadding.left + curRadius, Math.min(width - curRadius, d.x));\n    const top = Math.max(SVGPadding.top + curRadius, Math.min(height - curRadius, d.y));\n\n    if (config.borderConstraint) {\n      return {top: top, left: left};\n    } else {\n      return {top: d.y, left: d.x};\n    }\n  };\n\n  const bindSlider = (name, min, max, defaultValue, nodeRadiusScale=null) => {\n    let slider = d3.select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      let step = sliderValue / 200;\n      forceStrength.force[name] = value;\n\n      switch (name) {\n      case 'attention':\n        simulation.force('attentionLink').strength(value);\n        // Disable the auto attention\n        d3.select('#checkbox-auto-attention')\n          .property('checked', false);\n        config.autoAttention = false;\n        break;\n      case 'textOrder':\n        simulation.force('textLink').strength(d => d.target.index === 0 ? 0 : value);\n        break;\n      case 'manyBody':\n        simulation.force('charge').strength(value);\n        break;\n      case 'collideRadius':\n        simulation.force('collide').radius(d => nodeRadiusScale(d.saliency) + value);\n        break;\n      case 'threshold':\n        weightThreshold = weightThresholdMin + step * weightThresholdGap;\n        weightThresholdUpdated(step, nodeRadiusScale);\n        break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const resetSimulation = () => {\n    simulation.force('collide', null);\n    simulation.force('attentionLink', null);\n    simulation.force('charge', null);\n    simulation.force('center', null);\n    simulation.force('textLink', null);\n    simulation.force('hiddenTextLink', null);\n    simulation.force('posX', null);\n    simulation.force('posY', null);\n    simulation.force('grid', null);\n  };\n\n  const bindSelect = (nodeRadiusScale) => {\n\n    currentLayout = config.defaultLayout;\n    let selectOption = d3.select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayoutValue = selectOption.property('value');\n\n      // Need to switch layout\n      if (newLayoutValue !== currentLayout.value) {\n        resetSimulation();\n        \n        switch(newLayoutValue) {\n        case 'force':\n          currentLayout = layoutOptions.force;\n          initForceSim(nodeRadiusScale);\n          simulation.alpha(1).restart();\n          break;\n\n        case 'radial':\n          currentLayout = layoutOptions.radial;\n          initRadialSim();\n          simulation.alpha(1).restart();\n          break;\n\n        case 'grid':\n          currentLayout = layoutOptions.grid;\n          initGridSim();\n          simulation.alpha(1).restart();\n          break;\n        }\n\n        updateNodeRadius(nodeRadiusScale);\n      }\n      simulation.alpha(1).restart();\n    });\n  };\n\n  const bindLayerHeadSelect = () => {\n\n    let layerSelectOption = d3.select('#select-layer')\n      .property('value', curLayer);\n\n    let headSelectOption = d3.select('#select-head')\n      .property('value', curHead);\n\n    layerSelectOption.on('change', () => {\n      let newLayerValue = layerSelectOption.property('value');\n\n      // Need to switch layout\n      if (newLayerValue !== curLayer) {\n        // console.log(newLayerValue);\n        curLayer = newLayerValue;\n        updateLayerHead();\n\n        mapHead.layer = +curLayer;\n        mapHead.head = +curHead;\n        mapHeadStore.set(mapHead);\n      }\n    });\n\n    headSelectOption.on('change', () => {\n      let newHeadValue = headSelectOption.property('value');\n\n      // Need to switch layout\n      if (newHeadValue !== curHead) {\n        // console.log(newHeadValue);\n        curHead = newHeadValue;\n        updateLayerHead();\n\n        mapHead.layer = +curLayer;\n        mapHead.head = +curHead;\n        mapHeadStore.set(mapHead);\n      }\n    });\n  };\n\n  mapHeadStore.subscribe(value => {\n    mapHead = value;\n\n    if (mapHead.layer !== curLayer || mapHead.head !== curHead) {\n      // console.log('change');\n      d3.select('#select-layer')\n        .property('value', mapHead.layer);\n\n      d3.select('#select-head')\n        .property('value', mapHead.head);\n\n      curLayer = mapHead.layer;\n      curHead = mapHead.head;\n\n      updateLayerHead();\n    }\n\n  });\n  \n\n  const updateNodeRadius = (nodeRadiusScale) => {\n    d3.select(graphSVG)\n      .select('g.node-group')\n      .selectAll('circle')\n      .transition('node-radius')\n      .duration(animationTime)\n      .ease(ease)\n      .attr('r', d => currentLayout.value === 'force' ?\n        nodeRadiusScale(+d.saliency) : minNodeRadius);\n  };\n\n  const initForceSim = (nodeRadiusScale) => {\n    // Force 1 (ManyBody force)\n    simulation.force('charge', d3.forceManyBody()\n      .strength(forceStrength.force.manyBody)\n    );\n\n    // Force 2 (Center force)\n    simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // Force 3 (Link force)\n    simulation.force('attentionLink', d3.forceLink(linkArrays[curLinkI].links)\n      .id(d => d.id)\n    );\n    \n    // Force 4 (Text order link force)\n    simulation.force('textLink', d3.forceLink(linkArrays[curLinkI].hiddenLinks)\n      .id(d => d.id)\n      .strength(d => d.target.index === 0 ? 0 : forceStrength.force.textOrder)\n    );\n    \n    // Force 5 (Collide force)\n    simulation.force('collide', d3.forceCollide()\n      .radius(d => nodeRadiusScale(d.saliency) + forceStrength.force.collideRadius)\n    );\n  };\n\n  const initRadialSim = () => {\n    // Force 1 (Tex order link force)\n    simulation.force('textLink', d3.forceLink(linkArrays[curLinkI].hiddenLinks)\n      .id(d => d.id)\n      .strength(forceStrength.radial.textOrder)\n    );\n\n    // Force 2 (Custom radial force)\n    simulation.force('posY', d3.forceY()\n      .y((d, i) => {\n        let curLen = originalNodes.filter(d => !d.hidden).length;\n        let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / curLen);\n        return SVGHeight / 2 + Math.sin(curAngle) * radialRadius;\n      })\n      .strength(forceStrength.radial.radial)\n    );\n\n    simulation.force('posX', d3.forceX()\n      .x((d, i) => {\n        let curLen = originalNodes.filter(d => !d.hidden).length;\n        let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / curLen);\n        return SVGWidth / 2 + Math.cos(curAngle) * radialRadius;\n      })\n      .strength(forceStrength.radial.radial)\n    );\n  };\n\n  const initGridSim = () => {\n    let curGridRowSize = gridRowSize;\n    let gridColumnSize = Math.ceil(tokenSize / curGridRowSize);\n\n    let rowLength = gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;\n    let columnLength = gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;\n\n    // Check if we need to increase the row size\n    while (columnLength > SVGHeight) {\n      curGridRowSize = gridRowSize + 1;\n      rowLength = gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;\n      columnLength = gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;\n\n      if (rowLength > SVGWidth) {\n        console.log('Failed to initialize grid layout');\n        break;\n      }\n    }\n\n    let xs = Math.floor((SVGWidth - rowLength) / 2);\n    let ys = Math.floor((SVGHeight - columnLength) / 2);\n    \n    // Force 3 (Grid force)\n    simulation.force('grid', d3.forceLink(linkArrays[curLinkI].gridLinks)\n      .iterations(80)\n      .distance(50)\n      .id(d => d.id)\n    );\n\n    // Force 4 (Orientation force)\n    simulation.force('posX', d3.forceX()\n      .x((d, i) => xs + (i % gridRowSize) * (2 * minNodeRadius + gridColumnGap) + minNodeRadius)\n      .strength(d => d.id === undefined ? 0 : 1)\n    );\n\n    simulation.force('posY', d3.forceY()\n      .y((d, i) => ys + Math.floor(i / gridRowSize) * (2 * minNodeRadius + gridRowGap) + minNodeRadius)\n      .strength(d => d.id === undefined ? 0 : 1)\n    );\n  };\n\n  const initCurrentSim = (nodeRadiusScale) => {\n    switch(currentLayout.value) {\n    case 'force':\n      initForceSim(nodeRadiusScale);\n      break;\n    case 'radial':\n      initRadialSim();\n      break;\n    case 'grid':\n      initGridSim();\n      break;\n    }\n  };\n  \n  const tickLinkForce = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    if (d.selfLoop) {\n      const iCoord = borderConstraint(d[2], nodeRadiusScale);\n\n      // Shorten the distance from source to intermediate point\n      let interLen = Math.sqrt((tCoord.left - iCoord.left) ** 2 +\n        (tCoord.top - iCoord.top) ** 2) - nodeRadiusScale(d[0].saliency);\n\n      iCoord.left = tCoord.left + (iCoord.left - tCoord.left) / interLen * 80;\n      iCoord.top = tCoord.top + (iCoord.top - tCoord.top) / interLen * 80;\n\n      // Need to handle the arc manually if there is a self loop\n      const iVec = [iCoord.left - sCoord.left, iCoord.top - sCoord.top];\n      const iVecNorm = Math.sqrt((iVec[0] ** 2 + iVec[1] ** 2));\n\n      // Rotate 90 degree\n      // Normalized the rotate direction, use alpha to control magnitude\n      const alpha = 50;\n      const iVecClock90 = [-iVec[1] / iVecNorm * alpha, iVec[0] / iVecNorm * alpha];\n      const iVecCounterClock90 = [iVec[1] / iVecNorm * alpha, -iVec[0] / iVecNorm * alpha];\n\n      const leftControl = [sCoord.left + iVec[0] + iVecClock90[0],\n        sCoord.top + iVec[1] + iVecClock90[1]];\n      const rightControl = [sCoord.left + iVec[0] + iVecCounterClock90[0],\n        sCoord.top + iVec[1] + iVecCounterClock90[1]];\n\n      // We need to shorten the path to leave space for arrow\n      let halfLen = Math.sqrt((tCoord.left - rightControl[0]) ** 2 + (tCoord.top - rightControl[1]) ** 2);\n      let theta = (nodeRadiusScale(d[0].saliency) + 10)/ halfLen;\n      let modTCoord = {\n        left: tCoord.left + (rightControl[0] - tCoord.left) * theta,\n        top: tCoord.top + (rightControl[1] - tCoord.top) * theta,\n      };\n\n      // Draw a bezier curve with two control points (which are left and right\n      // perpendicular to the self loop node -> intermediate node vector)\n      return 'M' + sCoord.left + ',' + sCoord.top\n        + 'C' + leftControl[0] + ',' + leftControl[1]\n        + ' ' + rightControl[0] + ',' + rightControl[1]\n        + ' ' + modTCoord.left + ',' + modTCoord.top;\n\n    } else {\n      // We need to shorten the path to leave space for arrow\n      let vecLen = Math.sqrt((tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2);\n      let theta = (nodeRadiusScale(d[1].saliency) + 10) / vecLen;\n      let modTCoord = {\n        left: tCoord.left + (sCoord.left  - tCoord.left) * theta,\n        top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n      };\n      return 'M' + sCoord.left + ',' + sCoord.top + 'L' + modTCoord.left + ',' + modTCoord.top;\n    }\n  };\n\n  const tickNodeForce = (d, nodeRadiusScale) => {\n    // Maker sure the nodes are inside the box\n    const coord = borderConstraint(d, nodeRadiusScale);\n    return `translate(${coord.left}, ${coord.top})`;\n  };\n\n  const tickLinkRadial = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    let source = {x: sCoord.left, y: sCoord.top};\n    let target = {x: tCoord.left, y: tCoord.top};\n    let center = {x: SVGWidth / 2, y: SVGHeight / 2 + 40};\n\n    // We need to shorten the path to leave space for arrow\n    let theta = 1 - (minNodeRadius + 10) / radialRadius;\n    let modTarget = {\n      x: center.x + (target.x - center.x) * theta,\n      y: center.y + (target.y - center.y) * theta,\n    };\n\n    let modSource = {\n      x: center.x + (source.x - center.x) * theta,\n      y: center.y + (source.y - center.y) * theta,\n    };\n    \n    // Two control points symmetric regarding the center point\n    let controlP1 = {\n      x: center.x + (modSource.x - center.x) * radialCurveAlpha,\n      y: center.y + (modSource.y - center.x) * radialCurveAlpha\n    };\n\n    let controlP2 = {\n      x: center.x + (modTarget.x - center.x) * radialCurveAlpha,\n      y: center.y + (modTarget.y - center.x) * radialCurveAlpha\n    };\n\n    return `M ${modSource.x},${modSource.y} C${controlP1.x}, ${controlP1.y},\n      ${controlP2.x}, ${controlP2.y}, ${modTarget.x},${modTarget.y}`;\n  };\n  \n  const tickLinkGrid = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    // We need to shorten the path to leave space for arrow\n    let halfLen = Math.sqrt((tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2);\n\n    let theta = (minNodeRadius + 10) / halfLen;\n    let modTCoord = {\n      left: tCoord.left + (sCoord.left - tCoord.left) * theta,\n      top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n    };\n\n    return 'M' + sCoord.left + ',' + sCoord.top\n      + 'L' + modTCoord.left + ',' + modTCoord.top;\n  };\n\n  const weightThresholdUpdated = (step) => {\n    curLinkI = step;\n\n    // Update the svg\n    let linkLines = d3.select(graphSVG)\n      .select('g.attention-link-group')\n      .selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, d => `${d[0].id}-${d[1].id}`);\n\n    // Enter\n    linkLines.enter()\n      .append('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link')\n      .attr('id', d => `link-${d[0].id}-${d[1].id}`)\n      .style('stroke', 'hsl(150, 74%, 51%)')\n      .style('stroke-width', d => linkWidth(d.attention))\n      .transition()\n      .duration(animationTime * 3)\n      .ease(ease)\n      .style('stroke', linkColor);\n    \n    // Exit\n    linkLines.exit()\n      .style('stroke', 'hsl(349, 81%, 57%)')\n      .transition()\n      .duration(animationTime * 3)\n      .ease(ease)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        d3.select(g[i]).remove();\n      });\n    \n    // Update the simulation\n    simulation.nodes(linkArrays[curLinkI].nodes);\n    simulation.alpha(1).restart();\n  };\n\n  // Create related link arrays (hiddenLinks, biLinks, and gridLinks)\n  const createGraphLinks = (curLinks, nodeByID, nodeIndexArray) => {\n    curLinks = curLinks.map(d => Object.create(d));\n    let curNodes = originalNodes.slice();\n\n    // Add text order hidden links\n    let curHiddenLinks = [];\n    for (let i = 0; i < curNodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +curNodes[i].id,\n        target: +curNodes[i + 1].id\n      };\n      curHiddenLinks.push(hiddenLink);\n    }\n\n    // Add a connection between the first and last token\n    curHiddenLinks.push({\n      source: +curNodes[curNodes.length - 1].id,\n      target: curNodes[0].id\n    });\n\n    curHiddenLinks = curHiddenLinks.map(d => Object.create(d));\n\n    // Add intermediate nodes to create bezier curves\n    let curBiLinks = [];\n\n    curLinks.forEach(d => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let curBilink = [source, target];\n      curBilink.selfLoop = false;\n      curBilink.attention = +d.weight;\n\n      // Add a hidden node if there is a self-loop\n      if (source === target) {\n        curBilink.selfLoop = true;\n\n        // We cannot keep creating new intermediate nodes (need to be the same\n        // object for each source across different threshold)\n        let intermediate = {hidden: true};\n\n        if (intermediateNodeMap.has(source)) {\n          intermediate = intermediateNodeMap.get(source);\n        } else {\n          intermediateNodeMap.set(source, intermediate);\n        }\n\n        curBilink.push(intermediate);\n        curNodes.push(intermediate);\n        curLinks.push(\n          {source: intermediate, target: source}\n        );\n      }\n\n      curBiLinks.push(curBilink);\n    });\n\n    // Create grid links\n    let curGridLinks = [];\n    nodeIndexArray.sort((a, b) => +a - +b);\n    for (let i = 0; i < curNodes.length; i++) {\n      if (i % gridRowSize !== gridRowSize - 1 & nodeByID.has(i + 1)) {\n        curGridLinks.push({source: nodeByID.get(i), target: nodeByID.get(i + 1)});\n      }\n      if (nodeByID.has(i + gridRowSize)) {\n        curGridLinks.push({source: nodeByID.get(i), target: nodeByID.get(i + gridRowSize)});\n      }\n    }\n\n    return {\n      links: curLinks,\n      hiddenLinks: curHiddenLinks,\n      biLinks: curBiLinks,\n      gridLinks: curGridLinks,\n      nodes: curNodes\n    };\n  };\n\n  const graphNodeDoubleClickHandler = (e, nodeGroup, linkLineGroup, nodeIndexArray,\n    nodeIndices, nodeRadiusScale, nodeByID, simulation) => {\n    let curNode = d3.select(e.target);\n    let curID = curNode.data()[0].id;\n\n    // Delete the node from the nodes array\n    for (let i = linkArrays[curLinkI].nodes.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].nodes[i].id === curID) {\n        linkArrays[curLinkI].nodes.splice(i, 1);\n      }\n    }\n\n    // Remove the node element on screen\n    nodeGroup.selectAll('g.node')\n      .data(linkArrays[curLinkI].nodes.filter(d => d.id !== undefined), d => d.id)\n      .exit()\n      .remove();\n\n    // Delete all links connecting to this node\n    for (let i = linkArrays[curLinkI].biLinks.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].biLinks[i][0].id === curID |\n        linkArrays[curLinkI].biLinks[i][1].id === curID) {\n        linkArrays[curLinkI].biLinks.splice(i, 1);\n      }\n    }\n\n    // Delete all attention links connecting to this node\n    for (let i = linkArrays[curLinkI].links.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].links[i].source.id === curID |\n        linkArrays[curLinkI].links[i].target.id === curID) {\n        linkArrays[curLinkI].links.splice(i, 1);\n      }\n    }\n\n    // Rewire the text order link array\n    for (let i = linkArrays[curLinkI].hiddenLinks.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].hiddenLinks[i].source.id === curID) {\n        linkArrays[curLinkI].hiddenLinks.splice(i, 1);\n      } else if (linkArrays[curLinkI].hiddenLinks[i].target.id === curID) {\n        if (i + 1 < linkArrays[curLinkI].hiddenLinks.length) {\n          linkArrays[curLinkI].hiddenLinks[i].target = linkArrays[curLinkI].hiddenLinks[i + 1].source;\n        } else {\n          linkArrays[curLinkI].hiddenLinks[i].target = linkArrays[curLinkI].hiddenLinks[0].source;\n        }\n      }\n    }\n\n    // Need to reconstruct the grid links\n    linkArrays[curLinkI].gridLinks = [];\n    nodeIndices = new Set();\n    linkArrays[curLinkI].nodes.forEach(d => {if (d.id !== undefined) nodeIndices.add(+d.id);});\n    nodeIndexArray = Array.from(nodeIndices);\n    nodeIndexArray.sort((a, b) => +a - +b);\n\n    for (let i = 0; i < nodeIndexArray.length - 1; i++) {\n      let curI = nodeIndexArray[i];\n      if (i % gridRowSize !== gridRowSize - 1 & nodeByID.has(nodeIndexArray[i + 1])) {\n        linkArrays[curLinkI].gridLinks.push({source: nodeByID.get(curI),\n          target: nodeByID.get(nodeIndexArray[i + 1])});\n      }\n      if (nodeByID.has(nodeIndexArray[i + gridRowSize])) {\n        linkArrays[curLinkI].gridLinks.push({source: nodeByID.get(curI),\n          target: nodeByID.get(nodeIndexArray[i + gridRowSize])});\n      }\n    }\n\n    linkLineGroup.selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, d => `${d[0].id}-${d[1].id}`)\n      .exit()\n      .remove();\n\n    initCurrentSim(nodeRadiusScale);\n    simulation.alpha(0.3).restart();\n  };\n\n  const simulationTick = (nodeRadiusScale) => {\n    // console.log('Tick');\n\n    let linkLines = d3.select(graphSVG)\n      .select('g.attention-link-group')\n      .selectAll('path.link');\n\n    // Update the attention links\n    switch (currentLayout.value) {\n    case 'force':\n      linkLines.attr('d', d => tickLinkForce(d, nodeRadiusScale));\n      break;\n    case 'radial':\n      linkLines.attr('d', d => tickLinkRadial(d, nodeRadiusScale));\n      break;\n    case 'grid':\n      linkLines.attr('d', d => tickLinkGrid(d, nodeRadiusScale));\n      break;\n    default:\n      console.log('Unexpected case.');\n    }\n\n    // Update the nodes\n    d3.select(graphSVG)\n      .select('g.node-group')\n      .selectAll('g.node')\n      .attr('transform', d => tickNodeForce(d, nodeRadiusScale));\n  };\n\n  const drawSaliencyLegend = (legendGroup, legendPos, largestAbs,\n    leftColor='#eb2f06', rightColor='#4690C2') => {\n    // Define the gradient\n    let legendGradientDef = legendGroup.append('defs')\n      .append('linearGradient')\n      .attr('x1', 0)\n      .attr('y1', 1)\n      .attr('x2', 0)\n      .attr('y2', 0)\n      .attr('id', 'legend-gradient-graph');\n\n    legendGradientDef.append('stop')\n      .attr('stop-color', leftColor)\n      .attr('offset', 0);\n\n    legendGradientDef.append('stop')\n      .attr('stop-color', rightColor)\n      .attr('offset', 1);\n\n    legendGroup.append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', legendPos.width)\n      .attr('height', legendPos.height)\n      .style('fill', 'url(#legend-gradient-graph)')\n      .style('stroke', 'black');\n\n    // Draw the legend axis\n    let legendScale = d3.scaleLinear()\n      .domain([0, largestAbs])\n      .range([legendPos.height, 0])\n      .nice();\n\n    legendGroup.append('g')\n      .attr('transform', `translate(${legendPos.width}, ${0})`)\n      .call(d3.axisRight(legendScale).ticks(5));\n\n    legendGroup.append('text')\n      .attr('x', 0)\n      .attr('y', legendPos.height + 8)\n      .style('font-size', '12px')\n      .style('fill', 'hsl(0, 0%, 40%)')\n      .style('dominant-baseline', 'hanging')\n      .style('text-anchor', 'left')\n      .text('Semantic Saliency Score');\n  };\n\n  const initGraph = () => {\n    let svg = d3.select(graphSVG);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map(d => Object.create(d));\n    nodes.sort((a, b) => +a.id - +b.id);\n    \n    // Give each saliency token a unique name\n    let tokenCount = {};\n    nodes.forEach(d => {\n      let curCount = 0;\n      if (tokenCount[d.token] === undefined) {\n        tokenCount[d.token] = curCount + 1;\n      } else {\n        curCount = tokenCount[d.token];\n        tokenCount[d.token] += 1;\n      }\n      d.name = `${tokenIDName(d.token)}-${curCount}`;\n    });\n\n    originalNodes = nodes.slice();\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach(d => nodeIndices.add(+d.id));\n    let nodeIndexArray = Array.from(nodeIndices);\n\n    let nodeByID = new Map(nodes.map(d => [d.id, d]));\n\n    // Create link arrays at different range steps\n    linkArrays = {};\n    for (let i  = 0; i < weightThresholdSteps; i++) {\n      let curWeightThreshold = round(weightThresholdMin + i * weightThresholdGap, 2);\n      let links = graphData.links.filter(d => d.weight > curWeightThreshold);\n      let linkResult = createGraphLinks(links, nodeByID, nodeIndexArray);\n\n      linkArrays[i] = {\n        links: linkResult.links.slice(),\n        hiddenLinks: linkResult.hiddenLinks.slice(),\n        biLinks: linkResult.biLinks.slice(),\n        gridLinks: linkResult.gridLinks.slice(),\n        nodes: linkResult.nodes.slice()\n      };\n    }\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map(d => +d.saliency);\n    // console.log(d3.extent(allSaliencyScores));\n    nodeRadiusScale = d3.scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .unknown(0)\n      .nice();\n    \n    // Create a scale for the node color\n    let largestAbs = d3.max(allSaliencyScores.map(Math.abs));\n    let rightColor = '#E50035';\n    let leftColor = '#ffffff';\n\n    let nodeSaliencyColorScale = d3.scaleLinear()\n      .domain([0, largestAbs])\n      .range([d3.rgb(leftColor), d3.rgb(rightColor)])\n      .unknown(d3.rgb('white'));\n\n    // Create a scale for link stroke width\n    let attentionWeights = linkArrays[0].links.map(d => +d.weight);\n    linkWidth = d3.scaleLinear()\n      .domain(d3.extent(attentionWeights))\n      .range([0.5, 3])\n      .nice();\n\n    // Add attention links\n    let linkLineGroup = svg.append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', linkColor);\n\n    linkLineGroup.selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, d => `${d[0].id}-${d[1].id}`)\n      .join('path')\n      .attr('class', 'link')\n      .attr('id', d => `link-${d[0].name}-${d[1].name}`)\n      .attr('marker-end', 'url(#arrow)')\n      .style('stroke-width', d => linkWidth(d.attention));\n\n    // Add token nodes\n    let nodeGroup = svg.append('g')\n      .attr('class', 'node-group');\n\n    let nodeGroups = nodeGroup.selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(linkArrays[curLinkI].nodes.filter(d => d.id !== undefined), d => d.id)\n      .join('g')\n      .attr('class', 'node')\n      .attr('id', d => `node-${d.name}`)\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag())\n      // Hover over effect\n      .on('mouseover', (e, d) => {\n        curHoverToken = d.name;\n        hoverTokenStore.set(curHoverToken);\n        highLightLink(curHoverToken);\n      })\n      .on('mouseleave', () => {\n        dehighlightLink(curHoverToken);\n        curHoverToken = null;\n        hoverTokenStore.set(curHoverToken);\n      })\n      // Single click to remove fixing\n      .on('click', (e, d) => {\n        if (d.fx !== null && d.fy !== null) {\n          // Unfix the node\n          delete d.fx;\n          delete d.fy;\n\n          // Remove the fixing marker\n          d3.select(e.target.parentNode)\n            .selectAll('rect.fixed-marker')\n            .remove();\n          \n          simulation.alpha(0.2).restart();\n        }\n      })\n      // Double click to remove the node\n      .on('dblclick', e => graphNodeDoubleClickHandler(\n        e, nodeGroup, linkLineGroup, nodeIndexArray, nodeIndices,\n        nodeRadiusScale, nodeByID, simulation\n      ));\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3.scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n    \n    nodeGroups.append('circle')\n      .attr('class', 'node-circle')\n      .attr('r', d => currentLayout.value === 'force' ?\n        nodeRadiusScale(+d.saliency) : minNodeRadius)\n      // .style('fill', d => colorScale(d.id))\n      .style('fill', d => nodeSaliencyColorScale(+d.saliency))\n      .style('opacity', 1)\n      .clone(true)\n      .attr('r', d => currentLayout.value === 'force' ?\n        nodeRadiusScale(+d.saliency) : minNodeRadius)\n      .style('fill', linkHoverColor)\n      .attr('class', 'shadow-circle');\n\n    // Create legend for the saliency map view\n    let legendGroup = svg.append('g')\n      .attr('class', 'legend-group')\n      .attr('transform', `translate(${SVGPadding.left + 3}, ${SVGHeight - 130})`);\n\n    let legendPos = {width: 10, height: 100};\n\n    drawSaliencyLegend(legendGroup, legendPos, largestAbs, leftColor, rightColor);\n    \n    // Add token text to each node\n    let texts = nodeGroups.append('text')\n      .attr('class', 'node-text')\n      .style('font-weight', 600)\n      .text(d => d.token);\n\n    texts.filter(d => d3.hcl(nodeSaliencyColorScale(+d.saliency)).l < 66)\n      .clone(true)\n      .lower()\n      .style('stroke-linejoin', 'round')\n      .attr('stroke-width', 4)\n      .attr('stroke', 'white');\n    \n    nodeGroups.selectAll('circle').lower();\n\n    nodeGroups.append('title')\n      .text(d => d.token);\n\n    // Define the force\n    // Use the min threshold to init the simulation (it includes the most hidden nodes)\n    if (simulation == null) {\n      simulation = d3.forceSimulation(linkArrays[curLinkI].nodes);\n      // Change the min alpha so that the nodes do not shake at the end (end earlier)\n      // The default alphaMin is 0.000\n      // simulation.alphaMin(0.001);\n    } else {\n      simulation.nodes(linkArrays[curLinkI].nodes);\n      simulation.alpha(1).restart();\n    }\n\n    switch(currentLayout.value) {\n    case 'force':\n      initForceSim(nodeRadiusScale);\n      break;\n    case 'radial':\n      initRadialSim();\n      break;\n    case 'grid':\n      initGridSim();\n      break;\n    }\n\n    // Simulation tick updates\n    simulation.on('tick', () => simulationTick(nodeRadiusScale));\n\n    return nodeRadiusScale;\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    // weightThreshold = 0.05;\n\n    let svg = d3.select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Add arrow markers\n    svg.append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkColor)\n      .attr('fill', linkColor);\n    \n    // Create a different arrow marked used when user hovers over a node\n    svg.append('defs')\n      .append('marker')\n      .attr('id', 'arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkHoverColor)\n      .attr('fill', linkHoverColor);\n\n    nodeRadiusScale = initGraph();\n\n    // Register UI elements from the control panel\n    bindSlider('attention', 0, 10, forceStrength.force.attention);\n    bindSlider('textOrder', 0, 10, forceStrength.force.textOrder);\n    bindSlider('manyBody', -2000, 0, forceStrength.force.manyBody);\n    bindSlider('collideRadius', 0, 20, forceStrength.force.collideRadius, nodeRadiusScale);\n    bindSlider('threshold', weightThresholdMin, weightThresholdMax, weightThreshold, nodeRadiusScale);\n\n    bindSelect(nodeRadiusScale);\n\n    // Bind the layer and head selects\n    bindLayerHeadSelect();\n  };\n\n\n  const updateLayerHead = () => {\n\n    // Remove nodes and links\n    d3.select(graphSVG)\n      .select('g.node-group')\n      .remove();\n    \n    d3.select(graphSVG)\n      .select('g.attention-link-group')\n      .remove();\n    \n    d3.select(graphSVG)\n      .select('g.legend-group')\n      .remove();\n\n    // Update the graph data\n    graphData = createGraphData(curLayer, curHead);\n\n    initGraph();\n  };\n\n  /** Create CSS selector compatible name */\n  const tokenIDName = (tokenID) => {\n    if (tokenID == null) {\n      return null;\n    } else {\n      return tokenID.replace(/\\./g, '\\\\.')\n        .replace(/,/g, '\\\\,')\n        .replace(/#/g, '')\n        .replace(/\\[/g, '\\\\[')\n        .replace(/\\]/g, '\\\\]');\n    }\n  };\n\n  const highLightLink = (hoverToken) => {\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      // TODO\n      // .style('opacity', 0.05);\n      .style('opacity', 0.2);\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .filter((d, i, g) => d3.select(g[i]).attr('id').includes(`-${hoverToken}`))\n      .attr('marker-end', 'url(#arrow-hover)')\n      .classed('highlighted', true)\n      .style('stroke', null)\n      .style('stroke-width', 2)\n      .style('opacity', 0.8)\n      .raise();\n      // TODO\n      // .style('opacity', 0.9)\n      // .style('stroke-width', 2)\n      // .raise();\n\n    d3.select(graphSVG)\n      .select('.node-group')\n      .selectAll('.node')\n      .filter((d, i, g) => d3.select(g[i]).attr('id').includes(`-${hoverToken}`))\n      .raise()\n      .select('.shadow-circle')\n      .attr('r', d => currentLayout.value === 'force' ?\n        nodeRadiusScale(+d.saliency) + 5 : minNodeRadius + 5)\n      .style('stroke', 'white')\n      .style('stroke-width', 1.5);\n  };\n\n  const dehighlightLink = (hoverToken) => {\n\n    // TODO\n    // return;\n    // if (hoverToken.includes('jagged')) {\n    //   return;\n    // }\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .style('opacity', null);\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .filter((d, i, g) => d3.select(g[i]).attr('id').includes(`-${hoverToken}`))\n      .classed('highlighted', false)\n      .attr('marker-end', 'url(#arrow)')\n      .style('stroke', linkColor)\n      .style('stroke-width', d => linkWidth(d.attention))\n      .style('opacity', null);\n\n    d3.select(graphSVG)\n      .select('.node-group')\n      .selectAll('.node')\n      .filter((d, i, g) => d3.select(g[i]).attr('id').includes(`-${hoverToken}`))\n      .select('.shadow-circle')\n      .attr('r', d => currentLayout.value === 'force' ?\n        nodeRadiusScale(+d.saliency) : minNodeRadius)\n      .style('stroke', null)\n      .style('stroke-width', null)\n      .lower();\n  };\n\n  const createGraphData = (layer, head) => {\n    let curAttention = attentionData[layer][head];\n    let curAttentionData = {'nodes': [], 'links': []};\n    let curPredictedLabel = saliencyData[String(instanceID)]['meta']['predicted_label'];\n\n    // Add nodes\n    saliencyData[String(instanceID)]['tokens'].forEach((d, i) => {\n      curAttentionData.nodes.push({\n        token: d.token,\n        saliency: d[curPredictedLabel],\n        id: i\n      });\n    });\n\n    // Add links\n    for (let i = 0; i < curAttentionData.nodes.length; i++) {\n      for (let j = 0; j < curAttentionData.nodes.length; j++) {\n        curAttentionData.links.push({\n          source: i,\n          target: j,\n          weight: curAttention[i][j]\n        });\n      }\n    }\n\n    return curAttentionData;\n  };\n\n  const settingIconClicked = () => {\n    if (settingIconActive) {\n      settingIconActive = false;\n    } else {\n      settingIconActive = true;\n    }\n  };\n\n  hoverTokenStore.subscribe(value => {\n\n    if (value != null) {\n      curHoverToken = value;\n\n      // Check if the coming word has split subwords in graph vis\n      if (wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')] !== undefined) {\n        wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')].forEach(t => {\n          highLightLink(t);\n        });\n      } else {\n        highLightLink(curHoverToken);\n      }\n      \n    } else {\n\n      if (curHoverToken != null) {\n        // Check if the coming word has split subwords in graph vis\n        if (wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')] !== undefined) {\n          wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')].forEach(t => {\n            dehighlightLink(t);\n          });\n        } else {\n          dehighlightLink(curHoverToken);\n        }\n      }\n\n      curHoverToken = value;\n    }\n\n  });\n\n  const renderGraph = async () => {\n    // console.log('loading matrix');\n\n    // Load data from files if they have not been loaded\n    if (attentionData == null) {\n      attentionData = await d3.json(`PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`);\n    }\n    if (saliencyData == null) {\n      saliencyData = await d3.json('PUBLIC_URL/data/sst2-saliency-list-grad-l1.json');\n      tokenSize = saliencyData[instanceID].tokens.length;\n    }\n\n    // Create graph data\n    graphData = createGraphData(curLayer, curHead);\n\n    // graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    // console.log('loaded matrix');\n\n    drawGraph();\n  };\n\n  onMount(async() => {\n    if (attentionData == null) {\n      attentionData = await d3.json(`PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`);\n    }\n\n    if (saliencyData == null) {\n      saliencyData = await d3.json('PUBLIC_URL/data/sst2-saliency-list-grad-l1.json');\n      tokenSize = saliencyData[instanceID].tokens.length;\n    }\n\n    // gradSortedIndexes = await d3.json('PUBLIC_URL/data/sst2-sorted-grad-heads.json');\n    // gradSortedIndexes = gradSortedIndexes[instanceID];\n    // relevantAttentions = loadAttentionMatrix();\n    // console.log(relevantAttentions, saliencyData);\n    // console.log(tokenSize);\n\n    mounted = true;\n  });\n\n  graphViewConfigStore.subscribe(value => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined){\n      if (graphViewCompConfig === undefined ||\n        (graphViewCompConfig.compHeight !== value.compHeight &&\n        graphViewCompConfig.compWidth !== value.compWidth)\n      ){\n        // Update the height and width\n        graphViewCompConfig = value;\n        SVGHeight = graphViewCompConfig.compHeight;\n        SVGWidth = graphViewCompConfig.compWidth;\n        renderGraph();\n      }\n    }\n  });\n\n  wordToSubwordMapStore.subscribe(value => {\n    wordToSubwordMap = value;\n  });\n\n  instanceIDStore.subscribe(value => {\n    // console.log('Instance changed!!');\n    if (value !== instanceID) {\n\n      d3.select(graphSVG).selectAll('*').remove();\n\n      attentionData = null;\n      saliencyData = null;\n\n      instanceID = value;\n\n      renderGraph();\n    }\n    \n  });\n\n\n</script>\n\n<style type=\"text/scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  height: 100%;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}\n\n:global(.link.highlighted) {\n  stroke: #ffa31a;\n}\n\n:global(.border-rect) {\n  display: none;\n}\n\n.graph-label {\n  position: absolute;\n  color: gray;\n  font-size: 1.3rem;\n  margin: 5px 20px 0 20px;\n}\n\n.svg-container {\n  position: relative;\n}\n\n.svg-control-panel {\n  position: absolute;\n  top: 40px;\n  left: 0;\n  width: 200px;\n  cursor: default;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: flex-start;\n  font-size: 0.9em;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  box-shadow: 0 3px 3px rgba(49, 32, 18, 0.05);\n  background: rgba(255, 255, 255, 0.65);\n}\n.svg-control-panel .name {\n  font-size: 1em;\n  width: 94%;\n  padding: 5px 0px;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n}\n\n.sep-line-horizontal {\n  height: 0;\n  width: 95%;\n  border: 1px solid rgba(0, 0, 0, 0.06);\n}\n\n.sep-line-vertical {\n  height: 20px;\n  width: 0;\n  border: 1px solid rgba(0, 0, 0, 0.06);\n}\n\nselect {\n  height: 1.8em;\n  background: inherit;\n  border-color: rgba(0, 0, 0, 0);\n  padding: 0 1em 0 0.4em;\n}\nselect.select-num {\n  padding: 0 8px 0 0;\n  height: auto;\n  border-bottom: 3px solid rgba(167, 126, 98, 0.2);\n}\n\n.select-num-div::after {\n  top: 50%;\n  z-index: 0;\n}\n\n.select:not(.is-multiple) {\n  height: 1.8em;\n}\n\n.select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.2em;\n  border-color: #a77e62;\n  z-index: 0;\n}\n\n.select:not(.is-multiple).select-num-div {\n  height: auto;\n}\n.select:not(.is-multiple).select-num-div select {\n  margin: 0;\n}\n\n.select:not(.is-multiple).select-num-div::after {\n  right: 0.1em;\n  z-index: 0;\n}\n\n.select-row {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-around;\n  width: 94%;\n  padding: 3px 0;\n}\n\n.setting-icon {\n  padding: 0.1em 0.4em;\n  margin: 0 0.2em;\n  font-size: 1.1em;\n  color: #a77e62;\n  cursor: pointer;\n  border-radius: 3px;\n  transition: background 100ms ease-in-out;\n}\n.setting-icon:hover {\n  background: rgba(167, 126, 98, 0.1);\n}\n.setting-icon.active {\n  background: rgba(167, 126, 98, 0.2);\n}\n.setting-icon.active:hover {\n  background: rgba(167, 126, 98, 0.2);\n}\n\n.slider-container {\n  font-size: 0.9em;\n  padding: 0 15px 0 15px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-height: 0;\n  overflow: hidden;\n  transition: max-height 150ms ease-in-out;\n}\n.slider-container input {\n  width: 130px;\n}\n.slider-container .sep-line-horizontal {\n  width: 70%;\n  margin: 3px 0 10px 0;\n}\n.slider-container .sep-line-horizontal.longer-line {\n  width: 115%;\n  margin: 0 0 10px 0;\n}\n.slider-container.active {\n  max-height: 500px;\n  transition: max-height 300ms ease-in-out;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.slider-title {\n  color: rgba(0, 0, 0, 0.5);\n}\n\n.slider-text {\n  display: flex;\n  flex-direction: row;\n}\n.slider-text label {\n  margin-right: 5px;\n}\n\n.slider-value {\n  border-radius: 3px;\n  padding: 0 3px;\n  background: rgba(167, 126, 98, 0.2);\n  color: #836049;\n}</style>\n\n\n<div class='graph-view'>\n\n  <div class='svg-container'>\n\n    <div class='graph-label'>\n      Semantic Attention Graph\n    </div>\n\n    <!-- Control panel on top of the SVG -->\n    <div class='svg-control-panel'>\n      <div class='name'>\n        <div>\n          Layer \n          <div class='select select-num-div'>\n            <select name='layer' class='select-num' id='select-layer'>\n              {#each [...Array(12).keys()] as num}\n                <option value={num}>{num + 1}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n\n        <div>\n          Head\n          <div class='select select-num-div'>\n            <select name='layer' class='select-num' id='select-head'>\n              {#each [...Array(12).keys()] as num}\n                <option value={num}>{num + 1}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n\n      </div>\n\n      <div class='sep-line-horizontal'></div>\n\n      <div class='select-row'>\n\n        <div class='setting-icon'\n          on:click={settingIconClicked}\n          class:active={settingIconActive}\n        >\n          <i class=\"fas fa-sliders-h\"></i>\n        </div>\n\n        <div class='sep-line-vertical'></div>\n\n        <div class='select'>\n          <select name='layout' id='select-layout'>\n            {#each Object.values(layoutOptions) as opt}\n              <option value={opt.value}>{opt.name}</option>\n            {/each}\n          </select>\n        </div>\n\n      </div>\n\n      <!-- Slider panel -->\n      <div class='slider-container'\n        class:active={settingIconActive}\n      >\n        <div class='sep-line-horizontal longer-line'></div>\n\n        <div class='slider-title'>Edge Force</div>\n\n        <div class='sep-line-horizontal'></div>\n\n        <div class='slider'>\n\n          <div class='slider-text'>\n            <label for='attention'>Attention</label>\n            <div class='slider-value'>\n              {config.autoAttention ? 'auto' : round(forceStrength.force.attention, 2)}\n            </div>\n          </div>\n\n          <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"attention\">\n        </div>\n\n        <div class='slider'>\n\n          <div class='slider-text'>\n            <label for='textOrder'>Text Order</label>\n            <div class='slider-value'>\n              {round(forceStrength.force.textOrder, 2)}\n            </div>\n          </div>\n\n          <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"textOrder\">\n        </div>\n\n        <div class='slider'>\n\n          <div class='slider-text'>\n            <label for='manyBody'>ManyBody</label>\n            <div class='slider-value'>\n              {round(forceStrength.force.manyBody, 2)}\n            </div>\n          </div>\n\n          <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"manyBody\">\n        </div>\n\n        <div class='slider'>\n\n          <div class='slider-text'>\n            <label for='collide'>Node Distance</label>\n            <div class='slider-value'>\n              {round(forceStrength.force.collideRadius, 2)}\n            </div>\n          </div>\n\n          <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"collideRadius\">\n        </div>\n\n        <div class='slider-title'>Edge Threshold</div>\n\n        <div class='sep-line-horizontal'></div>\n\n        <div class='slider'>\n\n          <div class='slider-text'>\n            <label for='threshold'>Attention > </label>\n            <div class='slider-value'>\n              {round(weightThreshold, 2)}\n            </div>\n          </div>\n\n          <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" step=\"200\" class=\"slider\" id=\"threshold\">\n        </div>\n        \n      </div>\n\n    </div>\n\n    <svg class='graph-svg' bind:this={graphSVG}></svg>\n  </div>\n\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = {top: 3, left: 3, right: 3, bottom: 3};\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout'\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout'\n    } \n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.force\n  };\n\n  let forceStrength = {manyBody: 0, attention: 0, textOrder: 0};\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const drag = (simulation) => {\n  \n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    };\n    \n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n    \n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    };\n    \n    return d3.drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (d.saliency !== undefined) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGWidth - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(SVGPadding.left + curRadius, Math.min(width - curRadius, d.x));\n    const top = Math.max(SVGPadding.top + curRadius, Math.min(height - curRadius, d.y));\n\n    if (config.borderConstraint) {\n      return {top: top, left: left};\n    } else {\n      return {top: d.y, left: d.x};\n    }\n  };\n\n  const bindCheckBox = (simulation, links) => {\n    // Border checkbox\n    let borderCheckBox = d3.select('#checkbox-border')\n      .property('checked', config.borderConstraint);\n\n    borderCheckBox.on('change', (event) => {\n      config.borderConstraint = event.target.checked;\n      simulation.alpha(0.2).restart();\n    });\n\n    // Hidden links\n    let hiddenLinkCheckBox = d3.select('#checkbox-hidden-link')\n      .property('checked', config.showHiddenLink);\n    \n    hiddenLinkCheckBox.on('change', (event) => {\n      config.showHiddenLink = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.text-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n\n      d3.select(graphSVG)\n        .select('g.text-hidden-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n    });\n\n    // Hidden nodes\n    let hiddenNodeCheckBox = d3.select('#checkbox-hidden-node')\n      .property('checked', config.showHiddenNode);\n    \n    hiddenNodeCheckBox.on('change', (event) => {\n      config.showHiddenNode = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.hidden-node-group')\n        .style('visibility', config.showHiddenNode ? 'visible' : 'hidden');\n      simulation.alpha(0.05).restart();\n    });\n\n    // Automatic attention link strength checkbox\n    let autoCheckBox = d3.select('#checkbox-auto-attention')\n      .property('checked', config.autoAttention);\n    \n    autoCheckBox.on('change', (event) => {\n      config.autoAttention = event.target.checked;\n\n      if (config.autoAttention) {\n        simulation.force('attentionLink', d3.forceLink(links)\n          .id(d => d.id));\n        simulation.alpha(0.3).restart();\n      } else {\n        simulation.force('attentionLink')\n          .strength(forceStrength.attention);\n        simulation.alpha(0.3).restart();\n      }\n    });\n\n  };\n\n  const bindSlider = (name, simulation, min, max, defaultValue, nodeRadiusScale=null) => {\n    let slider = d3.select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      forceStrength[name] = value;\n\n      switch (name) {\n      case 'attention':\n        simulation.force('attentionLink').strength(value);\n        // Disable the auto attention\n        d3.select('#checkbox-auto-attention')\n          .property('checked', false);\n        config.autoAttention = false;\n        break;\n      case 'textOrder':\n        simulation.force('textLink').strength(value);\n        simulation.force('hiddenTextLink').strength(value);\n        break;\n      case 'manyBody':\n        simulation.force('charge').strength(value);\n        break;\n      case 'collide':\n        simulation.force('collide').radius(d => minNodeRadius + value);\n        break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const bindSelect = () => {\n    let selectOption = d3.select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayout = selectOption.property('value');\n\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3.select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter(d => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map(d => Object.create(d));\n    links = links.map(d => Object.create(d));\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach(d => nodeIndices.add(+d.id));\n\n    // Add text order hidden links\n    let hiddenLinks = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +nodes[i].id,\n        target: +nodes[i + 1].id\n      };\n      hiddenLinks.push(hiddenLink);\n    }\n    // hiddenLinks.push({\n    //   source: +nodes[nodes.length - 1].id,\n    //   target: nodes[0].id\n    // });\n    hiddenLinks = hiddenLinks.map(d => Object.create(d));\n    \n    // console.log(nodes, links);\n\n    // Add intermediate nodes to create bezier curves\n    let nodeByID = new Map(nodes.map(d => [d.id, d]));\n    let bilinks = [];\n    \n\n    links.forEach(d => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let intermediate = {hidden: true};\n\n      let curBilink = [source, intermediate, target];\n      curBilink.selfLoop = source === target;\n      \n      // nodes.push(intermediate);\n      // links.push(\n      //   {source: source, target: intermediate},\n      //   {source: intermediate, target: target}\n      // );\n\n      bilinks.push(curBilink);\n    });\n    \n    // Add grid links\n    let gridLinks = [];\n    let nodeIndexArray = Array.from(nodeIndices);\n    const rowSize = 10;\n\n    nodeIndexArray.sort((a, b) => +a - +b);\n    for (let i = 0; i < nodes.length; i++) {\n      if (i % rowSize !== rowSize - 1 & nodeByID.has(i + 1)) {\n        gridLinks.push({source: nodeByID.get(i), target: nodeByID.get(i + 1)});\n      }\n      if (nodeByID.has(i + rowSize)) {\n        gridLinks.push({source: nodeByID.get(i), target: nodeByID.get(i + rowSize)});\n      }\n    }\n\n    // console.log(gridLinks);\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map(d => +d.saliency);\n    let nodeRadiusScale = d3.scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .nice();\n    \n    // Define the force\n    let simulation = d3.forceSimulation(nodes);\n    const initManyBodyStrength = -1400;\n    const initAttentionStrength = 0.5;\n    const initTextOrderStrength = 2;\n    const initRadialStrength = 1;\n    const initCollideRadius = 7;\n\n    forceStrength.manyBody = initManyBodyStrength;\n    forceStrength.attention = initAttentionStrength;\n    forceStrength.textOrder = initTextOrderStrength;\n    forceStrength.radial = initRadialStrength;\n    forceStrength.collide = initCollideRadius;\n\n    // Force 1 (ManyBody force)\n    simulation.force('charge', d3.forceManyBody()\n      .strength(d => d.selfLoop == undefined ? -200 : 0)\n    );\n\n    // Force 2 (Center force)\n    simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // Force 3 (Link force)\n    // simulation.force('attentionLink', d3.forceLink(links)\n    //   .id(d => d.id)\n    //   //.strength(initAttentionStrength)\n    // );\n    \n    // Force 4 (Text order link force)\n    // simulation.force('textLink', d3.forceLink(hiddenLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );\n\n    // Force 8 (Grid force)\n    simulation.force('grid', d3.forceLink(gridLinks)\n      .iterations(80)\n      .distance(50)\n      .id(d => d.id)\n    );\n\n    simulation.force('posY', d3.forceY()\n      .y(d => Math.floor(d.index / rowSize) * SVGHeight / rowSize)\n    );\n\n    simulation.force('posX', d3.forceX()\n      .x(d => (d.index % rowSize) * SVGWidth / rowSize)\n    );\n\n    // Force 5 (Text order link force on hidden nodes)\n    // simulation.force('hiddenTextLink', d3.forceLink(hiddenTextOrderLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );    \n    \n    // Force 6 (Radial force)\n    // simulation.force('charge', d3.forceCollide().radius(d => nodeRadiusScale(d.saliency) + 15))\n    //   .force('radial', d3.forceRadial(300)\n    //     .x(SVGWidth / 2)\n    //     .y(SVGHeight / 2)\n    //     .strength(initRadialStrength)\n    //   );\n    \n    // Force 7 (Collide force)\n    simulation.force('collide', d3.forceCollide()\n      .radius(d => d.saliency === undefined ? 0 : minNodeRadius + 10)\n    );\n\n    // Change the min alpha so that the nodes do not shake at the end (end earlier)\n    // The default alphaMin is 0.0001\n    simulation.alphaMin(0.001);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg.append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    // Add attention links\n    let linkLines = svg.append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textLinkLines = svg.append('g')\n      .attr('class', 'text-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'red')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    // let textHiddenLinkLines = svg.append('g')\n    //   .attr('class', 'text-hidden-link-group')\n    //   .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n    //   .style('stroke', 'blue')\n    //   .style('stroke-opacity', 1)\n    //   .selectAll('line')\n    //   .data(hiddenTextOrderLinks)\n    //   .join('line')\n    //   .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg.append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(nodes.filter(d => d.id !== undefined))\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag(simulation));\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3.scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n    \n    nodeGroups.append('circle')\n      .attr('class', 'node-circle')\n      //.attr('r', d => nodeRadiusScale(+d.saliency))\n      .attr('r', minNodeRadius)\n      .style('fill', d => colorScale(d.id));\n    \n    // Add token text to each node\n    nodeGroups.append('text')\n      .attr('class', 'node-text')\n      .text(d => d.token);\n\n    nodeGroups.append('title')\n      .text(d => d.token);\n\n    // Add hidden nodes\n    let hiddenNodeGroups = svg.append('g')\n      .attr('class', 'hidden-node-group')\n      .style('visibility', config.showHiddenNode ? 'visible' : 'hidden')\n      .selectAll('g.hidden-node')\n      // Need to select intermediate nodes\n      .data(nodes.filter(d => d.id == undefined))\n      .join('g')\n      .attr('class', 'hidden-node');\n\n    hiddenNodeGroups.append('circle')\n      .attr('class', 'hidden-node-circle')\n      .attr('r', 3)\n      .style('fill', 'lightgreen');\n\n    // Simulation tick updates\n    simulation.on('tick', () => {\n      // console.log('Tick');\n\n      // Update the attention links\n      linkLines.attr('d', d => {\n        const sCoord = borderConstraint(d[0], nodeRadiusScale);\n        const tCoord = borderConstraint(d[2], nodeRadiusScale);\n\n        // We need to shorten the path to leave space for arrow\n        let halfLen = Math.sqrt((tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2);\n\n        let theta = minNodeRadius / halfLen;\n        let modTCoord = {\n          left: tCoord.left + (sCoord.left - tCoord.left) * theta,\n          top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n        };\n\n        return 'M' + sCoord.left + ',' + sCoord.top\n          + 'L' + modTCoord.left + ',' + modTCoord.top;\n      });\n\n\n      // Update the nodes\n      nodeGroups.attr('transform', d => {\n        // Maker sure the nodes are inside the box\n        const coord = borderConstraint(d, nodeRadiusScale);\n        return `translate(${coord.left}, ${coord.top})`;\n      });\n\n      // Update the hidden nodes\n      if (config.showHiddenNode) {\n        hiddenNodeGroups.attr('transform', d => {\n          // Maker sure the nodes are inside the box\n          const coord = borderConstraint(d);\n          return `translate(${coord.left}, ${coord.top})`;\n        });\n      }\n\n      // Update the text links\n      if (config.showHiddenLink) {\n        textLinkLines\n          .attr('x1', d => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', d => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', d => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', d => borderConstraint(d.target, nodeRadiusScale).top);\n\n        textHiddenLinkLines\n          .attr('x1', d => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', d => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', d => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', d => borderConstraint(d.target, nodeRadiusScale).top);\n      }\n\n    });\n\n    // Register UI elements from the control panel\n    bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    bindSlider('manyBody', simulation, -2000, 0, initManyBodyStrength);\n    bindSlider('collide', simulation, 0, 20, initCollideRadius, nodeRadiusScale);\n\n    bindCheckBox(simulation, links);\n\n    bindSelect();\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style type=\"text/scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}</style>\n\n<div class='graph-view'>\n  <div class='control-panel'>\n    <!-- Sliders -->\n    <div class='slider'>\n      <label for='attention'>Attention Strength\n        [{config.autoAttention ? 'auto' : round(forceStrength.attention, 2)}]\n      </label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"attention\">\n    </div>\n\n    <div class='slider'>\n      <label for='textOrder'>Text Order Strength [{round(forceStrength.textOrder, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"textOrder\">\n    </div>\n\n    <div class='slider'>\n      <label for='manyBody'>ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"manyBody\">\n    </div>\n\n    <div class='slider'>\n      <label for='collide'>Node Distance [{round(forceStrength.collide, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"collide\">\n    </div>\n\n    <!-- Checkboxes -->\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\">\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\">\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\">\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-border\">\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n    \n    <!-- Selection -->\n    <div class='select'>\n      <select name='layout' id='select-layout'>\n        <option value='force'>Force Layout</option>\n        <option value='radial'>Radial Layout</option>\n      </select>\n    </div>\n    \n  </div>\n\n  <div class='svg-container'>\n    <svg class='graph-svg' bind:this={graphSVG}></svg>\n  </div>\n  \n</div>",
    "<script>\n</script>\n\n<style type='text/scss'>#header {\n  height: 50px;\n  display: flex;\n  padding: 0 20px;\n  align-items: center;\n  background: #312012;\n  justify-content: space-between;\n}\n\n#logo {\n  display: flex;\n  align-items: baseline;\n}\n\n#logo-text {\n  font-size: 2rem;\n  color: white;\n  font-family: \"Fredoka One\";\n  margin-right: 10px;\n}\n\n#logo-tagline {\n  font-size: 1.5rem;\n  color: #aaa5a1;\n  font-family: \"Neucha\";\n}\n\n.icons {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  color: white;\n}\n.icons :not(:last-child) {\n  margin-right: 15px;\n}\n\n.icon {\n  font-size: 1.5rem;\n  display: flex;\n  align-items: center;\n  color: white;\n}</style>\n\n<div id=\"header\">\n\n  <div id=\"logo\">\n    <div id=\"logo-text\">\n      Dodrio\n    </div>\n    \n    <div id='logo-tagline'>\n      Exploring transformer models in your browser! \n    </div>\n  </div>\n\n  <div class=\"icons\">\n  \n    <a class=\"icon-a\" target=\"_blank\" href=\"https://arxiv.org/abs/2004.15004\">\n      <div class=\"icon\" title=\"Research paper\">\n        <i class=\"fas fa-file-pdf\"></i>\n      </div>\n    </a>\n\n    <a target=\"_blank\" href=\"https://youtu.be/HnWIHWFbuUQ\">\n      <div class=\"icon\" title=\"Demo video\">\n        <i class=\"fab fa-youtube\"></i>\n      </div>\n    </a>\n\n    <a target=\"_blank\" href=\"https://github.com/poloclub/cnn-explainer\">\n      <div class=\"icon\" title=\"Open-source code\">\n        <i class=\"fab fa-github\"></i>\n      </div>\n    </a>\n\n  </div>\n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import { lowerMapViewConfigStore, attentionHeadColorStore,\n    tooltipConfigStore, mapHeadStore } from './store';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  let svg = null;\n  let atlasData = null;\n  let attentions = null;\n  let saliencies = null;\n  let tokenSize = null;\n\n  // Tooltip variables\n  let tooltipConfig = null;\n  tooltipConfigStore.subscribe(value => {tooltipConfig = value;});\n\n  let viewContainer = null;\n  let mapHead = {layer: 9, head: 8};\n  let curLayer = 9;\n  let curHead = 8;\n\n  let attentionHeadColors = new Map;\n\n  const red = d3.hcl(23, 85, 56);\n  const purple = d3.hcl(328, 85, 56);\n  const blue = d3.hcl(274, 85, 56);\n\n  let instanceID = 1562;\n  const dispatch = createEventDispatcher();\n  let isShown = true;\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n\n  const SVGPadding = {top: 40, left: 10, right: 10, bottom: 3};\n\n  const ease = d3.easeCubicInOut;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const createGraph = () => {\n\n    const layerNum = attentions.length;\n    const headNum = attentions[0].length;\n    const layerNameWidth = 35;\n    const headNameHeight = 17;\n\n    let availableWidth = SVGWidth - layerNameWidth - SVGPadding.left - SVGPadding.right;\n    let availableHeight = SVGHeight - SVGPadding.top - SVGPadding.bottom - headNameHeight;\n\n    let availableLength = Math.min(availableHeight, availableWidth);\n    // console.log(SVGHeight, availableLength, availableWidth, availableHeight);\n    const gridGap = 8;\n\n    const gridLength = Math.floor((availableHeight - (layerNum - 1) * gridGap) / layerNum);\n    const maxOutRadius = gridLength / 2;\n    const minOutRadius = 3;\n\n    let adjustedRowGap = Math.floor((availableWidth - maxOutRadius - headNum * gridLength) / (layerNum - 1));\n    let adjustedColGap = Math.floor((availableHeight - layerNum * gridLength) / (layerNum - 1));\n\n    svg = d3.select(svg)\n      .attr('width', availableWidth + layerNameWidth)\n      .attr('height', availableHeight + headNameHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', availableLength)\n      .attr('height', availableLength)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    let donutGroup = svg.append('g')\n      .attr('class', 'donut-group')\n      .attr('transform', `translate(${SVGPadding.left + maxOutRadius + layerNameWidth},\n        ${maxOutRadius + headNameHeight})`);\n    \n    // Create color scale\n    let hueScale = d3.scaleLinear()\n      .domain([-1, 0, 1])\n      .range([red, purple, blue]);\n\n    let lightnessScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([130, 40]);\n\n    // Use square root scale\n    let outRadiusScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([minOutRadius, maxOutRadius]);\n\n    let ringRadiusScale = d3.scaleLinear()\n      .domain([0, 1])\n      .range([4, 7]);\n\n    let scales = {\n      hueScale: hueScale,\n      lightnessScale: lightnessScale,\n      outRadiusScale: outRadiusScale,\n      ringRadiusScale: ringRadiusScale\n    };\n\n    let donuts = donutGroup.selectAll('g.donut')\n      .data(atlasData)\n      .join('g')\n      .attr('class', 'donut')\n      .style('cursor', 'pointer')\n      .attr('transform', d => `translate(${d.head * (maxOutRadius * 2 + adjustedRowGap)},\n        ${(layerNum - d.layer - 1) * (maxOutRadius * 2 + adjustedColGap)})`);\n\n    // Draw the donuts\n    donuts.each((d, i, g) => drawDonut(d, i, g, scales));\n\n    // Record the head color\n    // console.log(attentionHeadColors);\n    attentionHeadColorStore.set(attentionHeadColors);\n\n    donuts.on('mouseover',\n      (e, d) => {\n        // Show the tooltip\n        let node = e.currentTarget;\n        let position = node.getBoundingClientRect();\n        let curWidth = position.right - position.left;\n\n        let tooltipCenterX = position.x + curWidth / 2;\n        let tooltipCenterY = position.y - 90;\n\n        tooltipConfig.html = `\n        <div class='tooltip-tb' style='display: flex; flex-direction: column;\n          justify-content: center; font-weight: 800;'>\n          <div> Layer ${d.layer + 1} Head ${d.head + 1} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Semantic: ${round(d.semantic, 2)} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Syntactic ${round(d.syntactic, 2)} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Importance: ${round(d.confidence, 2)} </div>\n        </div>\n        `;\n        tooltipConfig.width = 130;\n        tooltipConfig.maxWidth = 130;\n        tooltipConfig.left = tooltipCenterX - tooltipConfig.width / 2;\n        tooltipConfig.top = tooltipCenterY;\n        tooltipConfig.fontSize = '0.8em';\n        tooltipConfig.show = true;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Show the background rect\n        let curDonut = d3.select(e.currentTarget);\n\n        if (!curDonut.classed('selected')){\n          curDonut.select('.donut-rect')\n            .style('opacity', 1);\n        }\n      })\n      .on('mouseleave', (e) => {\n        tooltipConfig.show = false;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Hide the background rect\n        let curDonut = d3.select(e.currentTarget);\n        if (!curDonut.classed('selected')){\n          curDonut.select('.donut-rect')\n            .style('opacity', 0);\n        }\n\n      })\n      .on('click', (e) => {\n        let curDonut = d3.select(e.currentTarget);\n        if (curDonut.classed('selected')) {\n          // pass\n        } else {\n          // Restore the currently selected rect\n          let preDonut = d3.select(\n            donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n              .node().parentNode\n          );\n\n          preDonut.select('.donut-rect')\n            .style('fill', 'hsl(0, 0%, 80%)')\n            .style('opacity', 0);\n          \n          preDonut.classed('selected', false);\n\n          // Style the new rect\n          curDonut.select('.donut-rect')\n            .style('fill', 'hsl(27, 47%, 13%)')\n            .style('opacity', 1);\n          \n          curDonut.classed('selected', true);\n\n          curLayer = +curDonut.data()[0].layer;\n          curHead = +curDonut.data()[0].head;\n\n          mapHead.layer = curLayer;\n          mapHead.head = curHead;\n          mapHeadStore.set(mapHead);\n        }\n      });\n\n    // Draw horizontal lines between rows\n    donutGroup.selectAll('g.row-line-group')\n      .data(Array(layerNum - 1).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'row-line-group')\n      .append('path')\n      .attr('d', d => {\n        return `M${-maxOutRadius}\n        ${(layerNum - d - 1 - 1/2) * (maxOutRadius * 2 + adjustedColGap)}\n        L${headNum * (maxOutRadius * 2 + adjustedRowGap) - maxOutRadius}\n        ${(layerNum - d - 1 - 1/2) * (maxOutRadius * 2 + adjustedColGap)}`;\n      })\n      .style('stroke', 'hsla(0, 0%, 0%, 0.1)');\n\n    // Draw the label names\n    let nameGroup = svg.append('g')\n      .attr('class', 'name-group')\n      .attr('transform', `translate(${SVGPadding.left}, ${maxOutRadius + headNameHeight})`);\n    \n    nameGroup.selectAll('g.layer-name-group')\n      .data(Array(layerNum).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'layer-name-group')\n      .attr('transform', d => `translate(${layerNameWidth - 5},\n        ${(layerNum - d - 1) * (maxOutRadius * 2 + adjustedColGap)})`)\n      .append('text')\n      .text(d => d > 0 ? d + 1 : `Layer ${d + 1}`);\n      \n    let headNameGroup = svg.append('g')\n      .attr('class', 'name-group')\n      .attr('transform', `translate(${SVGPadding.left + layerNameWidth + maxOutRadius},\n        ${5})`);\n\n    headNameGroup.selectAll('g.head-name-group')\n      .data(Array(layerNum).fill(0).map( (_, i) => i))\n      .join('g')\n      .attr('class', 'head-name-group')\n      .attr('transform', d => `translate(${d * (maxOutRadius * 2 + adjustedRowGap)},\n        ${0})`)\n      .append('text')\n      .text(d => d > 0 ? d + 1 : `Head ${d + 1}`);\n\n    // console.log(atlasData);\n\n    d3.select(viewContainer)\n      .select('.head-arrow')\n      .style('top', `${70 - 40}px`)\n      .style('left', `${availableWidth - 170}px`);\n\n    d3.select(viewContainer)\n      .select('.layer-arrow')\n      .style('top', `${70}px`)\n      .style('left', `${availableWidth + 10}px`);\n\n    // Highlight the initial selection\n    let curDonut = d3.select(\n      donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n        .node().parentNode\n    );\n\n    // Style the new rect\n    curDonut.select('.donut-rect')\n      .style('fill', 'hsl(27, 47%, 13%)')\n      .style('opacity', 1);\n    \n    curDonut.classed('selected', true);\n  };\n\n  mapHeadStore.subscribe(value => {\n    mapHead = value;\n    // console.log(mapHead, curLayer, curHead);\n\n    if (mapHead.layer !== curLayer || mapHead.head !== curHead) {\n\n      let donutGroup = svg.select('g.donut-group');\n\n      // Restore the currently selected rect\n      let preDonut = d3.select(\n        donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n          .node().parentNode\n      );\n      \n      preDonut.select('.donut-rect')\n        .style('fill', 'hsl(0, 0%, 80%)')\n        .style('opacity', 0);\n\n      preDonut.classed('selected', false);\n\n      curLayer = mapHead.layer;\n      curHead = mapHead.head;\n\n      let curDonut = d3.select(\n        donutGroup.select(`#donut-rect-${curLayer}-${curHead}`)\n          .node().parentNode\n      );\n\n      // Style the new rect\n      curDonut.select('.donut-rect')\n        .style('fill', 'hsl(27, 47%, 13%)')\n        .style('opacity', 1);\n      \n      curDonut.classed('selected', true);\n    }\n  });\n\n  const drawDonut = (d, i, g, scales) => {\n    let donut = d3.select(g[i]);\n\n    let outRadius = scales.outRadiusScale(d.confidence);\n    let ringRadius = scales.ringRadiusScale(d.confidence);\n    let inRadius = Math.max(0, outRadius - ringRadius);\n\n    // Draw the background rect\n    let maxLength = 2 * scales.outRadiusScale.range()[1];\n    donut.append('rect')\n      .attr('class', 'donut-rect')\n      .attr('id', `donut-rect-${d.layer}-${d.head}`)\n      .attr('x', - maxLength / 2)\n      .attr('y', - maxLength / 2)\n      .attr('rx', 5)\n      .attr('width', maxLength)\n      .attr('height', maxLength)\n      .style('fill', 'hsl(0, 0%, 80%)')\n      .style('opacity', 0);\n\n    // Draw the rings\n    // Arc's center is at (0, 0) on the local coordinate\n    let arc = d3.arc()\n      .outerRadius(outRadius)\n      .innerRadius(0)\n      .startAngle(0)\n      .endAngle(Math.PI * 2);\n\n    let color = d3.hcl(scales.hueScale(d.syntactic - d.semantic));\n    color.l = scales.lightnessScale(Math.max(d.semantic, d.syntactic));\n\n    // Record the color\n    attentionHeadColors.set([d.layer, d.head].toString(), color.formatHex());\n\n    donut.append('path')\n      .attr('class', 'donut-chart')\n      .attr('d', arc)\n      .style('fill', color);\n\n    // Draw the edges\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < tokenSize; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / tokenSize);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        token: d.token,\n        id: i\n      });\n    }\n  };\n\n  const initData = async (attentionFile, saliencyFile, atlasFile) => {\n    // Init attention data\n    attentions = await d3.json(attentionFile);\n\n    // init atlas data\n    atlasData = await d3.json(atlasFile);\n    \n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n    tokenSize = saliencies.tokens.length;\n  };\n\n  onMount(async () => {\n    // Load the attention and atlas data\n    if (attentions == null || atlasData == null || saliencies == null) {\n      initData(\n        `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`,\n        'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n        'PUBLIC_URL/data/sst2-atlas.json'\n      );\n    }\n  });\n\n  lowerMapViewConfigStore.subscribe(async value => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined){\n      if (instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n        instanceViewConfig.compWidth !== value.compWidth)\n      ){\n        instanceViewConfig = value;\n        \n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight;\n\n        // Load the attention and atlas data\n        if (attentions == null || atlasData == null || saliencies == null) {\n          initData(\n            `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`,\n            'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n            'PUBLIC_URL/data/sst2-atlas.json'\n          ).then(createGraph);\n        } else {\n          createGraph();\n        }\n      }\n    }\n  });\n\n</script>\n\n<style type='text/scss'>:global(.layer-name-group text) {\n  dominant-baseline: middle;\n  text-anchor: end;\n  font-size: 0.7em;\n  fill: rgba(0, 0, 0, 0.3);\n}\n\n:global(.head-name-group text) {\n  dominant-baseline: hanging;\n  text-anchor: middle;\n  font-size: 0.7em;\n  fill: rgba(0, 0, 0, 0.3);\n}\n\n.svg-container {\n  width: 100%;\n  height: 100%;\n  overflow-x: hidden;\n  position: relative;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  align-items: flex-end;\n}\n\n.atlas-view {\n  display: flex;\n  flex-direction: row;\n  max-width: 100%;\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n  transition: max-width 1000ms ease-in-out;\n}\n\n.atlas-svg-container {\n  position: relative;\n}\n\n.control-row {\n  position: absolute;\n  top: 0;\n  left: 0;\n  cursor: default;\n  padding-top: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  user-select: none;\n  font-size: 0.9rem;\n  z-index: 5;\n}\n\n.lower-atlas-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 20px 0 20px;\n}\n\n.expand-button {\n  padding: 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 5px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n\n.icon-wrapper {\n  margin-right: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 0.5;\n}\n.icon-wrapper img {\n  height: 1.2em;\n}\n\n.color-legend {\n  margin-left: 20px;\n  display: flex;\n}\n.color-legend img {\n  height: 22px;\n}</style>\n\n<div class='atlas-view' bind:this={viewContainer}>\n\n  <div class='control-row'>\n\n    <div class='lower-atlas-label'>\n      Attention Head Overview\n    </div>\n\n    <div class='select-row'>\n      <div class='relation-container' on:click={() => dispatch('open')}>\n        <div class='expand-button'>\n          <div class='icon-wrapper'>\n            <img src='PUBLIC_URL/figures/expand-outline.svg' alt='expanding icon'>\n          </div>\n          Show Detail\n        </div>\n      </div>\n    </div>\n\n    <div class='color-legend'>\n      <img src='PUBLIC_URL/figures/color-legend.png' alt='expanding icon'>\n    </div>\n\n  </div>\n\n\n  <div class='svg-container'>\n\n    <div class='atlas-svg-container'>\n      <svg class='atlas-svg' bind:this={svg}></svg>\n    </div>\n\n  </div>\n  \n</div>",
    "<script>\n  import Header from './Header.svelte';\n  import GraphView from './GraphView.svelte';\n  import Dependency from './dependency-view/Dependency.svelte';\n  import Atlas from './Atlas.svelte';\n  import AtlasSide from './AtlasSide.svelte';\n  import Tooltip from './TooltipGlobal.svelte';\n  import LowerAtlas from './LowerAtlas.svelte';\n  import TableModal from './TableModal.svelte';\n  import { graphViewConfigStore, instanceViewConfigStore,\n    mapViewConfigStore, lowerMapViewConfigStore, comparisonViewStore,\n    tooltipConfigStore, sideStore } from './store';\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  // Set up the tooltip\n  let tooltip = null;\n  let atlasSVGWidth = null;\n  let atlasSVGHeight = null;\n  const headerHeight = 50;\n\n  let downButton;\n  let buttonDown = true;\n  let downButtonPos = {\n    width: 50,\n    height: 20\n  };\n\n  let tooltipConfig = {\n    show: false,\n    html: '1.23',\n    left: 0,\n    top: 0,\n    width: 80,\n    maxWidth: 80,\n    fontSize: '1em'\n  };\n\n  tooltipConfigStore.subscribe(value => {tooltipConfig = value;});\n\n  let sideInfo = {};\n  sideStore.subscribe(value => {sideInfo = value;});\n\n  let lowerContainerDIV = null;\n  let graphViewDIV = null;\n  let graphViewConfig = {\n    compWidth: null,\n    compHeight: null\n  };\n  \n  let originalInstanceViewHeight = null;\n  let instanceViewDIV = null;\n  let instanceViewConfig = {\n    compWidth: null,\n    compHeight: null\n  };\n\n  let comparisonViewConfig = {};\n  comparisonViewStore.subscribe(value => {\n    comparisonViewConfig = value;\n  });\n\n  let mapViewDIV = null;\n  let mapViewConfig = {\n    compWidth: null,\n    compHeight: null\n  };\n\n  let lowerMapViewDIV = null;\n  let lowerMapViewConfig = {\n    compWidth: null,\n    compHeight: null\n  };\n\n  /**\n   * Open the large map view.\n   */\n  const atlasOpened = () => {\n    mapViewDIV.style['display'] = '';\n    mapViewDIV.style['opacity'] = '1';\n  };\n\n  /**\n   * Close the large map view.\n   */\n  const atlasClosed = () => {\n\n    d3.select(mapViewDIV)\n      .select('.legend-container')\n      .style('display', 'none');\n\n    let svg =  d3.select(mapViewDIV)\n      .select('.atlas-svg-container')\n      .style('width', '100%')\n      .style('height', '100%')\n      .select('.atlas-svg-full');\n\n    atlasSVGWidth = svg.attr('width');\n    atlasSVGHeight = svg.attr('height');\n\n    svg.attr('width', null)\n      .attr('height', null)\n      .style('padding-top', '36px')\n      .style('padding-left', '8px')\n      .style('width', '100%')\n      .style('height', '100%');\n    \n    mapViewDIV.style['width'] = `${lowerMapViewConfig.compWidth}px`;\n    mapViewDIV.style['height'] = `${lowerMapViewConfig.compHeight}px`;\n    mapViewDIV.style['opacity'] = 0;\n\n    const transitionEnd = () => {\n      mapViewDIV.style['display'] = 'none';\n      mapViewDIV.style['visibility'] = '';\n      mapViewDIV.style['width'] = '1000px';\n      mapViewDIV.style['height'] = '100%';\n\n      d3.select(mapViewDIV)\n        .select('.legend-container')\n        .style('display', null);\n\n      d3.select(mapViewDIV)\n        .select('.atlas-svg-container')\n        .style('width', null)\n        .style('height', null)\n        .select('.atlas-svg-full')\n        .style('padding-top', null)\n        .style('padding-left', null)\n        .style('width', null)\n        .style('height', null)\n        .attr('width', atlasSVGWidth)\n        .attr('height', atlasSVGHeight);\n\n      mapViewDIV.removeEventListener('transitionend', transitionEnd);\n    };\n\n    mapViewDIV.addEventListener('transitionend', transitionEnd);\n  };\n\n  const downButtonClicked = () => {\n\n    // Enter comparison view\n    if (buttonDown) {\n      instanceViewDIV.style.height = '100%';\n      lowerContainerDIV.style.bottom = `-${graphViewConfig.compHeight - 10}px`;\n      downButton.style.top = `${originalInstanceViewHeight + headerHeight\n        - downButtonPos.height / 2 + graphViewConfig.compHeight - 10}px`;\n\n      comparisonViewConfig.height = Math.floor(instanceViewDIV.clientHeight) - 5;\n      comparisonViewConfig.inComparison = true;\n      comparisonViewStore.set(comparisonViewConfig);\n    } else {\n      // Exit comparison view\n      instanceViewDIV.style.height = '34%';\n      lowerContainerDIV.style.bottom = '0px';\n      downButton.style.top = `${originalInstanceViewHeight + headerHeight\n        - downButtonPos.height / 2}px`;\n\n      comparisonViewConfig.height = originalInstanceViewHeight - 5;\n      comparisonViewConfig.inComparison = false;\n      comparisonViewStore.set(comparisonViewConfig);\n    }\n\n    buttonDown = !buttonDown;\n  };\n\n  const comparisonOpenHandler = () => {\n    instanceViewDIV.style.height = '100%';\n    lowerContainerDIV.style.bottom = `-${graphViewConfig.compHeight - 10}px`;\n    downButton.style.top = `${originalInstanceViewHeight + headerHeight\n      - downButtonPos.height / 2 + graphViewConfig.compHeight - 10}px`;\n    buttonDown = false;\n\n    comparisonViewConfig.height = Math.floor(instanceViewDIV.clientHeight) - 5;\n    comparisonViewConfig.inComparison = true;\n    comparisonViewStore.set(comparisonViewConfig);\n  };\n\n  const comparisonCloseHandler = () => {\n    instanceViewDIV.style.height = '34%';\n    lowerContainerDIV.style.bottom = '0px';\n    downButton.style.top = `${originalInstanceViewHeight + headerHeight\n      - downButtonPos.height / 2}px`;\n    buttonDown = true;\n\n    comparisonViewConfig.height = originalInstanceViewHeight - 5;\n    comparisonViewConfig.inComparison = false;\n    comparisonViewStore.set(comparisonViewConfig);\n  };\n\n  onMount(() => {\n    graphViewConfig.compWidth = Math.floor(graphViewDIV.clientWidth);\n    graphViewConfig.compHeight = Math.floor(graphViewDIV.clientHeight);\n    graphViewConfigStore.set(graphViewConfig);\n\n    instanceViewConfig.compWidth = Math.floor(instanceViewDIV.clientWidth);\n    // Need to offset the horizontal scroll bar height\n    instanceViewConfig.compHeight = Math.floor(instanceViewDIV.clientHeight) - 5;\n    instanceViewConfigStore.set(instanceViewConfig);\n    originalInstanceViewHeight = Math.floor(instanceViewDIV.clientHeight);\n\n    lowerMapViewConfig.compWidth = Math.floor(lowerMapViewDIV.clientWidth);\n    lowerMapViewConfig.compHeight = Math.floor(lowerMapViewDIV.clientHeight);\n    lowerMapViewConfigStore.set(lowerMapViewConfig);\n\n    // Need to offset the padding\n    mapViewConfig.compWidth = Math.floor(mapViewDIV.clientWidth - 10);\n    mapViewConfig.compHeight = Math.floor(mapViewDIV.clientHeight - 10);\n    mapViewConfigStore.set(mapViewConfig);\n\n    // Hide the large map view\n    mapViewDIV.style['opacity'] = '0';\n    mapViewDIV.style['visibility'] = 'hidden';\n    atlasClosed();\n\n    // Position the down button\n    // console.log(headerHeight, downButtonPos.height);\n    downButton.style.top = `${Math.floor(instanceViewDIV.clientHeight) + headerHeight\n      - downButtonPos.height / 2}px`;\n    downButton.style.left = `${graphViewConfig.compWidth - downButtonPos.width / 2}px`;\n    downButton.style.width = `${downButtonPos.width}px`;\n    downButton.style.height = `${downButtonPos.height}px`;\n    downButton.style.visibility = 'visible';\n  });\n\n</script>\n\n<style type='text/scss'>.main-content {\n  border-bottom: solid 1px rgba(0, 0, 0, 0.2);\n  height: min(800px, calc(100vh - 50px));\n  width: 100vw;\n  display: flex;\n  box-sizing: border-box;\n  overflow: show;\n}\n\n.select-container {\n  border-right: solid 1px rgba(0, 0, 0, 0.2);\n  height: 100%;\n  display: flex;\n  overflow: scroll;\n  flex-direction: column;\n  box-sizing: border-box;\n}\n\n.attention-container {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  overflow: visible;\n  flex-direction: column;\n  box-sizing: border-box;\n  position: relative;\n}\n\n.instance-container {\n  width: 100%;\n  height: 34%;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n\n.lower-container {\n  border-top: solid 1px rgba(0, 0, 0, 0.2);\n  width: 100%;\n  height: 66%;\n  overflow: hidden;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: row;\n  background: #fcfcfc;\n  box-shadow: 0 -5px 5px rgba(0, 0, 0, 0.07);\n  position: absolute;\n  bottom: 0;\n  transition: bottom 300ms ease-in-out;\n}\n\n.graph-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  box-sizing: border-box;\n  position: relative;\n}\n\n.lower-atlas-container {\n  width: 60%;\n  height: 100%;\n  overflow: hidden;\n  box-sizing: border-box;\n  border-left: solid 1px rgba(0, 0, 0, 0.2);\n}\n\n.atlas-container {\n  width: 1000px;\n  max-width: 100%;\n  height: 100%;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  z-index: 11;\n  padding: 10px 0 0 10px;\n  transition: width 500ms ease-in-out, height 500ms ease-in-out, opacity 500ms ease-in-out;\n}\n\n.atlas-sidebar {\n  justify-self: flex-end;\n  background: #fafafa;\n  box-shadow: -3px 0 5px rgba(0, 0, 0, 0.1);\n  position: absolute;\n  right: 989px;\n  top: 300px;\n  width: 400px;\n  height: 450px;\n}\n\n.hidden {\n  visibility: hidden;\n}\n\n:global(.atlas-container.closed) {\n  transition: right 700ms ease-in-out, background-color 100ms ease-in-out 600ms;\n}\n\n.down-button {\n  position: absolute;\n  width: 50px;\n  height: 8px;\n  font-size: 0.7em;\n  visibility: hidden;\n  border-radius: 15px;\n  z-index: 10;\n  cursor: pointer;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  background: white;\n  box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.2);\n  transition: background 300ms ease-in-out, top 300ms ease-in-out;\n}\n.down-button:hover {\n  background: #ede4de;\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  opacity: 1;\n}\n.icon-wrapper svg {\n  height: 20px;\n  color: #a77e62;\n}\n\n.up-down {\n  transform: rotate(180deg);\n}</style>\n\n<div class='main'>\n\n  <Header />\n\n  <Tooltip bind:this={tooltip}/>\n \n  <div class='main-content'>\n    <div class='select-container'>\n\n    </div>\n\n    <div class='attention-container'>\n      <!-- Instance View -->\n      <div class='instance-container' bind:this={instanceViewDIV}>\n        <Dependency on:close={comparisonCloseHandler} on:open={comparisonOpenHandler}/>\n      </div>\n\n      \n      <div class='lower-container' bind:this={lowerContainerDIV}>\n        <!-- Graph View -->\n        <div class='graph-container' bind:this={graphViewDIV} >\n          <GraphView />\n        </div>\n\n        <div class='lower-atlas-container' bind:this={lowerMapViewDIV}>\n          <LowerAtlas on:open={atlasOpened}/>\n        </div>\n      </div>\n\n\n      <!-- Map view -->\n      <div class='atlas-container' style='visibility=hidden' bind:this={mapViewDIV}>\n        <Atlas on:close={atlasClosed}/>\n      </div>\n\n      <div class='atlas-sidebar' class:hidden={!sideInfo.show}>\n        <AtlasSide />\n      </div>\n\n    </div>\n\n    <TableModal on:xClicked={() => {}} on:urlTyped={() => {}}/>\n\n    <div class='down-button' bind:this={downButton}>\n      <div class='icon-wrapper' on:click={downButtonClicked}>\n        <svg class='icon-down' class:up-down={!buttonDown} viewBox='0 0 512 512'>\n          <path fill='none' stroke='currentColor' stroke-linecap='round'\n            stroke-linejoin='round' stroke-width='80' d='M112 184l144 144 144-144'/>\n        </svg>\n      </div>\n    </div>\n\n  </div>\n\n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = {top: 3, left: 3, right: 3, bottom: 3};\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  const radialRadius = 300;\n  const radialStrength = 0.8;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout'\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout'\n    } \n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.force\n  };\n\n  let forceStrength = {manyBody: 0, attention: 0, textOrder: 0};\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * (10 ** decimal)) / (10 ** decimal);\n  };\n\n  const drag = (simulation) => {\n  \n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    };\n    \n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n    \n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    };\n    \n    return d3.drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (d.saliency !== undefined) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGWidth - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(SVGPadding.left + curRadius, Math.min(width - curRadius, d.x));\n    const top = Math.max(SVGPadding.top + curRadius, Math.min(height - curRadius, d.y));\n\n    if (config.borderConstraint) {\n      return {top: top, left: left};\n    } else {\n      return {top: d.y, left: d.x};\n    }\n  };\n\n  const bindCheckBox = (simulation, links) => {\n    // Border checkbox\n    let borderCheckBox = d3.select('#checkbox-border')\n      .property('checked', config.borderConstraint);\n\n    borderCheckBox.on('change', (event) => {\n      config.borderConstraint = event.target.checked;\n      simulation.alpha(0.2).restart();\n    });\n\n    // Hidden links\n    let hiddenLinkCheckBox = d3.select('#checkbox-hidden-link')\n      .property('checked', config.showHiddenLink);\n    \n    hiddenLinkCheckBox.on('change', (event) => {\n      config.showHiddenLink = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.text-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n\n      d3.select(graphSVG)\n        .select('g.text-hidden-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n    });\n\n    // Hidden nodes\n    let hiddenNodeCheckBox = d3.select('#checkbox-hidden-node')\n      .property('checked', config.showHiddenNode);\n    \n    hiddenNodeCheckBox.on('change', (event) => {\n      config.showHiddenNode = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.hidden-node-group')\n        .style('visibility', config.showHiddenNode ? 'visible' : 'hidden');\n      simulation.alpha(0.05).restart();\n    });\n\n    // Automatic attention link strength checkbox\n    let autoCheckBox = d3.select('#checkbox-auto-attention')\n      .property('checked', config.autoAttention);\n    \n    autoCheckBox.on('change', (event) => {\n      config.autoAttention = event.target.checked;\n\n      if (config.autoAttention) {\n        simulation.force('attentionLink', d3.forceLink(links)\n          .id(d => d.id));\n        simulation.alpha(0.3).restart();\n      } else {\n        simulation.force('attentionLink')\n          .strength(forceStrength.attention);\n        simulation.alpha(0.3).restart();\n      }\n    });\n\n  };\n\n  const bindSlider = (name, simulation, min, max, defaultValue, nodeRadiusScale=null) => {\n    let slider = d3.select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      forceStrength[name] = value;\n\n      switch (name) {\n      case 'attention':\n        simulation.force('attentionLink').strength(value);\n        // Disable the auto attention\n        d3.select('#checkbox-auto-attention')\n          .property('checked', false);\n        config.autoAttention = false;\n        break;\n      case 'textOrder':\n        simulation.force('textLink').strength(value);\n        simulation.force('hiddenTextLink').strength(value);\n        break;\n      case 'manyBody':\n        simulation.force('charge').strength(value);\n        break;\n      case 'collide':\n        simulation.force('collide').radius(d => nodeRadiusScale(d.saliency) + value);\n        break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const bindSelect = () => {\n    let selectOption = d3.select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayout = selectOption.property('value');\n\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3.select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter(d => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map(d => Object.create(d));\n    links = links.map(d => Object.create(d));\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach(d => nodeIndices.add(+d.id));\n\n    // Add text order hidden links\n    let hiddenLinks = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +nodes[i].id,\n        target: +nodes[i + 1].id\n      };\n      hiddenLinks.push(hiddenLink);\n    }\n\n    // Link the last token to the first token\n    hiddenLinks.push({\n      source: +nodes[nodes.length - 1].id,\n      target: nodes[0].id\n    });\n\n    hiddenLinks = hiddenLinks.map(d => Object.create(d));\n    \n    // console.log(nodes, links);\n\n    // Add intermediate nodes to create bezier curves\n    let nodeByID = new Map(nodes.map(d => [d.id, d]));\n    let bilinks = [];\n\n    // Add links between intermediate node and its previous token and afterward\n    // token\n    let hiddenTextOrderLinks = [];\n\n    links.forEach(d => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let intermediate = {hidden: true};\n\n      let curBilink = [source, intermediate, target];\n      curBilink.selfLoop = source === target;\n      \n      //nodes.push(intermediate);\n      links.push(\n        {source: source, target: intermediate},\n        {source: intermediate, target: target}\n      );\n\n      bilinks.push(curBilink);\n\n      if (nodeIndices.has(d.source - 1)) {\n        hiddenTextOrderLinks.push(\n          {source: nodeByID.get(d.source - 1), target: intermediate}\n        );\n      }\n\n      if (nodeIndices.has(d.source + 1)) {\n        hiddenTextOrderLinks.push(\n          {source: intermediate, target: nodeByID.get(d.source + 1)}\n        );\n      }\n\n      if (nodeIndices.has(d.target - 1)) {\n        hiddenTextOrderLinks.push(\n          {source: nodeByID.get(d.target - 1), target: intermediate}\n        );\n      }\n\n      if (nodeIndices.has(d.target + 1)) {\n        hiddenTextOrderLinks.push(\n          {source: intermediate, target: nodeByID.get(d.target + 1)}\n        );\n      }\n    });\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map(d => +d.saliency);\n    let nodeRadiusScale = d3.scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .nice();\n    \n    // Define the force\n    let simulation = d3.forceSimulation(nodes);\n    const initManyBodyStrength = -1400;\n    const initAttentionStrength = 0.5;\n    const initTextOrderStrength = 2;\n    const initRadialStrength = 1;\n    const initCollideRadius = 7;\n\n    forceStrength.manyBody = initManyBodyStrength;\n    forceStrength.attention = initAttentionStrength;\n    forceStrength.textOrder = initTextOrderStrength;\n    forceStrength.radial = initRadialStrength;\n    forceStrength.collide = initCollideRadius;\n\n    // Force 1 (ManyBody force)\n    // simulation.force('charge', d3.forceManyBody()\n    //   .strength(initManyBodyStrength)\n    // );\n\n    // // Force 2 (Center force)\n    // simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // // Force 3 (Link force)\n    // simulation.force('attentionLink', d3.forceLink(links)\n    //   .id(d => d.id)\n    //   //.strength(initAttentionStrength)\n    // );\n    \n    // // Force 4 (Text order link force)\n    simulation.force('textLink', d3.forceLink(hiddenLinks)\n      .id(d => d.id)\n      .strength(initTextOrderStrength)\n    );\n\n    // // Force 5 (Text order link force on hidden nodes)\n    // simulation.force('hiddenTextLink', d3.forceLink(hiddenTextOrderLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );    \n    \n    // Force 6 (Radial force)\n    // simulation.force('radial', d3.forceRadial(300)\n    //   .x(SVGWidth / 2)\n    //   .y(SVGHeight / 2)\n    //   .strength(initRadialStrength)\n    // );\n  \n    // Force 9 Custom radial force\n    let nodeIndexArray = Array.from(nodeIndices);\n\n    let radialScale = d3.scaleLinear()\n      .domain(d3.extent(nodeIndexArray))\n      .range([-Math.PI / 2, Math.PI * 3 / 2])\n      .nice();\n\n\n\n    simulation.force('posY', d3.forceY()\n      .y(d => SVGWidth / 2 + Math.sin(radialScale(d.index)) * radialRadius)\n      .strength(radialStrength)\n    );\n\n    simulation.force('posX', d3.forceX()\n      .x(d => SVGWidth / 2 + Math.cos(radialScale(d.index)) * radialRadius)\n      .strength(radialStrength)\n    );\n    \n    // Force 7 (Collide force)\n    simulation.force('collide', d3.forceCollide().radius(minNodeRadius));\n\n    // Change the min alpha so that the nodes do not shake at the end (end earlier)\n    // The default alphaMin is 0.0001\n    simulation.alphaMin(0.001);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg.append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    // Add attention links\n    let linkLines = svg.append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textLinkLines = svg.append('g')\n      .attr('class', 'text-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'red')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textHiddenLinkLines = svg.append('g')\n      .attr('class', 'text-hidden-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'blue')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenTextOrderLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg.append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(nodes.filter(d => d.id !== undefined))\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag(simulation));\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3.scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n    \n    nodeGroups.append('circle')\n      .attr('class', 'node-circle')\n      //.attr('r', d => nodeRadiusScale(+d.saliency))\n      .attr('r', minNodeRadius)\n      .style('fill', d => colorScale(d.id));\n    \n    // Add token text to each node\n    nodeGroups.append('text')\n      .attr('class', 'node-text')\n      .text(d => d.token);\n\n    nodeGroups.append('title')\n      .text(d => d.token);\n\n    // Add hidden nodes\n    let hiddenNodeGroups = svg.append('g')\n      .attr('class', 'hidden-node-group')\n      .style('visibility', config.showHiddenNode ? 'visible' : 'hidden')\n      .selectAll('g.hidden-node')\n      // Need to select intermediate nodes\n      .data(nodes.filter(d => d.id == undefined))\n      .join('g')\n      .attr('class', 'hidden-node');\n\n    hiddenNodeGroups.append('circle')\n      .attr('class', 'hidden-node-circle')\n      .attr('r', 3)\n      .style('fill', 'lightgreen');\n\n    // Simulation tick updates\n    simulation.on('tick', () => {\n      // console.log('Tick');\n\n      // Update the attention links\n      linkLines.attr('d', d => {\n        let source = {x: d[0].x, y: d[0].y};\n        let target = {x: d[2].x, y: d[2].y};\n\n        let center = {x: SVGWidth / 2, y: SVGHeight / 2};\n\n        // We need to shorten the path to leave space for arrow\n        let theta = 1 - minNodeRadius / radialRadius;\n        let modTarget = {\n          x: center.x + (target.x - center.x) * theta,\n          y: center.y + (target.y - center.y) * theta,\n        };\n\n        let modSource = {\n          x: center.x + (source.x - center.x) * theta,\n          y: center.y + (source.y - center.y) * theta,\n        };\n        \n        let controlAlpha = 3 / 5;\n\n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (modSource.x - center.x) * controlAlpha,\n          y: center.y + (modSource.y - center.x) * controlAlpha\n        };\n\n        let controlP2 = {\n          x: center.x + (modTarget.x - center.x) * controlAlpha,\n          y: center.y + (modTarget.y - center.x) * controlAlpha\n        };\n\n        return `M ${modSource.x},${modSource.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${modTarget.x},${modTarget.y}`;\n      });\n\n      // Update the nodes\n      nodeGroups.attr('transform', d => {\n        // Maker sure the nodes are inside the box\n        const coord = borderConstraint(d, nodeRadiusScale);\n        return `translate(${coord.left}, ${coord.top})`;\n      });\n\n      // Update the hidden nodes\n      if (config.showHiddenNode) {\n        hiddenNodeGroups.attr('transform', d => {\n          // Maker sure the nodes are inside the box\n          const coord = borderConstraint(d);\n          return `translate(${coord.left}, ${coord.top})`;\n        });\n      }\n\n      // Update the text links\n      if (config.showHiddenLink) {\n        textLinkLines\n          .attr('x1', d => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', d => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', d => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', d => borderConstraint(d.target, nodeRadiusScale).top);\n\n        textHiddenLinkLines\n          .attr('x1', d => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', d => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', d => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', d => borderConstraint(d.target, nodeRadiusScale).top);\n      }\n\n    });\n\n    // Register UI elements from the control panel\n    bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    bindSlider('manyBody', simulation, -2000, 0, initManyBodyStrength);\n    bindSlider('collide', simulation, 0, 20, initCollideRadius, nodeRadiusScale);\n\n    bindCheckBox(simulation, links);\n\n    bindSelect();\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style type=\"text/scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}</style>\n\n<div class='graph-view'>\n  <div class='control-panel'>\n    <!-- Sliders -->\n    <div class='slider'>\n      <label for='attention'>Attention Strength\n        [{config.autoAttention ? 'auto' : round(forceStrength.attention, 2)}]\n      </label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"attention\">\n    </div>\n\n    <div class='slider'>\n      <label for='textOrder'>Text Order Strength [{round(forceStrength.textOrder, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"textOrder\">\n    </div>\n\n    <div class='slider'>\n      <label for='manyBody'>ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"manyBody\">\n    </div>\n\n    <div class='slider'>\n      <label for='collide'>Node Distance [{round(forceStrength.collide, 2)}]</label>\n      <input type=\"range\" min=\"0\" max=\"1000\" value=\"500\" class=\"slider\" id=\"collide\">\n    </div>\n\n    <!-- Checkboxes -->\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\">\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\">\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\">\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class='checkbox'>\n      <input type=\"checkbox\" id=\"checkbox-border\">\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n    \n    <!-- Selection -->\n    <div class='select'>\n      <select name='layout' id='select-layout'>\n        <option value='force'>Force Layout</option>\n        <option value='radial'>Radial Layout</option>\n      </select>\n    </div>\n    \n  </div>\n\n  <div class='svg-container'>\n    <svg class='graph-svg' bind:this={graphSVG}></svg>\n  </div>\n  \n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import Tooltip from './Tooltip.svelte';\n  import TextClassificationStats from './TextClassificationStats.svelte';\n  import SmallMatrix from './SmallMatrix.svelte';\n  import GraphView from './GraphView.svelte';\n  import * as d3 from 'd3';\n  \n  export let width = 400;\n\n  let saliencyDiv = null;\n  let saliencySVG = null;\n  let rightSVG = null;\n  let saliencyComponent = null;\n  let saliencyRow = null;\n  let tooltip = null;\n\n  let tooltipLeft = 0;\n  let tooltipTop = 0;\n  let tooltipHtml = 'tooltip';\n  let tooltipWidth = 65;\n  let tooltipShow = false;\n  \n  let svgWidth = 950;\n  let svgHeight = 600;\n\n  let heatmapMode = false;\n\n  const rightSVGWidth = 100;\n  const legendPos = {\n    width: 20,\n    height: 300,\n    top: 5,\n    left: 30\n  };\n\n  let saliencySVGPadding = {\n    top: 10,\n    left: 10,\n    right: 10,\n    bottom: 20\n  };\n\n  const tokenPadding = {\n    left: 3,\n    right: 2,\n    top: 4,\n    bottom: 0\n  };\n\n  // HTML input\n  let saliencyKey = 'negative'\n  let saliencies = null;\n  let filename = 'saliency_list.json';\n\n  const newJSONUploaded = (evt) => {\n    // Load the file\n    let files = evt.target.files;\n    let file = files[0];\n    filename = file.name;\n\n    // Read the file\n    let reader = new FileReader();\n    reader.onload = async (evt) => {\n      // Renew the data and frame count\n      saliencies = await d3.json(evt.target.result);\n    }\n    reader.readAsDataURL(file);\n  }\n\n  const submitClicked = (evt) => {\n    // Remove the preivious views\n    d3.select(saliencyDiv)\n      .selectAll('.token')\n      .remove();\n\n    d3.select(saliencyRow)\n      .select('svg')\n      .remove();\n\n    drawSaliencies(saliencies, saliencyKey);\n  }\n  \n  const drawSaliencyLegend = (saliencyRow, largestAbs) => {\n    // Add a svg element\n    let rightSVGHeight = +d3.select(saliencySVG).attr('height');\n    rightSVG = d3.select(saliencyRow)\n      .append('svg')\n      .attr('class', 'right-svg')\n      .attr('height', rightSVGHeight)\n      .attr('width', rightSVGWidth);\n    \n    // Define the gradient\n    let legentGradientDef = rightSVG.append('defs')\n      .append('linearGradient')\n      .attr('x1', 0)\n      .attr('y1', 1)\n      .attr('x2', 0)\n      .attr('y2', 0)\n      .attr('id', 'legend-gradient');\n    \n    legentGradientDef.append('stop')\n      .attr('stop-color', '#eb2f06')\n      .attr('offset', 0);\n\n    legentGradientDef.append('stop')\n      .attr('stop-color', '#ffffff')\n      .attr('offset', 0.5);\n    \n    legentGradientDef.append('stop')\n      .attr('stop-color', '#4690C2')\n      .attr('offset', 1);\n    \n    // Draw the legend\n    let legendGroup = rightSVG.append('g')\n      .attr('class', 'legend')\n      .attr('transform', `translate(${legendPos.left}, ${legendPos.top})`)\n\n    legendGroup.append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', legendPos.width)\n      .attr('height', legendPos.height)\n      .style('fill', 'url(#legend-gradient)')\n      .style('stroke', 'black');\n    \n    // Draw the legend axis\n    let legendScale = d3.scaleLinear()\n      .domain([-largestAbs, largestAbs])\n      .range([legendPos.height, 0])\n      .nice();\n    \n    legendGroup.append(\"g\")\n      .attr('transform', `translate(${legendPos.width}, ${0})`)\n      .call(d3.axisRight(legendScale).ticks(10))\n  }\n\n  const enterHeatmap = () => {\n    const buttonAnimationTime = 1000;\n    const buttonAnimationEase = d3.easeCubicInOut;\n    let tokens = d3.select(saliencySVG)\n      .select('.text-group')\n      .selectAll('.token');\n    \n    // Hide the texts\n    tokens.select('.text-token')\n      .transition('text-opacity')\n      .duration(buttonAnimationTime / 2)\n      .ease(buttonAnimationEase)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        d3.select(g[i]).style('visibility', 'hidden');\n      });\n\n    let tileHeight = +tokens.select('.text-background').attr('height');\n    let containerWidth = svgWidth - saliencySVGPadding.left - saliencySVGPadding.right;\n    let tileGap = 3;\n    let tileColumnNum = Math.floor(containerWidth / (tileHeight + tileGap));\n    let tileNumRow = Math.floor(tokens.nodes().length / tileColumnNum) + 1;\n\n    // To center the heatmap, we need to re-calculate the starting gap\n    let startSpace = (containerWidth - tileColumnNum * (tileHeight + tileGap) + tileGap) / 2;\n\n    // Move the rect positions and change their width\n    tokens.transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('transform', (_, i) => {\n      // Compute the current tile's location\n      let cur_r = Math.floor(i / tileColumnNum);\n      let cur_c = i % tileColumnNum;\n      return `translate(${startSpace + cur_c * (tileHeight + tileGap)},\n        ${cur_r * (tileHeight + tileGap)})`;\n    })\n\n    tokens.select('.text-background')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('width', function(){return +d3.select(this).attr('height')});\n\n    // Change the SVG height\n    let tempSVGHeight = saliencySVGPadding.top + saliencySVGPadding.bottom / 2 +\n        tileNumRow * (tileHeight + tileGap) - tileGap;\n    \n    d3.select(saliencySVG)\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n    \n    d3.select(saliencySVG)\n      .select('.svg-border-rect')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n    \n    rightSVG.transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n  }\n\n\n  const exitHeatmap = (textTokenPositions, textTokenWidths) => {\n    const buttonAnimationTime = 1000;\n    const buttonAnimationEase = d3.easeCubicInOut;\n    let tokens = d3.select(saliencySVG)\n      .select('.text-group')\n      .selectAll('.token');\n    \n    // Show the texts\n    tokens.select('.text-token')\n      .style('visibility', 'visible');\n\n    // Restore the position of the text token\n    tokens.transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('transform', (_, i) => {\n        let curPos = textTokenPositions[i];\n        return `translate(${curPos.x}, ${curPos.y})`\n      });\n\n    // Restore text token rect width\n    tokens.select('.text-background')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('width', (_, i) => textTokenWidths[i] + tokenPadding.left + tokenPadding.right);\n\n    // Change the SVG height\n    d3.select(saliencySVG)\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n    \n    d3.select(saliencySVG)\n      .select('.svg-border-rect')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n    \n    rightSVG.transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n    \n    // Show the texts\n    tokens.select('.text-token')\n      .transition('text-animation')\n      .delay(buttonAnimationTime / 2)\n      .duration(buttonAnimationTime / 2)\n      .ease(buttonAnimationEase)\n      .style('opacity', 1);\n  }\n\n\n  const drawSaliencyControl = (textTokenPositions, textTokenWidths) => {\n    if (rightSVG === null) {\n      return;\n    }\n\n    let rectY = legendPos.top + legendPos.height + 10;\n    let heatmapButton = rightSVG.append('rect')\n      .attr('x', legendPos.left)\n      .attr('y', rectY)\n      .attr('class', 'rect-button')\n      .attr('width', 30)\n      .attr('height', 30)\n      .attr('rx', 5)\n      .style('fill', '#F5F5F5')\n      .style('stroke-width', 1)\n      .style('stroke', '#DBDBDB');\n    \n    heatmapButton.on('mouseover', (event, d) => {\n      let node = event.currentTarget;\n      let button = d3.select(node);\n      button.style('stroke', 'black');\n    });\n\n    heatmapButton.on('mouseleave', (event, d) => {\n      let node = event.currentTarget;\n      let button = d3.select(node);\n      button.style('stroke', '#DBDBDB');\n    });\n\n    heatmapButton.on('click', () => {\n      if (!heatmapMode) {\n        enterHeatmap();\n        heatmapMode = true;\n      } else {\n        exitHeatmap(textTokenPositions, textTokenWidths);\n        heatmapMode = false;\n      }\n    })\n\n  }\n\n  const drawSaliencies = (saliencies, key) => {\n    if (saliencySVG === null) {\n      return;\n    }\n\n    let saliencyTokens = saliencies.tokens;\n    // console.log(saliencyTokens);\n\n    // Create a divering color scale from red to green\n    let largestAbs = d3.max(saliencyTokens.map(d => Math.abs(d[key])));\n    const tokenGap = 4;\n    const rowGap = 30;\n\n    let colorScale = d3.scaleLinear()\n      .domain([-largestAbs, 0, largestAbs])\n      .range([d3.rgb('#eb2f06'), d3.rgb('#ffffff'), d3.rgb('#458FC1')]);\n    \n    let container = d3.select(saliencySVG)\n      .attr('height', svgHeight)\n      .attr('width', svgWidth)\n      .append('g')\n      .attr('class', 'main-svg')\n      .attr('transform', `translate(${saliencySVGPadding.left}, ${saliencySVGPadding.top})`);\n    \n    // Add svg border rect\n    d3.select(saliencySVG)\n      .append('rect')\n      .attr('class', 'svg-border-rect')\n      .attr('height', svgHeight)\n      .attr('width', svgWidth)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n    \n    // Add svg control buttons\n    \n    let containerWidth = svgWidth - saliencySVGPadding.left - saliencySVGPadding.right;\n    \n    let textGroup = container.append('g')\n      .attr('class', 'text-group');\n\n    let tokenGroups = textGroup.selectAll('g.token')\n      .data(saliencyTokens)\n      .enter()\n      .append('g')\n      .attr('class', 'token')\n      .attr('id', (_, i) => `token-${i}`);\n\n    let tokenTexts = tokenGroups.append('text')\n      .attr('class', 'text-token')\n      .attr('x', tokenPadding.left)\n      .attr('y', tokenPadding.top)\n      .text(d => d.token);\n    \n    // After the text elements are created, we need to query again to get the\n    // length and width of these elements\n    let textTokenWidths = {};\n    let textTokenPositions = {};\n    let textTokenHeight = null;\n\n    tokenTexts.each(function(_, i) {\n      let bbox = this.getBBox();\n      textTokenWidths[i] = +Number(bbox.width).toFixed(2);\n\n      if (textTokenHeight == null) {\n        textTokenHeight = bbox.height;\n      }\n    });\n\n    let tokenRects = tokenGroups.append('rect')\n      .attr('class', 'text-background')\n      .attr('width', (_, i) => textTokenWidths[i] + tokenPadding.left + tokenPadding.right)\n      .attr('height', textTokenHeight + tokenPadding.top + tokenPadding.bottom)\n      .style('fill', d => colorScale(+d[key]))\n      .lower();\n\n    // Change the positions of tokens based on their width\n    let curPos = {x: 0, y: 0};\n    let tokenNum = Object.keys(textTokenWidths).length;\n\n    // Change the position of the text token\n    tokenGroups.each(function(_, i) {\n      d3.select(this)\n        .attr('transform', `translate(${curPos.x}, ${curPos.y})`);\n      \n      // Record the new position\n      textTokenPositions[i] = {x: curPos.x, y: curPos.y};\n\n      // Update the next position\n      let curLineLength = curPos.x + textTokenWidths[i] + tokenPadding.left +\n                          tokenPadding.right + tokenGap;\n      if (i + 1 < tokenNum) {\n        curLineLength += textTokenWidths[i + 1];\n      }\n\n      // Shift to next row if needed\n      if (curLineLength > containerWidth) {\n        curPos.y += rowGap;  \n        curPos.x = 0;\n      } else {\n        curPos.x = curPos.x + textTokenWidths[i] + tokenPadding.left + tokenPadding.right + tokenGap;\n      }\n    });\n\n    // Resize the SVG based on the content height\n    svgHeight = (curPos.y + textTokenHeight + tokenPadding.top +\n                 tokenPadding.bottom + saliencySVGPadding.bottom);\n    d3.select(saliencySVG)\n      .attr('height', svgHeight)\n      .select('.svg-border-rect')\n      .attr('height', svgHeight);\n    \n    // Mouseover function\n    tokenGroups.on('mouseover', (event, d) => {\n      let node = event.currentTarget;\n      let curGroup = d3.select(node);\n      let curI = d3.select(node.parentNode).nodes().indexOf(event.currentTarget);\n\n      // Highlight the border\n      curGroup.select('.text-background')\n        .style('stroke', 'rgba(0, 0, 0, 1)')\n\n      // Show the tooltip\n      tooltipShow = true;\n      let position = node.getBoundingClientRect();\n\n      let curWidth = position.right - position.left;\n      let tooltipCenterX = position.x + curWidth / 2;\n      let tooltipCenterY = position.y - 40 + window.scrollY;\n\n      tooltipHtml = d3.format('.4f')(+d[key]);\n      tooltipLeft = tooltipCenterX - tooltipWidth / 2;\n      tooltipTop = tooltipCenterY;\n    })\n\n    // Mouseleave function\n    tokenGroups.on('mouseleave', (event, d) => {\n      let node = event.currentTarget;\n      let curGroup = d3.select(node);\n      let curI = d3.select(node.parentNode).nodes().indexOf(event.currentTarget);\n\n      // Dehighlight the border\n      curGroup.select('.text-background')\n        .style('stroke', 'none');\n      \n      // Hide the tooltip\n      tooltipShow = false;\n    });\n\n    drawSaliencyLegend(saliencyRow, largestAbs);\n    drawSaliencyControl(textTokenPositions, textTokenWidths);\n  }\n\n  onMount(async () => {\n    console.log('loading');\n    saliencies = await d3.json('PUBLIC_URL/data/saliency_list.json');\n    console.log('loaded');\n\n    drawSaliencies(saliencies, saliencyKey);\n  })\n\n</script>\n\n<style type=\"text/scss\">.saliency-component {\n  display: flex;\n  flex-direction: column;\n}\n\n.saliency-row {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n}\n\n:global(.saliency-svg .token) {\n  cursor: pointer;\n}\n\n:global(.saliency-svg .text-token) {\n  font-size: 1em;\n  dominant-baseline: hanging;\n}\n\n:global(.saliency-svg .text-background) {\n  shape-rendering: crispEdges;\n  stroke-width: 1px;\n}\n\n:global(.right-svg .rect-button) {\n  cursor: pointer;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: row-reverse;\n  margin: 10px 0;\n  padding: 0 100px 0 0;\n}\n.control-panel .input {\n  margin: 0 10px;\n  width: 120px;\n}\n\n.large {\n  font-size: 1em;\n  padding-left: 1em;\n  padding-right: 1em;\n  padding-top: 1.2em;\n  padding-bottom: 1.2em;\n  margin-right: 10px;\n}</style>\n\n<div class='saliency-component' bind:this={saliencyComponent}>\n  <Tooltip bind:this={tooltip}\n    left={tooltipLeft}\n    top={tooltipTop}\n    tooltipHtml={tooltipHtml}\n    width={tooltipWidth}\n    tooltipShow={tooltipShow}\n  />\n\n  <GraphView />\n  <SmallMatrix />\n\n  <div class='saliency-row' bind:this={saliencyRow}>\n    <svg class='saliency-svg' bind:this={saliencySVG}></svg>\n  </div>\n\n\n  <div class='control-panel'>\n    <button class=\"button\" on:click={submitClicked}>Submit</button>\n\n    <input class=\"input\" type=\"text\" placeholder=\"Saliency Key\"\n      bind:value={saliencyKey}>\n\n    <div class=\"file is-normal-small\">\n      <label class=\"file-label\">\n        <input class=\"file-input is-normal-small\" type=\"file\" name=\"json\"\n          accept='.json'\n          on:change={newJSONUploaded}>\n        <span class=\"file-cta is-normal-small no-top-border-radius\">\n          <span class=\"file-icon\">\n            <i class=\"fas fa-upload\"></i>\n          </span>\n          <span class=\"file-label\">\n            JSON\n          </span>\n        </span>\n      </label>\n    </div>\n\n    {#if filename !== null}\n      <div class=\"tag is-light is-large large\">\n        {filename}\n      </div>\n    {/if}\n    {#if saliencies != null}\n      <TextClassificationStats\n        trueLabel={saliencies.meta['true_label']}\n        predictedLabel={saliencies.meta['predicted_label']}\n        softmaxScores={saliencies.meta['softmax_scores']}/>\n    {/if}\n  </div>\n  \n</div>",
    "<script>\n  import { onMount, createEventDispatcher } from 'svelte';\n  import { tableModalStore, instanceIDStore, currInstanceStore } from './store';\n  import EmbeddingView from './EmbeddingView.svelte';\n  import TableView from './TableView.svelte';\n\n  let modalComponent;\n\n  const dispatch = createEventDispatcher();\n  let modalInfo = {\n    show: false\n  };\n  let tempID = null;\n  currInstanceStore.subscribe(value => {tempID = value;});\n\n  tableModalStore.set(modalInfo);\n  tableModalStore.subscribe(value => {modalInfo = value});\n\n  const crossClicked = () => {\n    modalInfo.show = false;\n    tableModalStore.set(modalInfo);\n    // Dispatch the parent component\n    dispatch('xClicked', {preImage: modalInfo.preImage});\n  };\n\n  const okClicked = () => {\n    modalInfo.show = false;\n    instanceIDStore.set(tempID);\n    // Dispatch the parent component\n    dispatch('xClicked', {preImage: modalInfo.preImage});\n  };\n\n  onMount(() => {\n\n  });\n</script>\n\n<style>\n\n  .modal-container {\n    margin: 0 auto;\n    display: flex;\n    flex-direction: row-reverse;\n    align-items: center;\n  }\n\n  .modal-card {\n    width: '';\n    max-width: 700px;\n    max-height: 600px;\n    position: relative;\n  }\n\n  .modal-card-title {\n    font-size: 20px;\n  }\n\n  .modal-card-head {\n    padding: 15px 20px;\n  }\n\n  .modal-card-body {\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-start;\n    align-items: flex-start;\n    padding: 0;\n  }\n\n  .modal-card-foot {\n    padding: 12px 20px;\n    justify-content: space-between;\n  }\n\n  .is-smaller {\n    font-size: 15px;\n    padding: 0.5em 0.8em;\n    max-height: 2.2em;\n  }\n\n  .embedding-div {\n    width: 350px;\n    height: 351px;\n    /* margin-top: 50px; */\n    margin-right: 20px;\n    z-index: 1;\n    background: white;\n    border-top-right-radius: 6px;\n    border-bottom-right-radius: 6px;\n    border-radius: 6px;\n  }\n\n  .center {\n    text-align: center;\n  }\n\n</style>\n\n\n<div class=\"modal-component\"\n  bind:this={modalComponent}>\n\n  <div class=\"modal\"\n    id=\"input-modal\"\n    class:is-active={modalInfo.show}>\n\n    <div class=\"modal-background\" on:click={crossClicked}></div>\n\n    <div class='modal-container'>\n\n      <div class=\"modal-card\">\n        <header class=\"modal-card-head\">\n          <p class=\"modal-card-title\">Select Input Sentence</p>\n          <button class=\"delete\" aria-label=\"close\" on:click={crossClicked}></button>\n        </header>\n\n        <section class=\"modal-card-body\">\n          \n          <TableView />\n\n        </section>\n\n        <footer class=\"modal-card-foot\">\n\n          <div class=\"button-container\">\n            <button class=\"button is-smaller\"\n              on:click={crossClicked}>\n              Cancel\n            </button>\n\n            <button class=\"button is-success is-smaller\"\n              on:click={okClicked}>\n              Add\n            </button>\n          </div>\n\n        </footer>\n\n      </div>\n\n      <div class='embedding-div'>\n        <header class=\"modal-card-head\">\n          <p class=\"modal-card-title center\">Instance Embedding</p>\n        </header>\n\n        <EmbeddingView />\n      </div>\n\n    </div>\n\n  </div>\n\n</div>",
    "<script>\n  import { onMount, afterUpdate } from 'svelte';\n  import { tableViewConfigStore, currInstanceStore } from './store';\n  import * as d3 from 'd3';\n  \n  // Shared states\n  let tableViewConfig = undefined;\n\n  let tableData = [];\n  let selectedInstanceId = 23;\n  let currHighlightedRow = 0;\n  let mostRecentColumnSortCriterion = 'true_label';\n  let isEmbeddingViewUpdate = false;\n\n  let sortState = {\n    sentence: {\n      selected: false,\n      up: false\n    },\n    'true_label': {\n      selected: false,\n      up: false\n    },\n    'predicted_label': {\n      selected: false,\n      up: false\n    },\n    'logit_distance': {\n      selected: false,\n      up: false\n    }\n  };\n\n  let selectedRowColor = 'hsla(0, 0%, 0%, 0.1)';\n\n  let sortBy = {col: 'id', ascending: true};\n\n  $: selectedInstanceId, function(){\n    if (document.getElementsByTagName('table')[0]\n      && document.getElementsByTagName('table')[0]\n        .children[1].children[currHighlightedRow]) {\n      // We sort by most recent column so that placing\n      // the selected instance at the top of the table does\n      // not affect the previous sorting. Reactive for\n      // when the instanceId store value changes from\n      // another source (ie. EmbeddingView).\n      if (isEmbeddingViewUpdate) {\n        // console.log(mostRecentColumnSortCriterion);\n        sort(mostRecentColumnSortCriterion);\n      }\n    }\n    isEmbeddingViewUpdate = true;\n  }();\n  \n  $: sort = (column) => {\n    mostRecentColumnSortCriterion = column;\n    \n    if (sortBy.col == column) {\n      sortBy.ascending = !sortBy.ascending;\n      sortState[column].up = sortBy.ascending;\n      sortState = sortState;\n    } else {\n      if (sortState[sortBy.col] !== undefined) {\n        sortState[sortBy.col].selected = false;\n      }\n      \n      sortBy.col = column;\n      sortBy.ascending = true;\n      sortState[column].selected = true;\n      sortState[column].up = true;\n      sortState = sortState;\n    }\n    \n    let sortModifier = (sortBy.ascending) ? 1 : -1;\n    \n    let sort = (a, b) => \n      (a[column] < b[column]) \n        ? -1 * sortModifier \n        : (a[column] > b[column]) \n          ? 1 * sortModifier \n          : 0;\n    \n    tableData = tableData.sort(sort);\n\n    // If we have an active instance, move it to the begining of the\n    // table regardless of the sort.\n    tableData.forEach(function(item, i){\n      if(item.id == selectedInstanceId){\n        tableData.splice(i, 1);\n        tableData.unshift(item);\n      }\n    });\n    // Update background row color.\n    // Remove style from previously selected row.\n    document.getElementsByTagName('table')[0].children[1]\n      .children[currHighlightedRow].style = 'background-color: inherit;';\n\n    // Add style to top row, since sorting\n    // by column moves selected row to the top.\n    document.getElementsByTagName('table')[0].children[1]\n      .children[0].style = 'background-color: ' + selectedRowColor;\n    currHighlightedRow = 0;\n    isEmbeddingViewUpdate = false;\n  };\n\n  $: getInstance = (row) => {\n    currInstanceStore.set(row.cells[0].innerText);\n    isEmbeddingViewUpdate = false;\n    // console.log('selected row id: ' + row.cells[0].innerText);\n    // Remove style from previously selected row.\n    document.getElementsByTagName('table')[0].children[1]\n      .children[currHighlightedRow].style = 'background-color: inherit;';\n\n    // Style newly selected row.\n    row.style = 'background-color: ' + selectedRowColor;\n    currHighlightedRow = row.rowIndex - 1;\n  };\n\n  tableViewConfigStore.subscribe(value => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined){\n      if (tableViewConfig === undefined\n        || (tableViewConfig.compHeight !== value.compHeight\n        && tableViewConfig.compWidth !== value.compWidth)){\n        tableViewConfig = value;\n      }\n    }\n  });\n\n  currInstanceStore.subscribe(value => {\n    selectedInstanceId = value;\n  });\n\n  onMount(async () => {\n    // console.log('loading table');\n    tableData = await d3.json('PUBLIC_URL/data/table-list-sst2.json');\n    // console.log('loaded table');\n  });\n  \n</script>\n\n<style type='text/scss'>table, th, td {\n  font-size: 0.9em;\n}\n\ntable {\n  width: 100%;\n  table-layout: auto;\n  text-align: center;\n  border-collapse: collapse;\n}\n\ntd {\n  padding: 0 20px 10px 20px;\n}\n\nth {\n  padding: 10px 10px;\n  position: sticky;\n  z-index: 100;\n  top: 0;\n  background: #fafafa;\n  background-clip: padding-box;\n  border-bottom: 1px solid #c7c7c7;\n}\nth.sentence {\n  width: 61%;\n  padding: 10px 20px;\n}\nth.true {\n  width: 11%;\n  padding: 10px 15px;\n}\nth.predicted {\n  width: 15%;\n  padding: 10px 15px;\n}\nth.error {\n  width: 13%;\n  padding: 10px 15px;\n}\n\n.sentence-div {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  cursor: pointer;\n}\n.sentence-div:hover img {\n  opacity: 0.5;\n}\n.sentence-div img {\n  margin-left: 3px;\n  width: 20px;\n  opacity: 0.1;\n}\n.sentence-div img.selected {\n  opacity: 1;\n}\n\n.true-div, .predicted-div, .error-div {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n  cursor: pointer;\n}\n.true-div:hover img, .predicted-div:hover img, .error-div:hover img {\n  opacity: 0.5;\n}\n.true-div img, .predicted-div img, .error-div img {\n  margin-left: 3px;\n  width: 20px;\n  opacity: 0.1;\n}\n.true-div img.selected, .predicted-div img.selected, .error-div img.selected {\n  opacity: 1;\n}\n\ntr:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n  cursor: default;\n}\n\ntr:first-child {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\ntd.number-row {\n  text-align: right;\n}\n\ntd.text-row {\n  text-align: left;\n}</style>\n\n<div class='table-view'>\n  <table>\n    <thead>\n      <tr>\n        <th style='display: none;' on:click={sort('id')}>id</th>\n        <th class='sentence' on:click={sort('sentence')}>\n          <div class='sentence-div'>\n            Sentence\n            <img src={sortState.sentence.up ? 'PUBLIC_URL/figures/up.svg' : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState.sentence.selected}\n              alt='sort logo'\n            >\n          </div>\n        </th>\n\n        <th class='true' on:click={sort('true_label')}>\n          <div class='true-div'>\n            True\n            <img src={sortState['true_label'].up ? 'PUBLIC_URL/figures/up.svg' : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['true_label'].selected}\n              alt='sort logo'\n            >\n          </div>\n        </th>\n\n        <th class='predicted' on:click={sort('predicted_label')}>\n          <div class='predicted-div'>\n            Predicted\n            <img src={sortState['predicted_label'].up ? 'PUBLIC_URL/figures/up.svg' : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['predicted_label'].selected}\n              alt='sort logo'\n            >\n          </div>\n        </th>\n\n        <th class='error' on:click={sort('logit_distance')}>\n          <div class='error-div'>\n            Error\n            <img src={sortState['logit_distance'].up ? 'PUBLIC_URL/figures/up.svg' : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['logit_distance'].selected}\n              alt='sort logo'\n            >\n          </div>\n        </th>\n\n      </tr>\n    </thead>\n    <tbody>\n      {#each tableData as row}\n        <tr on:click={getInstance(this)}>\n          <td style='display: none;'>{row.id}</td>\n          <td class='text-row'>{row.sentence}</td>\n          <td class='number-row'>{row.true_label}</td>\n          <td class='number-row'>{row.predicted_label}</td>\n          <td class='number-row'>{Number((row.logit_distance).toFixed(2))}</td>\n        </tr>\n      {/each}\n    </tbody>\n  </table>\n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  \n  export let trueLabel;\n  export let predictedLabel;\n  // Dictionary of {label : score}\n  export let softmaxScores;\n  $: {\n    d3.select(chart)\n      .selectAll('*')\n      .remove();\n    drawSoftmaxChart(); \n  }\n\n  let chart;\n  let softmaxScoreDicts;\n  let trueLabelTagStyle\n    $: {\n      switch(trueLabel) {\n        case \"positive\":\n          trueLabelTagStyle = \"tag is-rounded is-success\"\n          break;\n        case \"negative\":\n          trueLabelTagStyle = \"tag is-rounded is-danger\"\n          break;\n        default:\n          trueLabelTagStyle = \"tag is-rounded is-light\"\n      }\n    };\n  let predictedLabelTagStyle\n    $: {\n      switch(predictedLabel) {\n        case \"positive\":\n          predictedLabelTagStyle = \"tag is-rounded is-success\"\n          break;\n        case \"negative\":\n          predictedLabelTagStyle = \"tag is-rounded is-danger\"\n          break;\n        default:\n          predictedLabelTagStyle = \"tag is-rounded is-light\"\n      }\n    };\n\n  function preprocessSoftmaxScores() {\n    let softmaxScoreDicts = [];\n    let labels = Object.keys(softmaxScores);\n    labels.forEach(function(label) {\n      let softmaxScoreEntry = {}\n      softmaxScoreEntry['label'] = label;\n      softmaxScoreEntry['score'] = softmaxScores[label];\n      softmaxScoreDicts.push(softmaxScoreEntry);\n    })\n    return softmaxScoreDicts;\n  }\n\n  const drawSoftmaxChart = () => {\n    softmaxScoreDicts = preprocessSoftmaxScores();\n\n    let margin = {top: 10, right: 10, bottom: 30, left: 40};\n    let svgWidth = 180, svgHeight = 110;\n    let height = svgHeight- margin.top- margin.bottom, width = svgWidth - margin.left - margin.right;\n\n    let x = d3.scaleBand().rangeRound([0, width]).padding(0.1),\n        y = d3.scaleLinear().rangeRound([height, 0]);\n\n    x.domain(softmaxScoreDicts.map(function(d) { return d.label; }));\n    y.domain([0, d3.max(softmaxScoreDicts, function(d) { return d.score; })]);\n\n    let svg = d3.select(chart).append(\"svg\");\n    svg.attr('height', svgHeight)\n        .attr('width', svgWidth);\n\n    svg = svg.append(\"g\")\n             .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    svg.append(\"g\")\n        .attr(\"class\", \"axis axis--x\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(d3.axisBottom(x));\n\n    svg.append(\"g\")\n        .attr(\"class\", \"axis axis--y\")\n        .call(d3.axisLeft(y).ticks(5));\n            \n    let bars = svg.selectAll('.bar')\n        .data(softmaxScoreDicts)\n        .enter()\n        .append(\"g\");\n\n    bars.append('rect')\n        .attr('class', 'bar')\n        .attr(\"x\", function(d) { return x(d.label); })\n        .attr(\"y\", function(d) { return y(d.score); })\n        .attr(\"width\", x.bandwidth())\n        .attr(\"height\", function(d) { return height - y(d.score); })\n        .attr(\"fill\", \"#DCDCDC\");\n  }\n\n  onMount(async () => {\n    drawSoftmaxChart();\n  })\n</script>\n\n<style>\n  .text-classification-stats {\n    display: flex;\n    flex-basis: 0;\n    flex-grow: 1;\n    flex-shrink: 1;\n  }\n\n  .stats-1 {\n    flex: 70%;\n  }\n  .stats-2 {\n    flex: 30%;\n    text-align: center;\n  }\n\n  .stats-1 span {\n    font-size: 0.75em;\n    font-weight: bold;\n  }\n  .stats-2 span {\n    font-size: 0.75em;\n    font-weight: bold;\n  }\n\n  .tag {\n    vertical-align: middle;\n  }\n</style>\n\n<div class='text-classification-stats'>\n  <div class=\"stats-1\">\n    <span>\n      Predicted Label:\n      <span id=\"predictedLabel\" class={predictedLabelTagStyle}>{predictedLabel}</span>&nbsp;\n      True Label:\n      <span id=\"trueLabel\" class={trueLabelTagStyle}>{trueLabel}</span>\n    </span>\n  </div>\n\n  <div class=\"stats-2\">\n    <span class=\"has-text-centered\">\n      Softmax Scores\n    </span>\n    <div bind:this={chart}></div>\n  </div>\n</div>",
    "<script>\n  import * as d3 from 'd3';\n\n  export let tooltipShow = false;\n  export let tooltipHtml = \"1.23\";\n  export let left = 0;\n  export let top = 0;\n  export let width = 80;\n  export let maxWidth = 80;\n  export let fontSize = '1em';\n\n  let tooltip = null;\n\n  $: style = `left: ${left}px; top: ${top}px; width: ${width}px; max-width: \n              ${maxWidth}px; font-size: ${fontSize}`;\n  $: tooltipShow, function() {\n    if (tooltip === null) return;\n    let selection = d3.select(tooltip);\n\n    if (tooltipShow) {\n      selection.style('visibility', 'visible');\n\n      d3.select(tooltip)\n        .transition()\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 1);\n    } else {\n      d3.select(tooltip)\n        .transition()\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 0)\n        .on('end', function() {\n          d3.select(this)\n            .style('visibility', 'hidden');\n        });\n    }\n  }();\n\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    color: white;\n    background-color: black;\n    padding: 5px 5px;\n    border-radius: 5px;\n    opacity: 1;\n    z-index: 10;\n    visibility: visible;\n    transition: opacity 150ms, visibility 150ms;\n    display: flex;\n    justify-content: center;\n    box-sizing: border-box;\n  }\n</style>\n\n<div class=\"tooltip\" style={style} bind:this={tooltip}>\n  {@html tooltipHtml}\n</div>",
    "<script>\n  import * as d3 from 'd3';\n  import { onMount } from 'svelte';\n  import { tooltipConfigStore } from './store';\n\n  let tooltipConfig = {\n    show: false,\n    html: 'null',\n    left: 0,\n    top: 0,\n    width: 80,\n    maxWidth: 80,\n    fontSize: '1em'\n  };\n\n  let tooltip = null;\n\n  $: style = `left: ${tooltipConfig.left}px; top: ${tooltipConfig.top}px;\n    width: ${tooltipConfig.width}px; max-width: ${tooltipConfig.maxWidth}px;\n    font-size: ${tooltipConfig.fontSize}`;\n\n  tooltipConfigStore.subscribe(value => {\n\n    let selection = d3.select(tooltip);\n    if (value.show) {\n      selection.style('visibility', 'visible');\n      d3.select(tooltip)\n        .transition()\n        .duration(100)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 1);\n    } else {\n      d3.select(tooltip)\n        .transition()\n        .delay(100)\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 0)\n        .on('end', function() {\n          d3.select(this)\n            .style('visibility', 'hidden');\n        });\n    }\n\n    tooltipConfig = value;\n  });\n\n  onMount(() => {\n    d3.select(tooltip).style('visibility', 'hidden');\n    tooltipConfigStore.set(tooltipConfig);\n  });\n\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    color: white;\n    background-color: black;\n    padding: 5px 5px;\n    border-radius: 5px;\n    opacity: 1;\n    z-index: 20;\n    visibility: visible;\n    transition: opacity 150ms, visibility 150ms;\n    display: flex;\n    justify-content: center;\n    box-sizing: border-box;\n  }\n</style>\n\n<div class=\"tooltip\" style={style} bind:this={tooltip}>\n  {@html tooltipConfig.html}\n</div>",
    "<script>\n  import { onMount } from 'svelte';\n  import { instanceViewConfigStore, hoverTokenStore,\n    wordToSubwordMapStore, tableModalStore, instanceIDStore, comparisonViewStore } from '../store';\n  import { isSpecialToken, padZeroLeft } from './utils';\n  import { drawParagraph } from './saliency-view';\n  import { drawGraph } from './dependency-view';\n  import RadialModal from './RadialModal.svelte';\n  import { drawDependencyComparison, removeDependencyComparison } from './comparison-view';\n  import { drawTree } from './tree-view';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  const dispatch = createEventDispatcher();\n\n  let svg = null;\n  let data = null;\n  let existingLinkSet = null;\n  let saliencies = null;\n  let attentions = null;\n  let headOrder = null;\n\n  let wordToSubwordMap = null;\n  let relations = [];\n  let selectedRelations = {};\n  let instanceID = 1562;\n\n  let textTokenWidths = {};\n  let tokenXs = [];\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n  let SVGInitialized = false;\n  let inComparisonView = false;\n  let comparisonViewConfig = {};\n\n  comparisonViewStore.subscribe(value => {\n    comparisonViewConfig = value;\n    SVGHeight = comparisonViewConfig.height - 41;\n\n    if (comparisonViewConfig.inComparison && !inComparisonView) {\n      comparisonButtonClickedHandler();\n    } else if (!comparisonViewConfig.inComparison && inComparisonView){\n      comparisonButtonClickedHandler();\n    }\n  });\n\n  // Table Modal info\n  let tableModalInfo = null;\n  tableModalStore.subscribe(value => {tableModalInfo = value;});\n\n  const SVGPadding = {top: 10, left: 15, right: 15, bottom: 10};\n  const textTokenPadding = {top: 3, left: 3, right: 3, bottom: 3};\n\n  // Global stores\n  let curHoverToken = null;\n  \n  // Control panel variables\n  const layoutOptions = {\n    saliency: {\n      value: 'saliency',\n      name: 'Saliency View'\n    },\n    dependency: {\n      value: 'dependency',\n      name: 'Dependency List'\n    },\n    tree: {\n      value: 'tree',\n      name: 'Dependency Tree'\n    } \n  };\n\n  const headListOptions = {\n    syntactic: {\n      value: 'syntactic',\n      name: 'syntactic correlations'\n    },\n    semantic: {\n      value: 'semantic',\n      name: 'semantic correlations '\n    },\n    importance: {\n      value: 'importance',\n      name: 'importance scores'\n    } \n  };\n\n  let dependencyViewInitialized = false;\n  let saliencyViewInitialized = false;\n  let treeViewInitialized = false;\n\n  let currentLayout = layoutOptions.dependency;\n  let linkColor = 'hsl(0, 0%, 80%)';\n  let linkHoverColor = 'hsl(42, 95%, 58%)';\n  linkHoverColor = 'hsl(36, 100%, 55%)';\n  // linkHoverColor = 'hsl(174, 65%, 48%)';\n\n  // let linkHoverGradient1 = 'hsl(173, 66%, 90%)';\n  // let linkHoverGradient2 = 'hsl(176, 74%, 70%)';\n  // let linkHoverGradient3 = 'hsl(173, 66%, 35%)';\n\n  let linkHoverGradient1 = 'hsl(36, 100%, 90%)';\n  let linkHoverGradient2 = 'hsl(36, 100%, 80%)';\n  let linkHoverGradient3 = 'hsl(36, 100%, 55%)';\n\n  let showRelationCheckboxes = false;\n\n  const ease = d3.easeCubicInOut;\n  const animationTime = 300;\n  \n  const bindSelect = () => {\n    let selectOption = d3.select('#instance-select')\n      .property('value', currentLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayoutValue = selectOption.property('value');\n\n      // Need to switch layout\n      if (newLayoutValue !== currentLayout.value) {\n\n        switch(newLayoutValue) {\n        case 'saliency':\n          // Hide the old view\n          if (currentLayout.value === 'dependency' && dependencyViewInitialized) {\n            svg.select('g.token-group')\n              .style('display', 'none');\n          }\n\n          if (currentLayout.value === 'tree' && treeViewInitialized) {\n            svg.select('g.tree-group')\n              .style('display', 'none');\n          }\n\n          // Draw the new view\n          if (saliencyViewInitialized) {\n            svg.select('g.token-group-saliency')\n              .style('display', null);\n            svg.select('g.legend-group')\n              .style('display', null);\n          } else {\n            if (!SVGInitialized) {\n              initSVG();\n            }\n            drawParagraph(saliencies, svg, SVGWidth, SVGPadding, textTokenPadding,\n              wordToSubwordMap, tokenNodeMouseover, tokenNodeMouseleave);\n            saliencyViewInitialized = true;\n          }\n          currentLayout = layoutOptions[newLayoutValue];\n          break;\n\n        case 'dependency':\n          console.log('change to dependency view');\n\n          // Hide the old view\n          if (currentLayout.value === 'tree' && treeViewInitialized) {\n            svg.select('g.tree-group')\n              .style('display', 'none');\n          }\n\n          if (currentLayout.value === 'saliency' && saliencyViewInitialized) {\n            svg.select('g.token-group-saliency')\n              .style('display', 'none');\n            svg.select('g.legend-group')\n              .style('display', 'none');\n          }\n\n          // Draw the new view\n          if (dependencyViewInitialized) {\n            svg.select('g.token-group')\n              .style('display', null);\n          } else {\n            if (!SVGInitialized) {\n              initSVG();\n            }\n            let results = drawGraph(data, saliencies, wordToSubwordMap, svg, tokenXs,\n              textTokenPadding, SVGPadding, SVGHeight, tokenNodeMouseover,\n              tokenNodeMouseleave,initWordToSubwordMap);\n\n            tokenXs = results.tokenXs;\n            textTokenWidths = results.textTokenWidths;\n            dependencyViewInitialized = true;\n          }\n\n          currentLayout = layoutOptions[newLayoutValue];\n          break;\n\n        case 'tree':\n          console.log('change to tree view');\n\n          // Hide the old view\n          if (currentLayout.value === 'dependency' && dependencyViewInitialized) {\n            svg.select('g.token-group')\n              .style('display', 'none');\n          }\n\n          if (currentLayout.value === 'saliency' && saliencyViewInitialized) {\n            svg.select('g.token-group-saliency')\n              .style('display', 'none');\n            svg.select('g.legend-group')\n              .style('display', 'none');\n          }\n\n          // Draw the new view\n          if (treeViewInitialized) {\n            svg.select('g.tree-group')\n              .style('display', null);\n          } else {\n            if (!SVGInitialized) {\n              initSVG();\n            }\n            drawTree(data, saliencies, svg, SVGWidth, SVGHeight, SVGPadding,\n              tokenNodeMouseoverTree, tokenNodeMouseleave, textTokenPadding,\n              wordToSubwordMap, initWordToSubwordMap);\n            treeViewInitialized = true;\n          }\n\n          currentLayout = layoutOptions[newLayoutValue];\n          break;\n        }\n\n      }\n    });\n  };\n\n  const initSVG = () => {\n    svg = d3.select('svg.dependency-svg')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg.append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Add arrow markers\n    let arrowMarker = svg.append('defs');\n\n    arrowMarker.append('marker')\n      .attr('id', 'dep-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 10)\n      .attr('markerHeight', 5)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkColor)\n      .attr('fill', linkColor);\n    \n    arrowMarker.clone(true)\n      .select('marker')\n      .attr('id', 'dep-arrow-hover')\n      .select('path')\n      .attr('stroke', linkHoverColor)\n      .attr('fill', linkHoverColor);\n\n    arrowMarker.clone(true)\n      .select('marker')\n      .attr('id', 'dep-attention-arc-arrow')\n      .select('path')\n      .attr('stroke', 'none')\n      .attr('refX', 2)\n      .attr('fill', 'hsl(0, 0%, 10%)');\n\n    arrowMarker.clone(true)\n      .select('marker')\n      .attr('id', 'dep-attention-arrow')\n      .select('path')\n      .attr('stroke', 'none')\n      .attr('refX', 2)\n      .attr('fill', 'hsl(0, 0%, 80%)');\n\n    // Create opacity gradient\n    let gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-opacity-gradient')\n      .attr('x2', '0%')\n      .attr('y2', '100%');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0.9');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0)\n      .style('stop-color', 'white')\n      .attr('offset', '1');\n\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'bottom-opacity-gradient')\n      .attr('x2', '0%')\n      .attr('y2', '100%');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0)\n      .style('stop-color', 'white')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0.5');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '1');\n\n    // Line gradient right to left\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'link-opacity-gradient-rl');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.6');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '1');\n\n    // Line gradient left to right\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'link-opacity-gradient-lr');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.4');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '1');\n    \n    // Matched line gradient right to left\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'matched-link-opacity-gradient-rl');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient1)\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient2)\n      .attr('offset', '0.6');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient3)\n      .attr('offset', '1');\n\n    // Matched line gradient left to right\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'matched-link-opacity-gradient-lr');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient3)\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient2)\n      .attr('offset', '0.4');\n\n    gradient.append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient1)\n      .attr('offset', '1');\n\n    // Top line gradient right to left\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-link-opacity-gradient-rl');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.3');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '1');\n\n    // Line gradient left to right\n    gradient = svg.append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-link-opacity-gradient-lr');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '0');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.7');\n\n    gradient.append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '1');\n\n    SVGInitialized = true;\n  };\n\n  const tokenNodeMouseover = e => {\n    let curNode = d3.select(e.target);\n    let nodeID = curNode.data()[0].id;\n    hoverTokenStore.set(nodeID);\n  };\n\n  const tokenNodeMouseleave = () => {\n    hoverTokenStore.set(null);\n  };\n\n  const tokenNodeMouseoverTree = (tokens, e) => {\n    let curNode = d3.select(e.target);\n    let nodeID = tokens[curNode.data()[0].id].id;\n    hoverTokenStore.set(nodeID);\n  };\n\n  const highLightNode = () => {\n    // Cannot directly select class because some weird special character selector bug on firefox\n    svg.selectAll('.node')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .select('rect')\n      .style('stroke', linkHoverColor)\n      .style('stroke-width', 2);\n    \n    svg.selectAll('.arc-path')\n      // TODO\n      // .style('opacity', 0.2);\n      .style('opacity', 0.8);\n\n    svg.selectAll('.arc-path')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', true)\n      .style('opacity', 1)\n      .raise();\n\n    svg.selectAll('.node-clone')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .select('rect')\n      .style('stroke', linkHoverColor)\n      .style('opacity', 1)\n      .style('stroke-width', 2);\n\n    svg.selectAll('.matched-attention-path')\n      .classed('de-highlighted', true);\n\n    svg.selectAll('.attention-path')\n      .style('opacity', 0.2);\n\n    svg.selectAll('.attention-path')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', true)\n      .style('opacity', 1)\n      .raise();\n\n    svg.selectAll('.attention-arc')\n      .style('opacity', 0.2);\n\n    svg.selectAll('.attention-arc')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', true)\n      .style('opacity', 0.9)\n      .raise();\n  };\n\n  const deHighLightNode = () => {\n\n    // TODO\n    // return;\n\n    svg.selectAll('.node')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .select('rect')\n      .style('stroke', 'hsl(180, 1%, 80%)')\n      .style('stroke-width', 1);\n\n    svg.selectAll('.arc-path')\n      .style('opacity', null);\n\n    svg.selectAll('.arc-path')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', false);\n\n    svg.selectAll('.node-clone')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .select('rect')\n      .style('opacity', null)\n      .style('stroke', 'none');\n\n    svg.selectAll('.matched-attention-path')\n      .classed('de-highlighted', false);\n\n    svg.selectAll('.attention-path')\n      .style('opacity', null);\n\n    svg.selectAll('.attention-path')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', false)\n      .raise();\n\n    svg.selectAll('.attention-arc')\n      .style('opacity', 0.5);\n\n    svg.selectAll('.attention-arc')\n      .filter((d, i, g) => d3.select(g[i]).attr('class').includes(`-${curHoverToken}`))\n      .classed('highlighted', false)\n      .raise();\n  };\n\n  const initWordToSubwordMap = (tokens, saliencies) => {\n\n    wordToSubwordMap = {};\n    let j = 0;\n    while (isSpecialToken(saliencies.tokens[j].token)) {\n      j += 1;\n    }\n\n    for (let i = 0; i < tokens.length; i++) {\n      if (j >= saliencies.tokens.length) break;\n\n      let curWord = tokens[i].token;\n      let curToken = saliencies.tokens[j].token;\n\n      if (curWord !== curToken) {\n        let nextWord = i + 1 < tokens.length ? tokens[i + 1].token : null;\n        wordToSubwordMap[curWord] = [];\n\n        while (saliencies.tokens[j].token !== nextWord) {\n          wordToSubwordMap[curWord].push(saliencies.tokens[j].id);\n          j += 1;\n\n          if (j >= saliencies.tokens.length) break;\n        }\n      } else {\n        j += 1;\n      }\n    }\n    \n    // Update the store\n    wordToSubwordMapStore.set(wordToSubwordMap);\n\n    return wordToSubwordMap;\n  };\n\n  const comparisonButtonClicked = () => {\n    // Dispatch to parent if user clicks the button instead of arrow\n    if (inComparisonView) {\n      dispatch('close');\n    } else {\n      dispatch('open');\n    }\n  };\n\n  const comparisonButtonClickedHandler = () => {\n\n    svg.attr('height', SVGHeight);\n\n    let topHeads = getInterestingHeads();\n\n    if (inComparisonView) {\n      inComparisonView = false;\n      removeDependencyComparison(svg);\n    } else {\n      inComparisonView = true;\n      if (attentions == null) {\n        initAttentionData(\n          `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(instanceID, 4)}.json`\n        ).then(() => drawDependencyComparison(topHeads, svg, SVGPadding, data,\n          attentions, saliencies, SVGHeight, existingLinkSet, tokenXs,\n          textTokenPadding, textTokenWidths, wordToSubwordMap, initWordToSubwordMap));\n      } else {\n        drawDependencyComparison(topHeads, svg, SVGPadding, data, attentions,\n          saliencies, SVGHeight, existingLinkSet, tokenXs, textTokenPadding,\n          textTokenWidths, wordToSubwordMap, initWordToSubwordMap);\n      }\n    }\n  };\n\n  const editButtonClicked = () => {\n    tableModalInfo.show = true;\n    tableModalStore.set(tableModalInfo);\n  };\n\n  const checkboxChanged = (e) => {\n    // Need to change the selectedRelations again because there is a race between\n    // svelte's bind:checked call back and this function (on:change)\n    let curRel = e.target.dataset.rel;\n    selectedRelations[curRel] = e.target.checked;\n  };\n\n  /**\n   * Create a list of interesting heads based on their max accuracy on the selected\n   * syntactic dependencies.\n  */\n  const getInterestingHeads = () => {\n    let potentialHeads = new Map();\n\n    for (let key in selectedRelations) {\n      if (!selectedRelations[key] || headOrder[key] === undefined) {\n        continue;\n      }\n\n      let topHeads = headOrder[key]['top_heads'];\n\n      // Track the max accuracy\n      topHeads.forEach(d => {\n        if (potentialHeads.has(d.head)) {\n          potentialHeads.set(d.head,\n            Math.max(d.acc, potentialHeads.get(d.head)));\n        } else {\n          potentialHeads.set(d.head, d.acc);\n        }\n      });\n    }\n\n    // Sort the heads\n    let sortedHeads = [...potentialHeads.entries()].sort((a, b) => b[1] - a[1]);\n    let sortedObjHeads = sortedHeads.map(d => ({\n      id: {\n        layer: d[0][0],\n        head: d[0][1]\n      },\n      acc: d[1]\n    }));\n\n    return sortedObjHeads;\n  };\n\n  const initData = async (dependencyFile, saliencyFile, orderFile) => {\n    // Init dependency data\n    data = await d3.json(dependencyFile);\n    data = data[instanceID];\n\n    let relationCounter = new Map();\n    selectedRelations = {};\n\n    // Create a set of existing [parent, child] pairs\n    existingLinkSet = new Set();\n\n    data.list.forEach(d => {\n      existingLinkSet.add(String([d.parent, d.child]));\n      if (relationCounter.has(d.relation)) {\n        relationCounter.set(d.relation, relationCounter.get(d.relation) + 1);\n      } else {\n        relationCounter.set(d.relation, 1);\n        // Select all relations in initialization\n        selectedRelations[d.relation] = true;\n      }\n    });\n    relationCounter = new Map([...relationCounter.entries()].sort((a, b) => b[1] - a[1]));\n    relations = [...relationCounter.entries()];\n\n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n\n    // Init the dependency layer/head accuracy list\n    headOrder = await d3.json(orderFile);\n  };\n\n  const initAttentionData = async (attentionFile) => {\n    attentions = await d3.json(attentionFile);\n  };\n\n  onMount(async () => {\n    // Load the dependency and saliency data\n    if (data == null || saliencies == null) {\n      initData('PUBLIC_URL/data/sst2-dependencies.json',\n        'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n        'PUBLIC_URL/data/sst2-sorted-syntactic-heads.json');\n    }\n\n    bindSelect();\n  });\n\n  const createGraph = () => {\n    let results = null;\n    switch(currentLayout.value) {\n    case 'saliency':\n      if (!SVGInitialized) {\n        initSVG();\n      }\n      drawParagraph(saliencies, svg, SVGWidth, SVGPadding, textTokenPadding,\n        wordToSubwordMap, tokenNodeMouseover, tokenNodeMouseleave);\n      saliencyViewInitialized = true;\n      break;\n    \n    case 'dependency':\n      if (!SVGInitialized) {\n        initSVG();\n      }\n      results = drawGraph(data, saliencies, wordToSubwordMap, svg, tokenXs,\n        textTokenPadding, SVGPadding, SVGHeight, tokenNodeMouseover,\n        tokenNodeMouseleave, initWordToSubwordMap);\n      tokenXs = results.tokenXs;\n      textTokenWidths = results.textTokenWidths;\n\n      getInterestingHeads();\n\n      dependencyViewInitialized = true;\n      break;\n\n    case 'tree':\n      if (!SVGInitialized) {\n        initSVG();\n      }\n      drawTree(data, saliencies, svg, SVGWidth, SVGHeight, SVGPadding,\n        tokenNodeMouseoverTree, tokenNodeMouseleave, textTokenPadding, wordToSubwordMap,\n        initWordToSubwordMap);\n      treeViewInitialized = true;\n      break; \n    }\n  };\n\n  instanceViewConfigStore.subscribe(async value => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined){\n      if (instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n        instanceViewConfig.compWidth !== value.compWidth)\n      ){\n        instanceViewConfig = value;\n\n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight - 41;\n\n        // Load the dependency and saliency data\n        if (data == null || saliencies == null) {\n          initData('PUBLIC_URL/data/sst2-dependencies.json',\n            'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n            'PUBLIC_URL/data/sst2-sorted-syntactic-heads.json')\n            .then(createGraph);\n        } else {\n          createGraph();\n        }\n\n      }\n    }\n  });\n\n  instanceIDStore.subscribe(value => {\n    // console.log('Instance changed!!');\n    if (value !== instanceID) {\n      svg.selectAll('*').remove();\n      SVGInitialized = false;\n      attentions = null;\n\n      data = null;\n      existingLinkSet = null;\n      saliencies = null;\n      attentions = null;\n      headOrder = null;\n\n      wordToSubwordMap = null;\n      dependencyViewInitialized = false;\n      saliencyViewInitialized = false;\n      treeViewInitialized = false;\n      instanceID = value;\n      initData('PUBLIC_URL/data/sst2-dependencies.json',\n        'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json',\n        'PUBLIC_URL/data/sst2-sorted-syntactic-heads.json').then(createGraph);\n    }\n    \n  });\n  \n  hoverTokenStore.subscribe(value => {\n\n    if (svg == null) {return;}\n\n    if (value != null) {\n      // Highlight the corresponding node\n      curHoverToken = value;\n      highLightNode();\n    } else {\n      // Dehighlight the old node\n      deHighLightNode();\n      curHoverToken = value;\n    }\n\n  });\n\n</script>\n\n<style type='text/scss'>.svg-container {\n  width: 100%;\n  overflow-x: scroll;\n  position: absolute;\n  top: 41px;\n  cursor: default;\n}\n\n.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n:global(.arc-text) {\n  dominant-baseline: middle;\n  font-family: \"Roboto Mono\", monospace;\n  font-size: 0.8em;\n  text-anchor: middle;\n  stroke-linejoin: round;\n  fill: #0088ff;\n}\n\n:global(.arc-path) {\n  stroke-width: 2;\n  fill: none;\n}\n\n:global(.arc-path--lr) {\n  stroke: url(#top-link-opacity-gradient-lr);\n}\n\n:global(.arc-path--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 3;\n}\n\n:global(.arc-path--rl) {\n  stroke: url(#top-link-opacity-gradient-rl);\n}\n\n:global(.arc-path--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 3;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.text-token), :global(.text-token-arc) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  cursor: default;\n  fill: black;\n}\n\n:global(.text-token-arc) {\n  dominant-baseline: hanging;\n  text-anchor: start;\n}\n\n:global(.text-link) {\n  cursor: default;\n  fill: #3a76a6;\n}\n\n:global(.node-group) {\n  stroke-linejoin: round;\n}\n:global(.node-group) :global(rect) {\n  fill: #f9fafb;\n  stroke: #cbcdcd;\n}\n\n:global(.link-group) {\n  fill: none;\n  stroke-opacity: 0.5;\n  stroke-width: 1.5;\n  stroke: #555;\n}\n\n:global(.node-group-attention) :global(text) {\n  opacity: 0.3;\n}\n:global(.node-group-attention) :global(rect) {\n  opacity: 0.4;\n  stroke: none;\n}\n\n:global(.comparison-head-name-group) :global(.name) {\n  font-size: 12px;\n  dominant-baseline: hanging;\n}\n\n:global(.attention-path) {\n  stroke: rgba(0, 0, 0, 0.3);\n  fill: none;\n}\n\n:global(.attention-path--lr) {\n  stroke: url(#link-opacity-gradient-lr);\n}\n\n:global(.attention-path--rl) {\n  stroke: url(#link-opacity-gradient-rl);\n}\n\n:global(.attention-arc) {\n  stroke: #1a1a1a;\n  fill: none;\n}\n\n:global(.attention-arc--lr) {\n  stroke: url(#link-opacity-gradient-lr);\n}\n\n:global(.attention-arc--rl) {\n  stroke: url(#link-opacity-gradient-rl);\n}\n\n:global(.attention-arc--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.attention-arc--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path) {\n  stroke: #fd9744;\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--lr) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n}\n\n:global(.matched-attention-path.attention-path--rl) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n}\n\n:global(.matched-attention-path.attention-path--lr.de-highlighted) {\n  stroke: url(#link-opacity-gradient-lr);\n  stroke-width: 1;\n}\n\n:global(.matched-attention-path.attention-path--rl.de-highlighted) {\n  stroke: url(#link-opacity-gradient-rl);\n  stroke-width: 1;\n}\n\n:global(.attention-path--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.attention-path--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--lr.de-highlighted.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--rl.de-highlighted.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.comparison-svg-button) {\n  cursor: pointer;\n}\n\n:global(.disabled) {\n  cursor: not-allowed;\n}\n\n.panel-container, .comparison-panel-container {\n  position: absolute;\n  display: flex;\n  flex-direction: row;\n}\n\n.dependency-label, .comparison-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 8px 0 20px;\n}\n\n.svg-control-panel, .comparison-control-panel {\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 5;\n  width: 98vw;\n  cursor: default;\n  padding-top: 5px;\n  max-height: 76px;\n  overflow: visible;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  font-size: 0.9rem;\n  background: rgba(255, 255, 255, 0.9);\n  user-select: none;\n}\n\nselect {\n  background: inherit;\n  border-color: rgba(0, 0, 0, 0);\n  padding: 0 1.6em 0 0.4em;\n  height: 1.8em;\n}\n\n.select select:not([multiple]) {\n  padding-right: 1.6em;\n}\n\n.select:not(.is-multiple) {\n  height: 1.8em;\n}\n\n.select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.8em;\n  border-color: #a77e62;\n}\n\n.comparison-panel-container {\n  width: 100%;\n  z-index: 5;\n  border-top: 1px solid rgba(0, 0, 0, 0.2);\n  box-shadow: 0 -3px 3px rgba(0, 0, 0, 0.01);\n}\n\n.comparison-label {\n  margin: 0 4px 0 20px;\n}\n\n.comparison-select {\n  font-size: 1.2em;\n  height: 2em;\n  border-bottom: 1px solid rgba(49, 32, 18, 0.2);\n}\n.comparison-select:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n.comparison-select select {\n  margin: 0;\n  padding: 0 1em 0 0;\n}\n.comparison-select select::after {\n  margin-top: -5px;\n}\n.comparison-select select:not([multiple]) {\n  padding-right: 1em;\n}\n.comparison-select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.3em;\n  border-color: #a77e62;\n  margin-top: -0.3em;\n}\n\n.relation-checkboxes {\n  position: absolute;\n  top: -40px;\n  left: 655px;\n  width: 700px;\n  padding: 5px 10px;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n  font-size: 0.9rem;\n  border-radius: 5px;\n  border: 1px solid #eeeeee;\n  box-shadow: 0 3px 3px rgba(0, 0, 0, 0.05);\n  background: rgba(255, 255, 255, 0.95);\n}\n\n.check-box-wrapper {\n  padding: 0 5px;\n}\n.check-box-wrapper input[type=checkbox] {\n  filter: hue-rotate(195deg) saturate(30%);\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 5px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n.select-row--highlight {\n  border: 1px solid #d6af8f;\n  background: rgba(49, 32, 18, 0.1);\n}\n.select-row--highlight:hover {\n  background: rgba(49, 32, 18, 0.1);\n}\n.select-row--edit {\n  margin-right: 20px;\n}\n\n.relation-container {\n  position: relative;\n}\n\n.relation {\n  padding: 0 2em 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n.relation::after {\n  z-index: 0;\n  border: 3px solid transparent;\n  border-radius: 2px;\n  border-right: 0;\n  border-top: 0;\n  content: \" \";\n  display: block;\n  height: 0.625em;\n  margin-top: -0.3em;\n  pointer-events: none;\n  position: absolute;\n  top: 50%;\n  transform: rotate(225deg);\n  transform-origin: center;\n  width: 0.625em;\n  border-color: #a77e62;\n  right: 0.9em;\n}\n\n.comparison-button {\n  padding: 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 1;\n}\n.icon-wrapper img {\n  height: 19px;\n}\n\n.hide {\n  display: none;\n}\n\n.light-gray {\n  color: #afa59d;\n}\n\n.gradient-guide {\n  margin-left: auto;\n}\n.gradient-guide img {\n  height: 22px;\n}</style>\n\n<div class='graph-view'>\n\n  <div class='panel-container'>\n\n    <!-- Control panel on top of the SVG -->\n    <div class='svg-control-panel'>\n\n      <div class='dependency-label'>\n        Current Sentence\n      </div>\n\n      <div class='select-row select-row--edit'>\n        <div class='relation-container' on:click={editButtonClicked}>\n          <div class='comparison-button'>\n            <div class='icon-wrapper'>\n              <img src='PUBLIC_URL/figures/edit.svg' alt='editing icon'>\n            </div>\n          </div>\n        </div>\n\n      </div>\n\n      <div class='select-row'>\n        <div class='select'>\n          <select name='instance-layout' id='instance-select'>\n            {#each Object.values(layoutOptions) as opt}\n              <option value={opt.value}>{opt.name}</option>\n            {/each}\n          </select>\n        </div>\n      </div>\n\n      <div class='select-row' class:select-row--highlight={inComparisonView}>\n        <div class='relation-container' on:click={comparisonButtonClicked}>\n          <div class='comparison-button'>\n            Show Comparison\n          </div>\n        </div>\n      </div>\n\n      <div class='select-row' class:select-row--highlight={showRelationCheckboxes}>\n        <div class='relation-container'\n          on:click={() => {showRelationCheckboxes = !showRelationCheckboxes;}}>\n          <div class='relation'>\n            Syntactic Relations\n          </div>\n        </div>\n      </div>\n\n      <div class='gradient-guide'>\n        <img src='PUBLIC_URL/figures/gradient.png' alt='gradient guide'>\n      </div>\n\n      <!-- Control panel after syntactic relation item is selected -->\n      <div class='relation-checkboxes' class:hide={!showRelationCheckboxes}>\n        {#each relations as entry}\n\n          <label class=\"checkbox check-box-wrapper\">\n            <input type=\"checkbox\" on:change={checkboxChanged}\n              bind:checked={selectedRelations[entry[0]]}\n              data-rel={entry[0]}\n            >\n            {entry[0]}\n            <span class='light-gray'>({entry[1]})</span>\n          </label>\n            \n        {/each}\n      </div>\n\n    </div>\n\n  </div>\n\n  <div class='comparison-panel-container hide'>\n    <div class='comparison-control-panel'>\n      <!-- <div class='comparison-name'>\n        Dependency predicted by 5 attentions heads having the highest score.\n      </div> -->\n\n      <div class='comparison-label'>\n        Dependencies predicted by attention heads with top \n      </div>\n\n      <div class='select comparison-select'>\n        <select name='head-list' id='head-select'>\n          {#each Object.values(headListOptions) as opt}\n            <option value={opt.value}>{opt.name}</option>\n          {/each}\n        </select>\n      </div>\n\n\n    </div>\n  </div>\n\n  <div class='svg-container'>\n    <svg class='dependency-svg'></svg>\n  </div>\n  \n</div>\n\n<RadialModal />",
    "<script>\n  import { onMount } from 'svelte';\n  import { modalStore, attentionHeadColorStore } from '../store';\n  import { getTokenWidth } from './utils';\n  import { resetRadialButtons } from './comparison-view';\n  import * as d3 from 'd3';\n\n  let modalComponent = null;\n  let svg = null;\n  let donut = null;\n  let svgVirtualLength = 500;\n  let svgLength = 480;\n\n  let modalInfo = {};\n  let markerDef = null;\n\n  let attentionHeadColor = new Map();\n  attentionHeadColorStore.subscribe(value => {attentionHeadColor = value;});\n\n  modalStore.set(modalInfo);\n  modalStore.subscribe(value => {\n    modalInfo = value;\n    if (modalInfo.attention != null) {\n      drawDonut(donut);\n    }\n  });\n\n  const crossClicked = () => {\n    modalInfo.show = false;\n    modalStore.set(modalInfo);\n\n    // Clean up the view\n    svg.select('.donut')\n      .selectAll('*')\n      .remove();\n    \n    // Reset buttons\n    resetRadialButtons();\n  };\n\n  const dragElement = (element) => {\n    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n    \n    const dragMouseDown = (e) => {\n      pos3 = e.clientX;\n      pos4 = e.clientY;\n\n      // Register events for mouse up and mouse move\n      document.onmouseup = closeDragElement;\n      document.onmousemove = elementDrag;\n    };\n\n    const elementDrag = (e) => {\n      // calculate the new cursor position:\n      pos1 = pos3 - e.clientX;\n      pos2 = pos4 - e.clientY;\n      pos3 = e.clientX;\n      pos4 = e.clientY;\n\n      // set the element's new position:\n      element.style.top = (element.offsetTop - pos2) + 'px';\n      element.style.left = (element.offsetLeft - pos1) + 'px';\n    };\n\n    const closeDragElement = () => {\n      // Restore the original mouse up and mouse move\n      document.onmouseup = null;\n      document.onmousemove = null;\n\n      // Remember the size and position\n      modalInfo.top = element.style.top;\n      modalInfo.left = element.style.left;\n      modalInfo.width = element.style.width;\n      modalInfo.height = element.style.height;\n    };\n\n    document.querySelector('.modal-card-head').onmousedown = dragMouseDown;\n  };\n\n  const drawDonut = (donut) => {\n    \n    // Restore the size and pos of the modal window if possible\n    if (modalInfo.top !== undefined) {\n      d3.select(modalComponent)\n        .select('.modal-card')\n        .style('top', `${modalInfo.top}px`)\n        .style('left', `${modalInfo.top}px`)\n        .style('width', `${modalInfo.width}px`)\n        .style('height', `${modalInfo.height}px`);\n    } else {\n      let SVGHeight = +d3.select('.dependency-svg').attr('height');\n      let SVGWidth = window.innerWidth;\n\n      d3.select(modalComponent)\n        .select('.modal-card')\n        .style('top', `${(SVGHeight - 420) / 2}px`)\n        .style('left', `${(SVGWidth - 380) / 2}px`);\n    }\n\n    let color = attentionHeadColor.get([modalInfo.layer, modalInfo.head].toString());\n\n    svg.select('#atlas-arrow')\n      .select('path')\n      .attr('fill', color)\n      .attr('stroke', color);\n\n    // Pre-draw the text\n    let tempSVG = d3.select(document.body)\n      .append('svg')\n      .attr('height', 200)\n      .attr('width', 200)\n      .style('visibility', 'hidden');\n\n    const result = getTokenWidth(modalInfo.tokens.map(d => d.token), tempSVG, '0.9em');\n    const maxTextWidth = d3.max(Object.entries(result.textTokenWidths).map(d => d[1]));\n    let inRadius = svgVirtualLength / 2 - maxTextWidth;\n    \n    tempSVG.remove();\n\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i\n      });\n    }\n\n    // Create the links\n    let links = [];\n    let threshold = 0;\n\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      for (let j = 0; j < modalInfo.tokens.length; j++) {\n        let curAttention = modalInfo.attention[i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3.scaleLinear()\n      .domain(d3.extent(links.map(d => d.attention)))\n      .range([0.2, 0.7]);\n\n    let linkOpacityScale = d3.scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n    \n    // Draw the texts (will re-draw again later after getting the optimal circle size)\n    let textTokenGroup = donut.append('g')\n      .attr('class', 'token-text-group')\n      .style('font-size', '0.9em')\n      .style('cursor', 'default');\n\n    textTokenGroup.selectAll('text')\n      .data(tokenPos, d => d.id)\n      .join('text')\n      .attr('data-angle', d => d.angle)\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', d => d.angle < Math.PI / 2 ? 6 : -6)\n      .attr('text-anchor', d => d.angle < Math.PI / 2 ? 'start' : 'end')\n      .text(d => d.token);\n\n    // Optimize the circle size (maximize the inner bbox)\n    // Need to create a temp svg to work around the drawing delay\n    let textClone = donut.select('.token-text-group').clone(true).remove();\n\n    tempSVG = d3.select(document.body)\n      .append('svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', svgLength)\n      .attr('height', svgLength)\n      .style('visibility', 'hidden');\n    \n\n    tempSVG.append(() => textClone.node());\n    let innerBox = tempSVG.select('.token-text-group').node().getBBox();\n    tempSVG.remove();\n\n    let top = svgVirtualLength / 2 + innerBox.y;\n    let bottom = svgVirtualLength - top - innerBox.height;\n    let left = svgVirtualLength / 2 + innerBox.x;\n    let right = svgVirtualLength - left - innerBox.width;\n\n    let radiusGrow = Math.min(top, bottom, left, right);\n\n    // Grow the radius and redraw text, circles and paths\n    inRadius += Math.floor(radiusGrow);\n\n    // Figure out the token positions\n    tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle = -Math.PI / 2 + i * (Math.PI * 2 / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i\n      });\n    }\n\n    // Draw invisible background for interaction\n    textTokenGroup.selectAll('rect')\n      .data(tokenPos, d => d.id)\n      .join('rect')\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n        `;\n      })\n      .attr('x', 0)\n      .attr('y', -5)\n      .attr('width', 50)\n      .attr('height', 15)\n      .style('fill', 'white')\n      .style('opacity', 0)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-arrow')\n          .select('path')\n          .attr('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.5);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .filter(dd => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-arrow')\n          .select('path')\n          .attr('opacity', null);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', d => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Update text position\n    textTokenGroup.selectAll('text')\n      .data(tokenPos, d => d.id)\n      .join('text')\n      .attr('data-angle', d => d.angle)\n      .attr('transform', d => {\n        let degree = d.angle * 180 / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', d => d.angle < Math.PI / 2 ? 6 : -6)\n      .attr('text-anchor', d => d.angle < Math.PI / 2 ? 'start' : 'end')\n      .text(d => d.token)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-arrow')\n          .select('path')\n          .style('opacity', 0.5);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .filter(dd => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-arrow-hover)')\n          .style('stroke', 'hsl(24, 95%, 59%)')\n          .style('opacity', 1)\n          .style('stroke-width', 3)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-arrow')\n          .select('path')\n          .attr('opacity', null);\n\n        donut.select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', d => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Draw the links as bezier curves\n    donut.append('g')\n      .attr('class', 'path-group')\n      .selectAll('path.donut-link')\n      .data(links, d => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('marker-end', 'url(#atlas-arrow)')\n      .attr('d', d => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = {x: 0, y: 0};\n        const radialCurveAlpha = 2 / 5;\n        \n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha\n        };\n        \n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('stroke-width', d => linkWidthScale(d.attention))\n      .style('opacity', d => linkOpacityScale(d.attention));\n    \n    // Draw the circles\n    donut.append('g')\n      .attr('class', 'token-dot-group')\n      .selectAll('circle.token-dot')\n      .data(tokenPos, d => d.id)\n      .join('circle')\n      .attr('class', 'token-dot')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', 1);\n\n  };\n\n  const drawRadial = () => {\n    svg.append('rect')\n      .attr('width', svgVirtualLength)\n      .attr('height', svgVirtualLength)\n      .style('fill', 'hsla(0, 0%, 100%, 0)');\n    \n    donut = svg.append('g')\n      .attr('class', 'donut')\n      .attr('transform', 'translate(250, 250)');\n\n    // drawDonut(donut);\n    markerDef = svg.append('defs')\n      .attr('id', 'atlas-arrow-def')\n      .append('marker')\n      .attr('id', 'atlas-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'gray')\n      .attr('fill', 'gray');\n\n    markerDef = svg.append('defs')\n      .attr('id', 'atlas-arrow-def-hover')\n      .append('marker')\n      .attr('id', 'atlas-arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'hsl(24, 95%, 59%)')\n      .attr('fill', 'hsl(24, 95%, 59%)');\n    \n  };\n\n  onMount(() => {\n    // Bind drag event\n    let modalCard = d3.select(modalComponent)\n      .select('.modal-card');\n\n    dragElement(modalCard.node());\n\n    svg = modalCard.select('svg.modal-svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', '100%')\n      .attr('height', '100%');\n\n    drawRadial();\n\n  });\n\n  const getColor = (layer, head) => {\n    if (attentionHeadColor == null || attentionHeadColor.has === undefined ||\n      !attentionHeadColor.has([layer, head].toString())) {\n      return 'black';\n    } else {\n      return attentionHeadColor.get([layer, head].toString());\n    }\n  };\n\n</script>\n\n<style type='text/scss'>.modal {\n  pointer-events: none;\n}\n\n.modal-card {\n  width: 380px;\n  height: 420px;\n  max-width: 800px;\n  min-width: 340px;\n  min-height: 380px;\n  resize: both;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n  animation: modal-card-appear 200ms;\n  /* Make it draggable */\n  position: absolute;\n  pointer-events: all;\n}\n.modal-card-title {\n  font-size: 1em;\n  cursor: default;\n  pointer-events: none;\n}\n.modal-card-head {\n  padding: 10px 15px;\n  cursor: move;\n}\n.modal-card-body {\n  padding: 5px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n@keyframes modal-card-appear {\n  0% {\n    opacity: 0;\n  }\n  50% {\n    opacity: 1;\n  }\n}</style>\n\n\n<div class='modal-component'\n  bind:this={modalComponent}>\n\n  <div class='modal' class:is-active={modalInfo.show}>\n\n    <div class='modal-card'>\n      <header class='modal-card-head'>\n        <div class='modal-card-title'\n          style={`color: ${getColor(modalInfo.layer, modalInfo.head)}`}>\n          Layer {modalInfo.layer} Head {modalInfo.head} Attention Wights\n        </div>\n        <button class='delete' aria-label='close' on:click={crossClicked}></button>\n      </header>\n\n      <section class='modal-card-body'>\n\n        <svg class='modal-svg'></svg>\n\n      </section>\n\n    </div>\n\n  </div>\n\n</div>"
  ],
  "names": [],
  "mappings": "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"
}