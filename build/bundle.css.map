{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "Atlas.svelte",
    "AtlasSide.svelte",
    "CircleView.svelte",
    "GraphView.svelte",
    "GridView.svelte",
    "Header.svelte",
    "LowerAtlas.svelte",
    "Main.svelte",
    "RadialView.svelte",
    "Saliency.svelte",
    "TableModal.svelte",
    "TableView.svelte",
    "TextClassificationStats.svelte",
    "Tooltip.svelte",
    "TooltipGlobal.svelte",
    "Article.svelte",
    "Dependency.svelte",
    "RadialModal.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { onMount } from 'svelte';\n  import {\n    mapViewConfigStore,\n    sideStore,\n    instanceIDStore,\n    attentionHeadColorStore,\n    tooltipConfigStore,\n    mapHeadStore,\n  } from './store';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  export let attentionDataDir;\n  export let saliencyDataFilepath;\n  export let atlasDataFilepath;\n\n  let svg = null;\n  let atlasData = null;\n  let attentions = null;\n  let saliencies = null;\n  let tokenSize = null;\n\n  // Tooltip variables\n  let tooltipConfig = null;\n  tooltipConfigStore.subscribe((value) => {\n    tooltipConfig = value;\n  });\n\n  let sideInfo = null;\n\n  let viewContainer = null;\n  let mapHead = { layer: 9, head: 8 };\n  let curLayer = 9;\n  let curHead = 8;\n\n  const red = d3.hcl(23, 85, 56);\n  const purple = d3.hcl(328, 85, 56);\n  const blue = d3.hcl(274, 85, 56);\n\n  let instanceID = 1562;\n\n  const dispatch = createEventDispatcher();\n  let isShown = true;\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n\n  const SVGPadding = { top: 40, left: 10, right: 10, bottom: 3 };\n\n  const ease = d3.easeCubicInOut;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const createGraph = () => {\n    const layerNum = attentions.length;\n    const headNum = attentions[0].length;\n    const layerNameWidth = 47;\n    const headNameHeight = 20;\n\n    // console.log(SVGWidth, SVGHeight);\n\n    let availableWidth =\n      SVGWidth - 210 - layerNameWidth - SVGPadding.left - SVGPadding.right;\n    let availableHeight =\n      SVGHeight - SVGPadding.top - SVGPadding.bottom - headNameHeight;\n\n    let availableLength = Math.min(availableHeight, availableWidth);\n    // console.log(SVGHeight, availableLength, availableWidth, availableHeight);\n    const gridGap = 8;\n\n    const gridLength = Math.floor(\n      (availableHeight - (layerNum - 1) * gridGap) / layerNum\n    );\n    const maxOutRadius = gridLength / 2;\n    const minOutRadius = 10;\n\n    let adjustedRowGap = Math.floor(\n      (availableWidth - maxOutRadius - headNum * gridLength) / (layerNum - 1)\n    );\n    let adjustedColGap = Math.floor(\n      (availableHeight - layerNum * gridLength) / (layerNum - 1)\n    );\n\n    svg = d3\n      .select('.atlas-svg-full')\n      .attr(\n        'viewbox',\n        `0 0 ${availableWidth + layerNameWidth} ${availableHeight}`\n      )\n      .attr('width', availableWidth + layerNameWidth)\n      .attr('height', availableHeight + headNameHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', availableLength)\n      .attr('height', availableLength)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    let donutGroup = svg\n      .append('g')\n      .attr('class', 'donut-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left + maxOutRadius + layerNameWidth},\n        ${maxOutRadius + headNameHeight})`\n      );\n\n    // Create color scale\n    let hueScale = d3\n      .scaleLinear()\n      .domain([-1, 0, 1])\n      .range([red, purple, blue]);\n\n    let lightnessScale = d3.scaleLinear().domain([0, 1]).range([130, 40]);\n\n    // Use square root scale\n    let outRadiusScale = d3\n      .scaleLinear()\n      .domain([0, 1])\n      .range([minOutRadius, maxOutRadius]);\n\n    let ringRadiusScale = d3.scaleLinear().domain([0, 1]).range([4, 7]);\n\n    let scales = {\n      hueScale: hueScale,\n      lightnessScale: lightnessScale,\n      outRadiusScale: outRadiusScale,\n      ringRadiusScale: ringRadiusScale,\n    };\n\n    let donuts = donutGroup\n      .selectAll('g.donut')\n      .data(atlasData)\n      .join('g')\n      .attr('class', 'donut')\n      .attr(\n        'transform',\n        (d) => `translate(${d.head * (maxOutRadius * 2 + adjustedRowGap)},\n        ${(layerNum - d.layer - 1) * (maxOutRadius * 2 + adjustedColGap)})`\n      )\n      .style('pointer-events', 'fill')\n      .style('cursor', 'pointer');\n\n    // Draw the donuts\n    donuts.each((d, i, g) => drawDonut(d, i, g, scales));\n\n    donuts\n      .on('mouseover', (e, d) => {\n        // Show the tooltip\n        let node = e.currentTarget;\n        let position = node.getBoundingClientRect();\n        let curWidth = position.right - position.left;\n\n        let tooltipCenterX = position.x + curWidth / 2;\n        let tooltipCenterY = position.y - 90;\n\n        tooltipConfig.html = `\n        <div class='tooltip-tb' style='display: flex; flex-direction: column;\n          justify-content: center; font-weight: 600;'>\n          <div> Layer ${d.layer + 1} Head ${d.head + 1} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Semantic: ${round(\n            d.semantic,\n            2\n          )} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Syntactic ${round(\n            d.syntactic,\n            2\n          )} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Importance: ${round(\n            d.confidence,\n            2\n          )} </div>\n        </div>\n        `;\n        tooltipConfig.width = 130;\n        tooltipConfig.maxWidth = 130;\n        tooltipConfig.left = tooltipCenterX - tooltipConfig.width / 2;\n        tooltipConfig.top = tooltipCenterY;\n        tooltipConfig.fontSize = '0.8em';\n        tooltipConfig.show = true;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Show the background rect\n        let curDonut = d3.select(e.currentTarget);\n\n        if (!curDonut.classed('selected')) {\n          curDonut.select('.donut-rect').style('opacity', 1);\n        }\n      })\n      .on('mouseleave', (e) => {\n        // TODO\n        // let datum = d3.select(e.target).data()[0];\n        // if (datum.layer === 2 && datum.head === 9) {\n        //   return;\n        // }\n\n        tooltipConfig.show = false;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Hide the background rect\n        let curDonut = d3.select(e.currentTarget);\n        if (!curDonut.classed('selected')) {\n          curDonut.select('.donut-rect').style('opacity', 0);\n        }\n      })\n      .on('click', (e, d) => {\n        sideInfo.show = true;\n        sideInfo.attention = attentions[d.layer][d.head];\n        sideInfo.tokens = saliencies.tokens.map((d) => {\n          return { token: d.token };\n        });\n        sideInfo.layer = d.layer;\n        sideInfo.head = d.head;\n        sideStore.set(sideInfo);\n      })\n      .on('dblclick', (e) => {\n        // console.log('double!');\n        let curDonut = d3.select(e.currentTarget);\n        if (curDonut.classed('selected')) {\n          // pass\n        } else {\n          // Restore the currently selected rect\n          let preDonut = d3.select(\n            donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node()\n              .parentNode\n          );\n\n          preDonut\n            .select('.donut-rect')\n            .style('fill', 'hsl(0, 0%, 80%)')\n            .style('opacity', 0);\n\n          preDonut.classed('selected', false);\n\n          // Style the new rect\n          curDonut\n            .select('.donut-rect')\n            .style('fill', 'hsl(27, 47%, 13%)')\n            .style('opacity', 1);\n\n          curDonut.classed('selected', true);\n\n          curLayer = +curDonut.data()[0].layer;\n          curHead = +curDonut.data()[0].head;\n\n          mapHead.layer = curLayer;\n          mapHead.head = curHead;\n          mapHeadStore.set(mapHead);\n        }\n      });\n\n    // Draw horizontal lines between rows\n    donutGroup\n      .selectAll('g.row-line-group')\n      .data(\n        Array(layerNum - 1)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'row-line-group')\n      .append('path')\n      .attr('d', (d) => {\n        return `M${-maxOutRadius}\n        ${(layerNum - d - 1 - 1 / 2) * (maxOutRadius * 2 + adjustedColGap)}\n        L${headNum * (maxOutRadius * 2 + adjustedRowGap) - maxOutRadius}\n        ${(layerNum - d - 1 - 1 / 2) * (maxOutRadius * 2 + adjustedColGap)}`;\n      })\n      .style('stroke', 'hsla(0, 0%, 0%, 0.1)');\n\n    // Draw the label names\n    let nameGroup = svg\n      .append('g')\n      .attr('class', 'name-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left}, ${maxOutRadius + headNameHeight})`\n      );\n\n    nameGroup\n      .selectAll('g.layer-name-group')\n      .data(\n        Array(layerNum)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'layer-name-group')\n      .attr(\n        'transform',\n        (d) => `translate(${layerNameWidth - 10},\n        ${(layerNum - d - 1) * (maxOutRadius * 2 + adjustedColGap)})`\n      )\n      .append('text')\n      .text((d) => (d > 0 ? d + 1 : `Layer ${d + 1}`));\n\n    let headNameGroup = svg\n      .append('g')\n      .attr('class', 'name-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left + layerNameWidth + maxOutRadius},\n        ${9})`\n      );\n\n    headNameGroup\n      .selectAll('g.head-name-group')\n      .data(\n        Array(layerNum)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'head-name-group')\n      .attr(\n        'transform',\n        (d) => `translate(${d * (maxOutRadius * 2 + adjustedRowGap)},\n        ${0})`\n      )\n      .append('text')\n      .text((d) => (d > 0 ? d + 1 : `Head ${d + 1}`));\n\n    d3.select(viewContainer)\n      .select('.head-arrow')\n      .style('top', `${70 - 40}px`)\n      .style('left', `${availableWidth - 170}px`);\n\n    d3.select(viewContainer)\n      .select('.layer-arrow')\n      .style('top', `${70}px`)\n      .style('left', `${availableWidth + 10}px`);\n\n    let curDonut = d3.select(\n      donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node().parentNode\n    );\n\n    // Style the new rect\n    curDonut\n      .select('.donut-rect')\n      .style('fill', 'hsl(27, 47%, 13%)')\n      .style('opacity', 1);\n\n    curDonut.classed('selected', true);\n  };\n\n  const drawDonut = (d, i, g, scales) => {\n    let donut = d3.select(g[i]);\n\n    let outRadius = scales.outRadiusScale(d.confidence);\n    let ringRadius = scales.ringRadiusScale(d.confidence);\n    let inRadius = Math.max(0, outRadius - ringRadius);\n\n    // Draw the background rect\n    let maxLength = 2 * scales.outRadiusScale.range()[1];\n    donut\n      .append('rect')\n      .attr('class', 'donut-rect')\n      .attr('id', `donut-rect-${d.layer}-${d.head}`)\n      .attr('x', -maxLength / 2)\n      .attr('y', -maxLength / 2)\n      .attr('rx', 5)\n      .attr('width', maxLength)\n      .attr('height', maxLength)\n      .style('fill', 'hsl(0, 0%, 80%)')\n      .style('opacity', 0);\n\n    // Draw an invisible circle for interaction\n    donut\n      .append('circle')\n      .attr('cx', 0)\n      .attr('cy', 0)\n      .attr('r', outRadius)\n      .style('fill', '#FDFCFC')\n      .style('opacity', 1);\n\n    // Draw the rings\n    // Arc's center is at (0, 0) on the local coordinate\n    let arc = d3\n      .arc()\n      .outerRadius(outRadius)\n      .innerRadius(inRadius)\n      .startAngle(0)\n      .endAngle(Math.PI * 2);\n\n    let color = d3.hcl(scales.hueScale(d.syntactic - d.semantic));\n    color.l = scales.lightnessScale(Math.max(d.semantic, d.syntactic));\n\n    donut\n      .append('path')\n      .attr('class', 'donut-chart')\n      .attr('d', arc)\n      .style('fill', color);\n\n    // Draw the edges\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < tokenSize; i++) {\n      let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / tokenSize);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        token: d.token,\n        id: i,\n      });\n    }\n\n    // Create the links\n    let links = [];\n\n    // Todo\n    // let threshold = 0.2;\n    let threshold = 0;\n\n    for (let i = 0; i < tokenSize; i++) {\n      for (let j = 0; j < tokenSize; j++) {\n        let curAttention = attentions[d.layer][d.head][i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`,\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3\n      .scaleLinear()\n      .domain(d3.extent(links.map((d) => d.attention)))\n      .range([0.2, 0.7]);\n\n    let linkOpacityScale = d3\n      .scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n\n    // Draw the links as bezier curves\n    donut\n      .selectAll('path.donut-link')\n      .data(links, (d) => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('d', (d) => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = { x: 0, y: 0 };\n        const radialCurveAlpha = 2 / 5;\n\n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha,\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha,\n        };\n\n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('pointer-events', 'none')\n      .style('stroke-width', (d) => linkWidthScale(d.attention))\n      .style('opacity', (d) => linkOpacityScale(d.attention));\n  };\n\n  const initData = async (attentionFile, saliencyFile, atlasFile) => {\n    // Init attention data\n    attentions = await d3.json(attentionFile);\n\n    // init atlas data\n    atlasData = await d3.json(atlasFile);\n\n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n    tokenSize = saliencies.tokens.length;\n  };\n\n  const closeClicked = () => {\n    sideInfo.show = false;\n    sideStore.set(sideInfo);\n    dispatch('close');\n  };\n\n  const badgeClicked = () => {\n    if (isShown) {\n      dispatch('close');\n      isShown = false;\n\n      d3.select(viewContainer)\n        .select('.svg-container')\n        .transition('move')\n        .duration(700)\n        .ease(ease)\n        .style('opacity', 0);\n\n      // Change the badge style\n      d3.timer(() => {\n        let badge = d3\n          .select(viewContainer)\n          .select('.badge')\n          .style('border-left', '1px solid hsl(0, 0%, 90.2%)')\n          .style('border-radius', '5px')\n          .style('box-shadow', '-3px 3px 3px hsla(0, 0%, 0%, 0.06)')\n          .style('margin-left', '5px');\n\n        badge.select('.badge-title').style('visibility', 'hidden');\n\n        badge\n          .select('.icon-wrapper > img')\n          .attr('src', 'PUBLIC_URL/figures/map-marked-alt-solid.svg');\n      }, 400);\n    } else {\n      dispatch('open');\n      isShown = true;\n\n      d3.select(viewContainer)\n        .select('.svg-container')\n        .transition('move')\n        .duration(700)\n        .ease(ease)\n        .style('opacity', 1);\n\n      // Change the badge style\n      d3.timer(() => {\n        let badge = d3\n          .select(viewContainer)\n          .select('.badge')\n          .style('border-left', null)\n          .style('border-radius', '0 5px 5px 0')\n          .style('box-shadow', null)\n          .style('margin-left', null);\n\n        badge.select('.badge-title').style('visibility', 'visible');\n\n        badge\n          .select('.icon-wrapper > img')\n          .attr('src', 'PUBLIC_URL/figures/chevron-right-solid.svg');\n      }, 400);\n    }\n  };\n\n  onMount(async () => {\n    // Load the attention and atlas data\n    if (attentions == null || atlasData == null || saliencies == null) {\n      initData(\n        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`,\n        saliencyDataFilepath,\n        atlasDataFilepath\n      );\n    }\n  });\n\n  instanceIDStore.subscribe(async (value) => {\n    if (value !== instanceID) {\n      instanceID = value;\n      saliencies = await d3.json(saliencyDataFilepath);\n      saliencies = saliencies[instanceID];\n      tokenSize = saliencies.tokens.length;\n      svg.select('*').remove();\n      createGraph();\n    }\n  });\n\n  sideStore.subscribe((value) => {\n    sideInfo = value;\n  });\n\n  mapViewConfigStore.subscribe(async (value) => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined) {\n      if (\n        instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n          instanceViewConfig.compWidth !== value.compWidth)\n      ) {\n        instanceViewConfig = value;\n\n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight;\n\n        // Load the attention and atlas data\n        if (attentions == null || atlasData == null || saliencies == null) {\n          initData(\n            attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`,\n            saliencyDataFilepath,\n            atlasDataFilepath\n          ).then(createGraph);\n        } else {\n          createGraph();\n        }\n      }\n    }\n  });\n</script>\n\n<style lang=\"scss\">.svg-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  align-items: flex-end;\n}\n\n.atlas-view {\n  display: flex;\n  flex-direction: row;\n  max-width: 100%;\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n  transition: max-width 1000ms ease-in-out;\n  border-radius: 10px 0 0 10px;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  box-shadow: -3px -3px 3px rgba(0, 0, 0, 0.1);\n  background: #fdfcfc;\n}\n.atlas-view .triangle {\n  content: \"\";\n  position: absolute;\n  top: 500px;\n  left: 0;\n  border-top: 20px solid transparent;\n  border-bottom: 20px solid transparent;\n  border-left: 20px solid #f2f2f2;\n}\n\n.legend-container {\n  padding-bottom: 25px;\n  padding-top: 50px;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  pointer-events: none;\n}\n.legend-container :first-child {\n  margin-bottom: 35px;\n}\n\n.bottom-images {\n  display: flex;\n  flex-direction: column;\n}\n.bottom-images :first-child {\n  margin-bottom: 35px;\n}\n\n.atlas-svg-container {\n  position: relative;\n}\n.atlas-svg-container svg {\n  border-right: 1px solid #e6e6e6;\n}\n\n.head-arrow {\n  position: absolute;\n  width: 160px;\n  pointer-events: none;\n}\n\n.layer-arrow {\n  position: absolute;\n  height: 160px;\n  pointer-events: none;\n}\n\n.control-row {\n  position: absolute;\n  top: 0;\n  left: 0;\n  cursor: default;\n  padding-top: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  user-select: none;\n  font-size: 0.9rem;\n  z-index: 5;\n}\n\n.lower-atlas-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 20px 0 10px;\n  display: flex;\n  flex-direction: row;\n}\n\n.expand-button {\n  padding: 3px 5px;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 10px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 0.5;\n  transform: rotate(45deg);\n}\n.icon-wrapper img {\n  height: 1.2em;\n}\n\n.hidden {\n  visibility: hidden;\n}</style>\n\n<div class=\"atlas-view\" bind:this={viewContainer}>\n  <div class=\"triangle\" class:hidden={!sideInfo.show} />\n\n  <div class=\"control-row\">\n    <div class=\"lower-atlas-label\">\n      <div class=\"select-row\">\n        <div class=\"relation-container\" on:click={closeClicked}>\n          <div class=\"expand-button\">\n            <div class=\"icon-wrapper\">\n              <img\n                src=\"PUBLIC_URL/figures/arrow-forward-outline.svg\"\n                alt=\"expanding icon\"\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      Attention Head Overview\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <div class=\"atlas-svg-container\">\n      <svg class=\"atlas-svg-full\" />\n    </div>\n\n    <div class=\"legend-container\">\n      <div>\n        <img\n          src=\"PUBLIC_URL/figures/click.png\"\n          width=\"180px\"\n          alt=\"click guide\"\n        />\n      </div>\n      <div class=\"bottom-images\">\n        <img\n          src=\"PUBLIC_URL/figures/size-legend.png\"\n          width=\"160px\"\n          alt=\"size legend\"\n        />\n        <img\n          src=\"PUBLIC_URL/figures/legend.png\"\n          width=\"200px\"\n          alt=\"color legend\"\n        />\n      </div>\n    </div>\n  </div>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { sideStore, attentionHeadColorStore } from './store';\n  import { getTokenWidth } from './dependency-view/utils';\n  import * as d3 from 'd3';\n\n  let modalComponent = null;\n  let svg = null;\n  let donut = null;\n  let svgVirtualLength = 500;\n  let svgLength = 480;\n  let markerDef = null;\n\n  let attentionHeadColor = new Map();\n  attentionHeadColorStore.subscribe((value) => {\n    attentionHeadColor = value;\n  });\n\n  let modalInfo = {};\n\n  sideStore.subscribe((value) => {\n    modalInfo = value;\n\n    if (modalInfo.attention != null) {\n      donut.selectAll('*').remove();\n      drawDonut(donut);\n    }\n  });\n\n  const drawDonut = (donut) => {\n    let color = attentionHeadColor.get(\n      [modalInfo.layer, modalInfo.head].toString()\n    );\n\n    svg\n      .select('#atlas-side-arrow')\n      .select('path')\n      .attr('fill', color)\n      .attr('stroke', color);\n\n    // Pre-draw the text\n    let tempSVG = d3\n      .select(document.body)\n      .append('svg')\n      .attr('height', 200)\n      .attr('width', 200)\n      .style('visibility', 'hidden');\n\n    const result = getTokenWidth(\n      modalInfo.tokens.map((d) => d.token),\n      tempSVG,\n      '0.9em'\n    );\n    const maxTextWidth = d3.max(\n      Object.entries(result.textTokenWidths).map((d) => d[1])\n    );\n    let inRadius = svgVirtualLength / 2 - maxTextWidth;\n\n    tempSVG.remove();\n\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle =\n        -Math.PI / 2 + i * ((Math.PI * 2) / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i,\n      });\n    }\n\n    // Create the links\n    let links = [];\n    let threshold = 0;\n\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      for (let j = 0; j < modalInfo.tokens.length; j++) {\n        let curAttention = modalInfo.attention[i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`,\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3\n      .scaleLinear()\n      .domain(d3.extent(links.map((d) => d.attention)))\n      .range([0.5, 2]);\n\n    let linkOpacityScale = d3\n      .scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n\n    // Draw the texts (will re-draw again later after getting the optimal circle size)\n    let textTokenGroup = donut\n      .append('g')\n      .attr('class', 'token-text-group')\n      .style('font-size', '0.9em')\n      .style('cursor', 'default');\n\n    textTokenGroup\n      .selectAll('text')\n      .data(tokenPos, (d) => d.id)\n      .join('text')\n      .attr('data-angle', (d) => d.angle)\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', (d) => (d.angle < Math.PI / 2 ? 6 : -6))\n      .attr('text-anchor', (d) => (d.angle < Math.PI / 2 ? 'start' : 'end'))\n      .text((d) => d.token);\n\n    // Optimize the circle size (maximize the inner bbox)\n    // Need to create a temp svg to work around the drawing delay\n    let textClone = donut.select('.token-text-group').clone(true).remove();\n\n    tempSVG = d3\n      .select(document.body)\n      .append('svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', svgLength)\n      .attr('height', svgLength)\n      .style('visibility', 'hidden');\n\n    tempSVG.append(() => textClone.node());\n    let innerBox = tempSVG.select('.token-text-group').node().getBBox();\n    tempSVG.remove();\n\n    let top = svgVirtualLength / 2 + innerBox.y;\n    let bottom = svgVirtualLength - top - innerBox.height;\n    let left = svgVirtualLength / 2 + innerBox.x;\n    let right = svgVirtualLength - left - innerBox.width;\n\n    let radiusGrow = Math.min(top, bottom, left, right);\n\n    // Grow the radius and redraw text, circles and paths\n    inRadius += Math.floor(radiusGrow);\n\n    // Figure out the token positions\n    tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle =\n        -Math.PI / 2 + i * ((Math.PI * 2) / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i,\n      });\n    }\n\n    // Draw invisible background for interaction\n    textTokenGroup\n      .selectAll('rect')\n      .data(tokenPos, (d) => d.id)\n      .join('rect')\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n        `;\n      })\n      .attr('x', 0)\n      .attr('y', -5)\n      .attr('width', 50)\n      .attr('height', 15)\n      .style('fill', 'white')\n      .style('opacity', 0)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-side-arrow').select('path').attr('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .filter((dd) => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-side-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-side-arrow').select('path').attr('opacity', null);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-side-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', (d) => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Update text position\n    textTokenGroup\n      .selectAll('text')\n      .data(tokenPos, (d) => d.id)\n      .join('text')\n      .attr('data-angle', (d) => d.angle)\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', (d) => (d.angle < Math.PI / 2 ? 6 : -6))\n      .attr('text-anchor', (d) => (d.angle < Math.PI / 2 ? 'start' : 'end'))\n      .text((d) => d.token)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-side-arrow').select('path').attr('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .filter((dd) => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-side-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-side-arrow').select('path').attr('opacity', null);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-side-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', (d) => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Draw the links as bezier curves\n    donut\n      .append('g')\n      .attr('class', 'path-group')\n      .selectAll('path.donut-link')\n      .data(links, (d) => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('marker-end', 'url(#atlas-side-arrow)')\n      .attr('d', (d) => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = { x: 0, y: 0 };\n        const radialCurveAlpha = 2 / 5;\n\n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha,\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha,\n        };\n\n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('stroke-width', (d) => linkWidthScale(d.attention))\n      .style('opacity', (d) => linkOpacityScale(d.attention));\n\n    // Draw the circles\n    donut\n      .append('g')\n      .attr('class', 'token-dot-group')\n      .selectAll('circle.token-dot')\n      .data(tokenPos, (d) => d.id)\n      .join('circle')\n      .attr('class', 'token-dot')\n      .attr('cx', (d) => d.x)\n      .attr('cy', (d) => d.y)\n      .attr('r', 1);\n  };\n\n  const drawRadial = () => {\n    svg\n      .append('rect')\n      .attr('width', svgVirtualLength)\n      .attr('height', svgVirtualLength)\n      .style('fill', 'hsla(0, 0%, 100%, 0)');\n\n    donut = svg\n      .append('g')\n      .attr('class', 'donut')\n      .attr('transform', 'translate(250, 250)');\n\n    markerDef = svg\n      .append('defs')\n      .attr('id', 'atlas-side-arrow-def')\n      .append('marker')\n      .attr('id', 'atlas-side-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'gray')\n      .attr('fill', 'gray');\n\n    markerDef = svg\n      .append('defs')\n      .attr('id', 'atlas-side-arrow-def-hover')\n      .append('marker')\n      .attr('id', 'atlas-side-arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'hsl(24, 95%, 59%)')\n      .attr('fill', 'hsl(24, 95%, 59%)');\n\n    // drawDonut(donut);\n  };\n\n  onMount(() => {\n    // Bind drag event\n    let container = d3.select(modalComponent).select('.svg-container');\n\n    svg = container\n      .select('svg.side-svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', '100%')\n      .attr('height', '100%');\n\n    drawRadial();\n  });\n\n  const getColor = (layer, head) => {\n    if (\n      attentionHeadColor == null ||\n      attentionHeadColor.has === undefined ||\n      !attentionHeadColor.has([layer, head].toString())\n    ) {\n      return 'black';\n    } else {\n      return attentionHeadColor.get([layer, head].toString());\n    }\n  };\n</script>\n\n<style lang=\"scss\">.atlas-side {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n\n.side-svg {\n  width: 100%;\n  height: 100%;\n}\n\n.side-title {\n  font-size: 1.3em;\n  cursor: default;\n  pointer-events: none;\n}</style>\n\n<div class=\"atlas-side\" bind:this={modalComponent}>\n  <div\n    class=\"side-title\"\n    style={`color: ${getColor(modalInfo.layer, modalInfo.head)}`}\n  >\n    Layer {modalInfo.layer + 1} Head {modalInfo.head + 1}\n  </div>\n\n  <div class=\"svg-container\">\n    <svg class=\"side-svg\" />\n  </div>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = { top: 3, left: 3, right: 3, bottom: 3 };\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n  };\n\n  let forceStrength = { manyBody: 0, attention: 0, textOrder: 0 };\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const createCircleLayout = (nodes, center, radius) => {\n    let nodeIndexArray = nodes.map((d) => +d.id);\n\n    // Create a scale to map index to radial\n    let extent = d3.extent(nodeIndexArray);\n\n    // Need to add an extra index to play around 0 = 2 * PI overlapping\n    extent[1] += 1;\n\n    let radialScale = d3\n      .scaleLinear()\n      .domain(extent)\n      .range([Math.PI, -Math.PI]);\n\n    // Add position to the node objects\n    nodes.forEach((d) => {\n      let alpha = radialScale(d.id);\n      d.x = round(center.x + radius * Math.sin(alpha), 2);\n      d.y = round(center.y + radius * Math.cos(alpha), 2);\n      d.headX = round(\n        center.x + (radius - minNodeRadius * 1.1) * Math.sin(alpha),\n        2\n      );\n      d.headY = round(\n        center.x + (radius - minNodeRadius * 1.1) * Math.cos(alpha),\n        2\n      );\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3\n      .select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter((d) => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map((d) => Object.create(d));\n    links = links.map((d) => Object.create(d));\n\n    // Calculate the node positions\n    createCircleLayout(\n      nodes,\n      { x: SVGWidth / 2, y: SVGHeight / 2 },\n      SVGWidth / 2 - minNodeRadius - SVGPadding.left\n    );\n\n    // Create links\n    let nodeByID = new Map(nodes.map((d) => [d.id, d]));\n    let bilinks = [];\n\n    links.forEach((d) => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n\n      bilinks.push({\n        source: source,\n        target: target,\n        selfLoop: source === target,\n      });\n    });\n\n    // console.log(bilinks);\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach((d) => nodeIndices.add(+d.id));\n\n    createCircleLayout(\n      nodes,\n      { x: SVGWidth / 2, y: SVGHeight / 2 },\n      SVGWidth / 2 - minNodeRadius - SVGPadding.left\n    );\n\n    // console.log(nodes);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg\n      .append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    const drawLines = (d) => {\n      return `M ${d.source.headX} ${d.source.headY} L ${d.target.headX} ${d.target.headY}`;\n    };\n\n    const bezierCurveFunc = (d) => {\n      let center = { x: SVGWidth / 2, y: SVGHeight / 2 };\n      let controlAlpha = 4 / 5;\n\n      // Two control points symmetric regarding the center point\n      let controlP1 = {\n        x: center.x + (d.source.headX - center.x) * controlAlpha,\n        y: center.y + (d.source.headY - center.x) * controlAlpha,\n      };\n\n      let controlP2 = {\n        x: center.x + (d.target.headX - center.x) * controlAlpha,\n        y: center.y + (d.target.headY - center.x) * controlAlpha,\n      };\n\n      return `M ${d.source.headX},${d.source.headY} C${controlP1.x}, ${controlP1.y},\n       ${controlP2.x}, ${controlP2.y}, ${d.target.headX},${d.target.headY}`;\n    };\n\n    // Draw edges\n    let linkLines = svg\n      .append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('d', bezierCurveFunc)\n      //.attr('d', drawLines)\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg\n      .append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      .data(nodes)\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', (d) => `translate(${d.x}, ${d.y})`);\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3\n      .scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n\n    nodeGroups\n      .append('circle')\n      .attr('class', 'node-circle')\n      .attr('r', minNodeRadius)\n      .style('fill', (d) => colorScale(d.id));\n\n    // Add token text to each node\n    nodeGroups\n      .append('text')\n      .attr('class', 'node-text')\n      .text((d) => d.token);\n\n    nodeGroups.append('title').text((d) => d.token);\n\n    // Register UI elements from the control panel\n    // bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    // bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    // bindSlider('manyBody', simulation, -1000, 0, initManyBodyStrength);\n\n    // bindCheckBox(simulation, links);\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style lang=\"scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n  opacity: 0.5;\n}</style>\n\n<div class=\"graph-view\">\n  <div class=\"control-panel\">\n    <!-- Sliders -->\n    <div class=\"slider\">\n      <label for=\"attention\"\n        >Attention Strength [{config.autoAttention\n          ? 'auto'\n          : round(forceStrength.attention, 2)}]\n      </label>\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"attention\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"textOrder\"\n        >Text Order Strength [{round(forceStrength.textOrder, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"textOrder\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"manyBody\"\n        >ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"manyBody\"\n      />\n    </div>\n\n    <!-- Checkboxes -->\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\" />\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\" />\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\" />\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-border\" />\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <svg class=\"graph-svg\" bind:this={graphSVG} />\n  </div>\n</div>\n",
    "<script>\n  import {\n    graphViewConfigStore,\n    hoverTokenStore,\n    wordToSubwordMapStore,\n    instanceIDStore,\n    mapHeadStore,\n  } from './store';\n  import * as d3 from 'd3';\n  import { onMount } from 'svelte';\n\n  export let attentionDataDir;\n  export let saliencyDataFilepath;\n\n  // Shared states\n  let graphViewCompConfig = undefined;\n  let instanceID = 1562;\n  let curLayer = 9;\n  let curHead = 8;\n  let mapHead = { layer: 9, head: 8 };\n\n  let graphSVG = null;\n  let graphData = null;\n  let saliencyData = null;\n  let wordToSubwordMap = null;\n\n  let SVGWidth = undefined;\n  let SVGHeight = undefined;\n\n  let curHoverToken = null;\n\n  // View configs\n  const SVGPadding = { top: 3, left: 3, right: 3, bottom: 3 };\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  // const minNodeRadius = 10;\n  // const maxNodeRadius = 20;\n\n  const radialRadius = 225;\n  const radialCurveAlpha = 0.3;\n\n  const gridRowSize = 8;\n  const gridRowGap = 35;\n  const gridColumnGap = 35;\n\n  // Graph vis variables\n  let tokenSize = null;\n  let originalNodes = null;\n\n  let curLinkI = 1;\n  let weightThresholdMin = 0.02;\n  let weightThresholdMax = 0.1;\n  let weightThresholdSteps = 6;\n  let weightThresholdGap =\n    (weightThresholdMax - weightThresholdMin) / (weightThresholdSteps - 1);\n  let weightThreshold = weightThresholdMin + weightThresholdGap * curLinkI;\n\n  let linkArrays = {};\n  let simulation = null;\n  let intermediateNodeMap = new Map();\n  let linkWidth = null;\n\n  let linkColor = 'hsl(0, 0%, 76%)';\n  let linkHoverColor = 'hsl(36, 100%, 55%)';\n  let nodeRadiusScale = null;\n  // linkHoverColor = 'hsl(174, 65%, 48%)';\n\n  // Control panel variables\n  let settingIconActive = false;\n\n  // Data\n  let mounted = false;\n  let attentionData = null;\n\n  const ease = d3.easeCubicInOut;\n  const animationTime = 300;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout',\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout',\n    },\n    grid: {\n      value: 'grid',\n      name: 'Grid Layout',\n    },\n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.radial,\n  };\n\n  let forceStrength = {\n    force: {\n      manyBody: -840,\n      attention: 0.5,\n      textOrder: 1.6,\n      collideRadius: 1,\n    },\n    radial: {\n      textOrder: 0.5,\n      radial: 1,\n    },\n    grid: {\n      collideRadius: 7,\n    },\n  };\n\n  let currentLayout = config.defaultLayout;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const drag = () => {\n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n\n      // Add a marker to indicate that the node is fixed\n      d3.select(event.sourceEvent.originalTarget.parentNode)\n        .append('rect')\n        .attr('class', 'fixed-marker')\n        .attr('x', -3)\n        .attr('y', 6)\n        .attr('width', 6)\n        .attr('height', 5)\n        .style('fill', 'white');\n    };\n\n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n\n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      // event.subject.fx = null;\n      // event.subject.fy = null;\n    };\n\n    return d3\n      .drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (!d.hidden) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGHeight - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(\n      SVGPadding.left + curRadius,\n      Math.min(width - curRadius, d.x)\n    );\n    const top = Math.max(\n      SVGPadding.top + curRadius,\n      Math.min(height - curRadius, d.y)\n    );\n\n    if (config.borderConstraint) {\n      return { top: top, left: left };\n    } else {\n      return { top: d.y, left: d.x };\n    }\n  };\n\n  const bindSlider = (name, min, max, defaultValue, nodeRadiusScale = null) => {\n    let slider = d3\n      .select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      let step = sliderValue / 200;\n      forceStrength.force[name] = value;\n\n      switch (name) {\n        case 'attention':\n          simulation.force('attentionLink').strength(value);\n          // Disable the auto attention\n          d3.select('#checkbox-auto-attention').property('checked', false);\n          config.autoAttention = false;\n          break;\n        case 'textOrder':\n          simulation\n            .force('textLink')\n            .strength((d) => (d.target.index === 0 ? 0 : value));\n          break;\n        case 'manyBody':\n          simulation.force('charge').strength(value);\n          break;\n        case 'collideRadius':\n          simulation\n            .force('collide')\n            .radius((d) => nodeRadiusScale(d.saliency) + value);\n          break;\n        case 'threshold':\n          weightThreshold = weightThresholdMin + step * weightThresholdGap;\n          weightThresholdUpdated(step, nodeRadiusScale);\n          break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const resetSimulation = () => {\n    simulation.force('collide', null);\n    simulation.force('attentionLink', null);\n    simulation.force('charge', null);\n    simulation.force('center', null);\n    simulation.force('textLink', null);\n    simulation.force('hiddenTextLink', null);\n    simulation.force('posX', null);\n    simulation.force('posY', null);\n    simulation.force('grid', null);\n  };\n\n  const bindSelect = (nodeRadiusScale) => {\n    currentLayout = config.defaultLayout;\n    let selectOption = d3\n      .select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayoutValue = selectOption.property('value');\n\n      // Need to switch layout\n      if (newLayoutValue !== currentLayout.value) {\n        resetSimulation();\n\n        switch (newLayoutValue) {\n          case 'force':\n            currentLayout = layoutOptions.force;\n            initForceSim(nodeRadiusScale);\n            simulation.alpha(1).restart();\n            break;\n\n          case 'radial':\n            currentLayout = layoutOptions.radial;\n            initRadialSim();\n            simulation.alpha(1).restart();\n            break;\n\n          case 'grid':\n            currentLayout = layoutOptions.grid;\n            initGridSim();\n            simulation.alpha(1).restart();\n            break;\n        }\n\n        updateNodeRadius(nodeRadiusScale);\n      }\n      simulation.alpha(1).restart();\n    });\n  };\n\n  const bindLayerHeadSelect = () => {\n    let layerSelectOption = d3\n      .select('#select-layer')\n      .property('value', curLayer);\n\n    let headSelectOption = d3.select('#select-head').property('value', curHead);\n\n    layerSelectOption.on('change', () => {\n      let newLayerValue = layerSelectOption.property('value');\n\n      // Need to switch layout\n      if (newLayerValue !== curLayer) {\n        // console.log(newLayerValue);\n        curLayer = newLayerValue;\n        updateLayerHead();\n\n        mapHead.layer = +curLayer;\n        mapHead.head = +curHead;\n        mapHeadStore.set(mapHead);\n      }\n    });\n\n    headSelectOption.on('change', () => {\n      let newHeadValue = headSelectOption.property('value');\n\n      // Need to switch layout\n      if (newHeadValue !== curHead) {\n        // console.log(newHeadValue);\n        curHead = newHeadValue;\n        updateLayerHead();\n\n        mapHead.layer = +curLayer;\n        mapHead.head = +curHead;\n        mapHeadStore.set(mapHead);\n      }\n    });\n  };\n\n  mapHeadStore.subscribe((value) => {\n    mapHead = value;\n\n    if (mapHead.layer !== curLayer || mapHead.head !== curHead) {\n      // console.log('change');\n      d3.select('#select-layer').property('value', mapHead.layer);\n\n      d3.select('#select-head').property('value', mapHead.head);\n\n      curLayer = mapHead.layer;\n      curHead = mapHead.head;\n\n      updateLayerHead();\n    }\n  });\n\n  const updateNodeRadius = (nodeRadiusScale) => {\n    d3.select(graphSVG)\n      .select('g.node-group')\n      .selectAll('circle')\n      .transition('node-radius')\n      .duration(animationTime)\n      .ease(ease)\n      .attr('r', (d) =>\n        currentLayout.value === 'force'\n          ? nodeRadiusScale(+d.saliency)\n          : minNodeRadius\n      );\n  };\n\n  const initForceSim = (nodeRadiusScale) => {\n    // Force 1 (ManyBody force)\n    simulation.force(\n      'charge',\n      d3.forceManyBody().strength(forceStrength.force.manyBody)\n    );\n\n    // Force 2 (Center force)\n    simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // Force 3 (Link force)\n    simulation.force(\n      'attentionLink',\n      d3.forceLink(linkArrays[curLinkI].links).id((d) => d.id)\n    );\n\n    // Force 4 (Text order link force)\n    simulation.force(\n      'textLink',\n      d3\n        .forceLink(linkArrays[curLinkI].hiddenLinks)\n        .id((d) => d.id)\n        .strength((d) =>\n          d.target.index === 0 ? 0 : forceStrength.force.textOrder\n        )\n    );\n\n    // Force 5 (Collide force)\n    simulation.force(\n      'collide',\n      d3\n        .forceCollide()\n        .radius(\n          (d) => nodeRadiusScale(d.saliency) + forceStrength.force.collideRadius\n        )\n    );\n  };\n\n  const initRadialSim = () => {\n    // Force 1 (Tex order link force)\n    simulation.force(\n      'textLink',\n      d3\n        .forceLink(linkArrays[curLinkI].hiddenLinks)\n        .id((d) => d.id)\n        .strength(forceStrength.radial.textOrder)\n    );\n\n    // Force 2 (Custom radial force)\n    simulation.force(\n      'posY',\n      d3\n        .forceY()\n        .y((d, i) => {\n          let curLen = originalNodes.filter((d) => !d.hidden).length;\n          let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / curLen);\n          return SVGHeight / 2 + Math.sin(curAngle) * radialRadius;\n        })\n        .strength(forceStrength.radial.radial)\n    );\n\n    simulation.force(\n      'posX',\n      d3\n        .forceX()\n        .x((d, i) => {\n          let curLen = originalNodes.filter((d) => !d.hidden).length;\n          let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / curLen);\n          return SVGWidth / 2 + Math.cos(curAngle) * radialRadius;\n        })\n        .strength(forceStrength.radial.radial)\n    );\n  };\n\n  const initGridSim = () => {\n    let curGridRowSize = gridRowSize;\n    let gridColumnSize = Math.ceil(tokenSize / curGridRowSize);\n\n    let rowLength =\n      gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;\n    let columnLength =\n      gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;\n\n    // Check if we need to increase the row size\n    while (columnLength > SVGHeight) {\n      curGridRowSize = gridRowSize + 1;\n      rowLength =\n        gridRowSize * 2 * minNodeRadius + (gridRowSize - 1) * gridColumnGap;\n      columnLength =\n        gridColumnSize * 2 * minNodeRadius + (gridColumnSize - 1) * gridRowGap;\n\n      if (rowLength > SVGWidth) {\n        console.log('Failed to initialize grid layout');\n        break;\n      }\n    }\n\n    let xs = Math.floor((SVGWidth - rowLength) / 2);\n    let ys = Math.floor((SVGHeight - columnLength) / 2);\n\n    // Force 3 (Grid force)\n    simulation.force(\n      'grid',\n      d3\n        .forceLink(linkArrays[curLinkI].gridLinks)\n        .iterations(80)\n        .distance(50)\n        .id((d) => d.id)\n    );\n\n    // Force 4 (Orientation force)\n    simulation.force(\n      'posX',\n      d3\n        .forceX()\n        .x(\n          (d, i) =>\n            xs +\n            (i % gridRowSize) * (2 * minNodeRadius + gridColumnGap) +\n            minNodeRadius\n        )\n        .strength((d) => (d.id === undefined ? 0 : 1))\n    );\n\n    simulation.force(\n      'posY',\n      d3\n        .forceY()\n        .y(\n          (d, i) =>\n            ys +\n            Math.floor(i / gridRowSize) * (2 * minNodeRadius + gridRowGap) +\n            minNodeRadius\n        )\n        .strength((d) => (d.id === undefined ? 0 : 1))\n    );\n  };\n\n  const initCurrentSim = (nodeRadiusScale) => {\n    switch (currentLayout.value) {\n      case 'force':\n        initForceSim(nodeRadiusScale);\n        break;\n      case 'radial':\n        initRadialSim();\n        break;\n      case 'grid':\n        initGridSim();\n        break;\n    }\n  };\n\n  const tickLinkForce = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    if (d.selfLoop) {\n      const iCoord = borderConstraint(d[2], nodeRadiusScale);\n\n      // Shorten the distance from source to intermediate point\n      let interLen =\n        Math.sqrt(\n          (tCoord.left - iCoord.left) ** 2 + (tCoord.top - iCoord.top) ** 2\n        ) - nodeRadiusScale(d[0].saliency);\n\n      iCoord.left = tCoord.left + ((iCoord.left - tCoord.left) / interLen) * 80;\n      iCoord.top = tCoord.top + ((iCoord.top - tCoord.top) / interLen) * 80;\n\n      // Need to handle the arc manually if there is a self loop\n      const iVec = [iCoord.left - sCoord.left, iCoord.top - sCoord.top];\n      const iVecNorm = Math.sqrt(iVec[0] ** 2 + iVec[1] ** 2);\n\n      // Rotate 90 degree\n      // Normalized the rotate direction, use alpha to control magnitude\n      const alpha = 50;\n      const iVecClock90 = [\n        (-iVec[1] / iVecNorm) * alpha,\n        (iVec[0] / iVecNorm) * alpha,\n      ];\n      const iVecCounterClock90 = [\n        (iVec[1] / iVecNorm) * alpha,\n        (-iVec[0] / iVecNorm) * alpha,\n      ];\n\n      const leftControl = [\n        sCoord.left + iVec[0] + iVecClock90[0],\n        sCoord.top + iVec[1] + iVecClock90[1],\n      ];\n      const rightControl = [\n        sCoord.left + iVec[0] + iVecCounterClock90[0],\n        sCoord.top + iVec[1] + iVecCounterClock90[1],\n      ];\n\n      // We need to shorten the path to leave space for arrow\n      let halfLen = Math.sqrt(\n        (tCoord.left - rightControl[0]) ** 2 +\n          (tCoord.top - rightControl[1]) ** 2\n      );\n      let theta = (nodeRadiusScale(d[0].saliency) + 10) / halfLen;\n      let modTCoord = {\n        left: tCoord.left + (rightControl[0] - tCoord.left) * theta,\n        top: tCoord.top + (rightControl[1] - tCoord.top) * theta,\n      };\n\n      // Draw a bezier curve with two control points (which are left and right\n      // perpendicular to the self loop node -> intermediate node vector)\n      return (\n        'M' +\n        sCoord.left +\n        ',' +\n        sCoord.top +\n        'C' +\n        leftControl[0] +\n        ',' +\n        leftControl[1] +\n        ' ' +\n        rightControl[0] +\n        ',' +\n        rightControl[1] +\n        ' ' +\n        modTCoord.left +\n        ',' +\n        modTCoord.top\n      );\n    } else {\n      // We need to shorten the path to leave space for arrow\n      let vecLen = Math.sqrt(\n        (tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2\n      );\n      let theta = (nodeRadiusScale(d[1].saliency) + 10) / vecLen;\n      let modTCoord = {\n        left: tCoord.left + (sCoord.left - tCoord.left) * theta,\n        top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n      };\n      return (\n        'M' +\n        sCoord.left +\n        ',' +\n        sCoord.top +\n        'L' +\n        modTCoord.left +\n        ',' +\n        modTCoord.top\n      );\n    }\n  };\n\n  const tickNodeForce = (d, nodeRadiusScale) => {\n    // Maker sure the nodes are inside the box\n    const coord = borderConstraint(d, nodeRadiusScale);\n    return `translate(${coord.left}, ${coord.top})`;\n  };\n\n  const tickLinkRadial = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    let source = { x: sCoord.left, y: sCoord.top };\n    let target = { x: tCoord.left, y: tCoord.top };\n    let center = { x: SVGWidth / 2, y: SVGHeight / 2 + 40 };\n\n    // We need to shorten the path to leave space for arrow\n    let theta = 1 - (minNodeRadius + 10) / radialRadius;\n    let modTarget = {\n      x: center.x + (target.x - center.x) * theta,\n      y: center.y + (target.y - center.y) * theta,\n    };\n\n    let modSource = {\n      x: center.x + (source.x - center.x) * theta,\n      y: center.y + (source.y - center.y) * theta,\n    };\n\n    // Two control points symmetric regarding the center point\n    let controlP1 = {\n      x: center.x + (modSource.x - center.x) * radialCurveAlpha,\n      y: center.y + (modSource.y - center.x) * radialCurveAlpha,\n    };\n\n    let controlP2 = {\n      x: center.x + (modTarget.x - center.x) * radialCurveAlpha,\n      y: center.y + (modTarget.y - center.x) * radialCurveAlpha,\n    };\n\n    return `M ${modSource.x},${modSource.y} C${controlP1.x}, ${controlP1.y},\n      ${controlP2.x}, ${controlP2.y}, ${modTarget.x},${modTarget.y}`;\n  };\n\n  const tickLinkGrid = (d, nodeRadiusScale) => {\n    const sCoord = borderConstraint(d[0], nodeRadiusScale);\n    const tCoord = borderConstraint(d[1], nodeRadiusScale);\n\n    // We need to shorten the path to leave space for arrow\n    let halfLen = Math.sqrt(\n      (tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2\n    );\n\n    let theta = (minNodeRadius + 10) / halfLen;\n    let modTCoord = {\n      left: tCoord.left + (sCoord.left - tCoord.left) * theta,\n      top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n    };\n\n    return (\n      'M' +\n      sCoord.left +\n      ',' +\n      sCoord.top +\n      'L' +\n      modTCoord.left +\n      ',' +\n      modTCoord.top\n    );\n  };\n\n  const weightThresholdUpdated = (step) => {\n    curLinkI = step;\n\n    // Update the svg\n    let linkLines = d3\n      .select(graphSVG)\n      .select('g.attention-link-group')\n      .selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`);\n\n    // Enter\n    linkLines\n      .enter()\n      .append('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link')\n      .attr('id', (d) => `link-${d[0].id}-${d[1].id}`)\n      .style('stroke', 'hsl(150, 74%, 51%)')\n      .style('stroke-width', (d) => linkWidth(d.attention))\n      .transition()\n      .duration(animationTime * 3)\n      .ease(ease)\n      .style('stroke', linkColor);\n\n    // Exit\n    linkLines\n      .exit()\n      .style('stroke', 'hsl(349, 81%, 57%)')\n      .transition()\n      .duration(animationTime * 3)\n      .ease(ease)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        d3.select(g[i]).remove();\n      });\n\n    // Update the simulation\n    simulation.nodes(linkArrays[curLinkI].nodes);\n    simulation.alpha(1).restart();\n  };\n\n  // Create related link arrays (hiddenLinks, biLinks, and gridLinks)\n  const createGraphLinks = (curLinks, nodeByID, nodeIndexArray) => {\n    curLinks = curLinks.map((d) => Object.create(d));\n    let curNodes = originalNodes.slice();\n\n    // Add text order hidden links\n    let curHiddenLinks = [];\n    for (let i = 0; i < curNodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +curNodes[i].id,\n        target: +curNodes[i + 1].id,\n      };\n      curHiddenLinks.push(hiddenLink);\n    }\n\n    // Add a connection between the first and last token\n    curHiddenLinks.push({\n      source: +curNodes[curNodes.length - 1].id,\n      target: curNodes[0].id,\n    });\n\n    curHiddenLinks = curHiddenLinks.map((d) => Object.create(d));\n\n    // Add intermediate nodes to create bezier curves\n    let curBiLinks = [];\n\n    curLinks.forEach((d) => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let curBilink = [source, target];\n      curBilink.selfLoop = false;\n      curBilink.attention = +d.weight;\n\n      // Add a hidden node if there is a self-loop\n      if (source === target) {\n        curBilink.selfLoop = true;\n\n        // We cannot keep creating new intermediate nodes (need to be the same\n        // object for each source across different threshold)\n        let intermediate = { hidden: true };\n\n        if (intermediateNodeMap.has(source)) {\n          intermediate = intermediateNodeMap.get(source);\n        } else {\n          intermediateNodeMap.set(source, intermediate);\n        }\n\n        curBilink.push(intermediate);\n        curNodes.push(intermediate);\n        curLinks.push({ source: intermediate, target: source });\n      }\n\n      curBiLinks.push(curBilink);\n    });\n\n    // Create grid links\n    let curGridLinks = [];\n    nodeIndexArray.sort((a, b) => +a - +b);\n    for (let i = 0; i < curNodes.length; i++) {\n      if ((i % gridRowSize !== gridRowSize - 1) & nodeByID.has(i + 1)) {\n        curGridLinks.push({\n          source: nodeByID.get(i),\n          target: nodeByID.get(i + 1),\n        });\n      }\n      if (nodeByID.has(i + gridRowSize)) {\n        curGridLinks.push({\n          source: nodeByID.get(i),\n          target: nodeByID.get(i + gridRowSize),\n        });\n      }\n    }\n\n    return {\n      links: curLinks,\n      hiddenLinks: curHiddenLinks,\n      biLinks: curBiLinks,\n      gridLinks: curGridLinks,\n      nodes: curNodes,\n    };\n  };\n\n  const graphNodeDoubleClickHandler = (\n    e,\n    nodeGroup,\n    linkLineGroup,\n    nodeIndexArray,\n    nodeIndices,\n    nodeRadiusScale,\n    nodeByID,\n    simulation\n  ) => {\n    let curNode = d3.select(e.target);\n    let curID = curNode.data()[0].id;\n\n    // Delete the node from the nodes array\n    for (let i = linkArrays[curLinkI].nodes.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].nodes[i].id === curID) {\n        linkArrays[curLinkI].nodes.splice(i, 1);\n      }\n    }\n\n    // Remove the node element on screen\n    nodeGroup\n      .selectAll('g.node')\n      .data(\n        linkArrays[curLinkI].nodes.filter((d) => d.id !== undefined),\n        (d) => d.id\n      )\n      .exit()\n      .remove();\n\n    // Delete all links connecting to this node\n    for (let i = linkArrays[curLinkI].biLinks.length - 1; i >= 0; i--) {\n      if (\n        (linkArrays[curLinkI].biLinks[i][0].id === curID) |\n        (linkArrays[curLinkI].biLinks[i][1].id === curID)\n      ) {\n        linkArrays[curLinkI].biLinks.splice(i, 1);\n      }\n    }\n\n    // Delete all attention links connecting to this node\n    for (let i = linkArrays[curLinkI].links.length - 1; i >= 0; i--) {\n      if (\n        (linkArrays[curLinkI].links[i].source.id === curID) |\n        (linkArrays[curLinkI].links[i].target.id === curID)\n      ) {\n        linkArrays[curLinkI].links.splice(i, 1);\n      }\n    }\n\n    // Rewire the text order link array\n    for (let i = linkArrays[curLinkI].hiddenLinks.length - 1; i >= 0; i--) {\n      if (linkArrays[curLinkI].hiddenLinks[i].source.id === curID) {\n        linkArrays[curLinkI].hiddenLinks.splice(i, 1);\n      } else if (linkArrays[curLinkI].hiddenLinks[i].target.id === curID) {\n        if (i + 1 < linkArrays[curLinkI].hiddenLinks.length) {\n          linkArrays[curLinkI].hiddenLinks[i].target =\n            linkArrays[curLinkI].hiddenLinks[i + 1].source;\n        } else {\n          linkArrays[curLinkI].hiddenLinks[i].target =\n            linkArrays[curLinkI].hiddenLinks[0].source;\n        }\n      }\n    }\n\n    // Need to reconstruct the grid links\n    linkArrays[curLinkI].gridLinks = [];\n    nodeIndices = new Set();\n    linkArrays[curLinkI].nodes.forEach((d) => {\n      if (d.id !== undefined) nodeIndices.add(+d.id);\n    });\n    nodeIndexArray = Array.from(nodeIndices);\n    nodeIndexArray.sort((a, b) => +a - +b);\n\n    for (let i = 0; i < nodeIndexArray.length - 1; i++) {\n      let curI = nodeIndexArray[i];\n      if (\n        (i % gridRowSize !== gridRowSize - 1) &\n        nodeByID.has(nodeIndexArray[i + 1])\n      ) {\n        linkArrays[curLinkI].gridLinks.push({\n          source: nodeByID.get(curI),\n          target: nodeByID.get(nodeIndexArray[i + 1]),\n        });\n      }\n      if (nodeByID.has(nodeIndexArray[i + gridRowSize])) {\n        linkArrays[curLinkI].gridLinks.push({\n          source: nodeByID.get(curI),\n          target: nodeByID.get(nodeIndexArray[i + gridRowSize]),\n        });\n      }\n    }\n\n    linkLineGroup\n      .selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`)\n      .exit()\n      .remove();\n\n    initCurrentSim(nodeRadiusScale);\n    simulation.alpha(0.3).restart();\n  };\n\n  const simulationTick = (nodeRadiusScale) => {\n    // console.log('Tick');\n\n    let linkLines = d3\n      .select(graphSVG)\n      .select('g.attention-link-group')\n      .selectAll('path.link');\n\n    // Update the attention links\n    switch (currentLayout.value) {\n      case 'force':\n        linkLines.attr('d', (d) => tickLinkForce(d, nodeRadiusScale));\n        break;\n      case 'radial':\n        linkLines.attr('d', (d) => tickLinkRadial(d, nodeRadiusScale));\n        break;\n      case 'grid':\n        linkLines.attr('d', (d) => tickLinkGrid(d, nodeRadiusScale));\n        break;\n      default:\n        console.log('Unexpected case.');\n    }\n\n    // Update the nodes\n    d3.select(graphSVG)\n      .select('g.node-group')\n      .selectAll('g.node')\n      .attr('transform', (d) => tickNodeForce(d, nodeRadiusScale));\n  };\n\n  const drawSaliencyLegend = (\n    legendGroup,\n    legendPos,\n    largestAbs,\n    leftColor = '#eb2f06',\n    rightColor = '#4690C2'\n  ) => {\n    // Define the gradient\n    let legendGradientDef = legendGroup\n      .append('defs')\n      .append('linearGradient')\n      .attr('x1', 0)\n      .attr('y1', 1)\n      .attr('x2', 0)\n      .attr('y2', 0)\n      .attr('id', 'legend-gradient-graph');\n\n    legendGradientDef\n      .append('stop')\n      .attr('stop-color', leftColor)\n      .attr('offset', 0);\n\n    legendGradientDef\n      .append('stop')\n      .attr('stop-color', rightColor)\n      .attr('offset', 1);\n\n    legendGroup\n      .append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', legendPos.width)\n      .attr('height', legendPos.height)\n      .style('fill', 'url(#legend-gradient-graph)')\n      .style('stroke', 'black');\n\n    // Draw the legend axis\n    let legendScale = d3\n      .scaleLinear()\n      .domain([0, largestAbs])\n      .range([legendPos.height, 0])\n      .nice();\n\n    legendGroup\n      .append('g')\n      .attr('transform', `translate(${legendPos.width}, ${0})`)\n      .call(d3.axisRight(legendScale).ticks(5));\n\n    legendGroup\n      .append('text')\n      .attr('x', 0)\n      .attr('y', legendPos.height + 8)\n      .style('font-size', '12px')\n      .style('fill', 'hsl(0, 0%, 40%)')\n      .style('dominant-baseline', 'hanging')\n      .style('text-anchor', 'left')\n      .text('Semantic Saliency Score');\n  };\n\n  const initGraph = () => {\n    let svg = d3.select(graphSVG);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map((d) => Object.create(d));\n    nodes.sort((a, b) => +a.id - +b.id);\n\n    // Give each saliency token a unique name\n    let tokenCount = {};\n    nodes.forEach((d) => {\n      let curCount = 0;\n      if (tokenCount[d.token] === undefined) {\n        tokenCount[d.token] = curCount + 1;\n      } else {\n        curCount = tokenCount[d.token];\n        tokenCount[d.token] += 1;\n      }\n      d.name = `${tokenIDName(d.token)}-${curCount}`;\n    });\n\n    originalNodes = nodes.slice();\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach((d) => nodeIndices.add(+d.id));\n    let nodeIndexArray = Array.from(nodeIndices);\n\n    let nodeByID = new Map(nodes.map((d) => [d.id, d]));\n\n    // Create link arrays at different range steps\n    linkArrays = {};\n    for (let i = 0; i < weightThresholdSteps; i++) {\n      let curWeightThreshold = round(\n        weightThresholdMin + i * weightThresholdGap,\n        2\n      );\n      let links = graphData.links.filter((d) => d.weight > curWeightThreshold);\n      let linkResult = createGraphLinks(links, nodeByID, nodeIndexArray);\n\n      linkArrays[i] = {\n        links: linkResult.links.slice(),\n        hiddenLinks: linkResult.hiddenLinks.slice(),\n        biLinks: linkResult.biLinks.slice(),\n        gridLinks: linkResult.gridLinks.slice(),\n        nodes: linkResult.nodes.slice(),\n      };\n    }\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map((d) => +d.saliency);\n    // console.log(d3.extent(allSaliencyScores));\n    nodeRadiusScale = d3\n      .scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .unknown(0)\n      .nice();\n\n    // Create a scale for the node color\n    let largestAbs = d3.max(allSaliencyScores.map(Math.abs));\n    let rightColor = '#E50035';\n    let leftColor = '#ffffff';\n\n    let nodeSaliencyColorScale = d3\n      .scaleLinear()\n      .domain([0, largestAbs])\n      .range([d3.rgb(leftColor), d3.rgb(rightColor)])\n      .unknown(d3.rgb('white'));\n\n    // Create a scale for link stroke width\n    let attentionWeights = linkArrays[0].links.map((d) => +d.weight);\n    linkWidth = d3\n      .scaleLinear()\n      .domain(d3.extent(attentionWeights))\n      .range([0.5, 3])\n      .nice();\n\n    // Add attention links\n    let linkLineGroup = svg\n      .append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', linkColor);\n\n    linkLineGroup\n      .selectAll('path.link')\n      .data(linkArrays[curLinkI].biLinks, (d) => `${d[0].id}-${d[1].id}`)\n      .join('path')\n      .attr('class', 'link')\n      .attr('id', (d) => `link-${d[0].name}-${d[1].name}`)\n      .attr('marker-end', 'url(#arrow)')\n      .style('stroke-width', (d) => linkWidth(d.attention));\n\n    // Add token nodes\n    let nodeGroup = svg.append('g').attr('class', 'node-group');\n\n    let nodeGroups = nodeGroup\n      .selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(\n        linkArrays[curLinkI].nodes.filter((d) => d.id !== undefined),\n        (d) => d.id\n      )\n      .join('g')\n      .attr('class', 'node')\n      .attr('id', (d) => `node-${d.name}`)\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag())\n      // Hover over effect\n      .on('mouseover', (e, d) => {\n        curHoverToken = d.name;\n        hoverTokenStore.set(curHoverToken);\n        highLightLink(curHoverToken);\n      })\n      .on('mouseleave', () => {\n        dehighlightLink(curHoverToken);\n        curHoverToken = null;\n        hoverTokenStore.set(curHoverToken);\n      })\n      // Single click to remove fixing\n      .on('click', (e, d) => {\n        if (d.fx !== null && d.fy !== null) {\n          // Unfix the node\n          delete d.fx;\n          delete d.fy;\n\n          // Remove the fixing marker\n          d3.select(e.target.parentNode)\n            .selectAll('rect.fixed-marker')\n            .remove();\n\n          simulation.alpha(0.2).restart();\n        }\n      })\n      // Double click to remove the node\n      .on('dblclick', (e) =>\n        graphNodeDoubleClickHandler(\n          e,\n          nodeGroup,\n          linkLineGroup,\n          nodeIndexArray,\n          nodeIndices,\n          nodeRadiusScale,\n          nodeByID,\n          simulation\n        )\n      );\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3\n      .scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n\n    nodeGroups\n      .append('circle')\n      .attr('class', 'node-circle')\n      .attr('r', (d) =>\n        currentLayout.value === 'force'\n          ? nodeRadiusScale(+d.saliency)\n          : minNodeRadius\n      )\n      // .style('fill', d => colorScale(d.id))\n      .style('fill', (d) => nodeSaliencyColorScale(+d.saliency))\n      .style('opacity', 1)\n      .clone(true)\n      .attr('r', (d) =>\n        currentLayout.value === 'force'\n          ? nodeRadiusScale(+d.saliency)\n          : minNodeRadius\n      )\n      .style('fill', linkHoverColor)\n      .attr('class', 'shadow-circle');\n\n    // Create legend for the saliency map view\n    let legendGroup = svg\n      .append('g')\n      .attr('class', 'legend-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left + 3}, ${SVGHeight - 130})`\n      );\n\n    let legendPos = { width: 10, height: 100 };\n\n    drawSaliencyLegend(\n      legendGroup,\n      legendPos,\n      largestAbs,\n      leftColor,\n      rightColor\n    );\n\n    // Add token text to each node\n    let texts = nodeGroups\n      .append('text')\n      .attr('class', 'node-text')\n      .style('font-weight', 600)\n      .text((d) => d.token);\n\n    texts\n      .filter((d) => d3.hcl(nodeSaliencyColorScale(+d.saliency)).l < 66)\n      .clone(true)\n      .lower()\n      .style('stroke-linejoin', 'round')\n      .attr('stroke-width', 4)\n      .attr('stroke', 'white');\n\n    nodeGroups.selectAll('circle').lower();\n\n    nodeGroups.append('title').text((d) => d.token);\n\n    // Define the force\n    // Use the min threshold to init the simulation (it includes the most hidden nodes)\n    if (simulation == null) {\n      simulation = d3.forceSimulation(linkArrays[curLinkI].nodes);\n      // Change the min alpha so that the nodes do not shake at the end (end earlier)\n      // The default alphaMin is 0.000\n      // simulation.alphaMin(0.001);\n    } else {\n      simulation.nodes(linkArrays[curLinkI].nodes);\n      simulation.alpha(1).restart();\n    }\n\n    switch (currentLayout.value) {\n      case 'force':\n        initForceSim(nodeRadiusScale);\n        break;\n      case 'radial':\n        initRadialSim();\n        break;\n      case 'grid':\n        initGridSim();\n        break;\n    }\n\n    // Simulation tick updates\n    simulation.on('tick', () => simulationTick(nodeRadiusScale));\n\n    return nodeRadiusScale;\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    // weightThreshold = 0.05;\n\n    let svg = d3\n      .select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Add arrow markers\n    svg\n      .append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkColor)\n      .attr('fill', linkColor);\n\n    // Create a different arrow marked used when user hovers over a node\n    svg\n      .append('defs')\n      .append('marker')\n      .attr('id', 'arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkHoverColor)\n      .attr('fill', linkHoverColor);\n\n    nodeRadiusScale = initGraph();\n\n    // Register UI elements from the control panel\n    bindSlider('attention', 0, 10, forceStrength.force.attention);\n    bindSlider('textOrder', 0, 10, forceStrength.force.textOrder);\n    bindSlider('manyBody', -2000, 0, forceStrength.force.manyBody);\n    bindSlider(\n      'collideRadius',\n      0,\n      20,\n      forceStrength.force.collideRadius,\n      nodeRadiusScale\n    );\n    bindSlider(\n      'threshold',\n      weightThresholdMin,\n      weightThresholdMax,\n      weightThreshold,\n      nodeRadiusScale\n    );\n\n    bindSelect(nodeRadiusScale);\n\n    // Bind the layer and head selects\n    bindLayerHeadSelect();\n  };\n\n  const updateLayerHead = () => {\n    // Remove nodes and links\n    d3.select(graphSVG).select('g.node-group').remove();\n\n    d3.select(graphSVG).select('g.attention-link-group').remove();\n\n    d3.select(graphSVG).select('g.legend-group').remove();\n\n    // Update the graph data\n    graphData = createGraphData(curLayer, curHead);\n\n    initGraph();\n  };\n\n  /** Create CSS selector compatible name */\n  const tokenIDName = (tokenID) => {\n    if (tokenID == null) {\n      return null;\n    } else {\n      return tokenID\n        .replace(/\\./g, '\\\\.')\n        .replace(/,/g, '\\\\,')\n        .replace(/#/g, '')\n        .replace(/\\[/g, '\\\\[')\n        .replace(/\\]/g, '\\\\]');\n    }\n  };\n\n  const highLightLink = (hoverToken) => {\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      // TODO\n      // .style('opacity', 0.05);\n      .style('opacity', 0.2);\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)\n      )\n      .attr('marker-end', 'url(#arrow-hover)')\n      .classed('highlighted', true)\n      .style('stroke', null)\n      .style('stroke-width', 2)\n      .style('opacity', 0.8)\n      .raise();\n    // TODO\n    // .style('opacity', 0.9)\n    // .style('stroke-width', 2)\n    // .raise();\n\n    d3.select(graphSVG)\n      .select('.node-group')\n      .selectAll('.node')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)\n      )\n      .raise()\n      .select('.shadow-circle')\n      .attr('r', (d) =>\n        currentLayout.value === 'force'\n          ? nodeRadiusScale(+d.saliency) + 5\n          : minNodeRadius + 5\n      )\n      .style('stroke', 'white')\n      .style('stroke-width', 1.5);\n  };\n\n  const dehighlightLink = (hoverToken) => {\n    // TODO\n    // return;\n    // if (hoverToken.includes('jagged')) {\n    //   return;\n    // }\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .style('opacity', null);\n\n    d3.select(graphSVG)\n      .select('.attention-link-group')\n      .selectAll('path.link')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)\n      )\n      .classed('highlighted', false)\n      .attr('marker-end', 'url(#arrow)')\n      .style('stroke', linkColor)\n      .style('stroke-width', (d) => linkWidth(d.attention))\n      .style('opacity', null);\n\n    d3.select(graphSVG)\n      .select('.node-group')\n      .selectAll('.node')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('id').includes(`-${hoverToken}`)\n      )\n      .select('.shadow-circle')\n      .attr('r', (d) =>\n        currentLayout.value === 'force'\n          ? nodeRadiusScale(+d.saliency)\n          : minNodeRadius\n      )\n      .style('stroke', null)\n      .style('stroke-width', null)\n      .lower();\n  };\n\n  const createGraphData = (layer, head) => {\n    let curAttention = attentionData[layer][head];\n    let curAttentionData = { nodes: [], links: [] };\n    let curPredictedLabel =\n      saliencyData[String(instanceID)]['meta']['predicted_label'];\n\n    // Add nodes\n    saliencyData[String(instanceID)]['tokens'].forEach((d, i) => {\n      curAttentionData.nodes.push({\n        token: d.token,\n        saliency: d[curPredictedLabel],\n        id: i,\n      });\n    });\n\n    // Add links\n    for (let i = 0; i < curAttentionData.nodes.length; i++) {\n      for (let j = 0; j < curAttentionData.nodes.length; j++) {\n        curAttentionData.links.push({\n          source: i,\n          target: j,\n          weight: curAttention[i][j],\n        });\n      }\n    }\n\n    return curAttentionData;\n  };\n\n  const settingIconClicked = () => {\n    if (settingIconActive) {\n      settingIconActive = false;\n    } else {\n      settingIconActive = true;\n    }\n  };\n\n  hoverTokenStore.subscribe((value) => {\n    if (value != null) {\n      curHoverToken = value;\n\n      // Check if the coming word has split subwords in graph vis\n      if (\n        wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')] !== undefined\n      ) {\n        wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')].forEach(\n          (t) => {\n            highLightLink(t);\n          }\n        );\n      } else {\n        highLightLink(curHoverToken);\n      }\n    } else {\n      if (curHoverToken != null) {\n        // Check if the coming word has split subwords in graph vis\n        if (\n          wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')] !==\n          undefined\n        ) {\n          wordToSubwordMap[curHoverToken.replace(/(.*)-\\d*/, '$1')].forEach(\n            (t) => {\n              dehighlightLink(t);\n            }\n          );\n        } else {\n          dehighlightLink(curHoverToken);\n        }\n      }\n\n      curHoverToken = value;\n    }\n  });\n\n  const renderGraph = async () => {\n    // console.log('loading matrix');\n\n    // Load data from files if they have not been loaded\n    if (attentionData == null) {\n      attentionData = await d3.json(\n        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`\n      );\n    }\n    if (saliencyData == null) {\n      saliencyData = await d3.json(saliencyDataFilepath);\n      tokenSize = saliencyData[instanceID].tokens.length;\n    }\n\n    // Create graph data\n    graphData = createGraphData(curLayer, curHead);\n\n    // graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    // console.log('loaded matrix');\n\n    drawGraph();\n  };\n\n  onMount(async () => {\n    if (attentionData == null) {\n      attentionData = await d3.json(\n        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`\n      );\n    }\n\n    if (saliencyData == null) {\n      saliencyData = await d3.json(saliencyDataFilepath);\n      tokenSize = saliencyData[instanceID].tokens.length;\n    }\n\n    // gradSortedIndexes = await d3.json('PUBLIC_URL/data/sst2-sorted-grad-heads.json');\n    // gradSortedIndexes = gradSortedIndexes[instanceID];\n    // relevantAttentions = loadAttentionMatrix();\n    // console.log(relevantAttentions, saliencyData);\n    // console.log(tokenSize);\n\n    mounted = true;\n  });\n\n  graphViewConfigStore.subscribe((value) => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined) {\n      if (\n        graphViewCompConfig === undefined ||\n        (graphViewCompConfig.compHeight !== value.compHeight &&\n          graphViewCompConfig.compWidth !== value.compWidth)\n      ) {\n        // Update the height and width\n        graphViewCompConfig = value;\n        SVGHeight = graphViewCompConfig.compHeight;\n        SVGWidth = graphViewCompConfig.compWidth;\n        renderGraph();\n      }\n    }\n  });\n\n  wordToSubwordMapStore.subscribe((value) => {\n    wordToSubwordMap = value;\n  });\n\n  instanceIDStore.subscribe((value) => {\n    // console.log('Instance changed!!');\n    if (value !== instanceID) {\n      d3.select(graphSVG).selectAll('*').remove();\n\n      attentionData = null;\n      saliencyData = null;\n\n      instanceID = value;\n\n      renderGraph();\n    }\n  });\n</script>\n\n<style lang=\"scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n  width: 100%;\n  height: 100%;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}\n\n:global(.link.highlighted) {\n  stroke: #ffa31a;\n}\n\n:global(.border-rect) {\n  display: none;\n}\n\n.graph-label {\n  position: absolute;\n  color: gray;\n  font-size: 1.3rem;\n  margin: 5px 20px 0 20px;\n}\n\n.svg-container {\n  position: relative;\n}\n\n.svg-control-panel {\n  position: absolute;\n  top: 40px;\n  left: 0;\n  width: 200px;\n  cursor: default;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: flex-start;\n  font-size: 0.9em;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  box-shadow: 0 3px 3px rgba(49, 32, 18, 0.05);\n  background: rgba(255, 255, 255, 0.65);\n}\n.svg-control-panel .name {\n  font-size: 1em;\n  width: 94%;\n  padding: 5px 0px;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n}\n\n.sep-line-horizontal {\n  height: 0;\n  width: 95%;\n  border: 1px solid rgba(0, 0, 0, 0.06);\n}\n\n.sep-line-vertical {\n  height: 20px;\n  width: 0;\n  border: 1px solid rgba(0, 0, 0, 0.06);\n}\n\nselect {\n  height: 1.8em;\n  background: inherit;\n  border-color: rgba(0, 0, 0, 0);\n  padding: 0 1em 0 0.4em;\n}\nselect.select-num {\n  padding: 0 8px 0 0;\n  height: auto;\n  border-bottom: 3px solid rgba(167, 126, 98, 0.2);\n}\n\n.select-num-div::after {\n  top: 50%;\n  z-index: 0;\n}\n\n.select:not(.is-multiple) {\n  height: 1.8em;\n}\n\n.select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.2em;\n  border-color: #a77e62;\n  z-index: 0;\n}\n\n.select:not(.is-multiple).select-num-div {\n  height: auto;\n}\n.select:not(.is-multiple).select-num-div select {\n  margin: 0;\n}\n\n.select:not(.is-multiple).select-num-div::after {\n  right: 0.1em;\n  z-index: 0;\n}\n\n.select-row {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-around;\n  width: 94%;\n  padding: 3px 0;\n}\n\n.setting-icon {\n  padding: 0.1em 0.4em;\n  margin: 0 0.2em;\n  font-size: 1.1em;\n  color: #a77e62;\n  cursor: pointer;\n  border-radius: 3px;\n  transition: background 100ms ease-in-out;\n}\n.setting-icon:hover {\n  background: rgba(167, 126, 98, 0.1);\n}\n.setting-icon.active {\n  background: rgba(167, 126, 98, 0.2);\n}\n.setting-icon.active:hover {\n  background: rgba(167, 126, 98, 0.2);\n}\n\n.slider-container {\n  font-size: 0.9em;\n  padding: 0 15px 0 15px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-height: 0;\n  overflow: hidden;\n  transition: max-height 150ms ease-in-out;\n}\n.slider-container input {\n  width: 130px;\n}\n.slider-container .sep-line-horizontal {\n  width: 70%;\n  margin: 3px 0 10px 0;\n}\n.slider-container .sep-line-horizontal.longer-line {\n  width: 115%;\n  margin: 0 0 10px 0;\n}\n.slider-container.active {\n  max-height: 500px;\n  transition: max-height 300ms ease-in-out;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.slider-title {\n  color: rgba(0, 0, 0, 0.5);\n}\n\n.slider-text {\n  display: flex;\n  flex-direction: row;\n}\n.slider-text label {\n  margin-right: 5px;\n}\n\n.slider-value {\n  border-radius: 3px;\n  padding: 0 3px;\n  background: rgba(167, 126, 98, 0.2);\n  color: #836049;\n}</style>\n\n<div class=\"graph-view\">\n  <div class=\"svg-container\">\n    <div class=\"graph-label\">Semantic Attention Graph</div>\n\n    <!-- Control panel on top of the SVG -->\n    <div class=\"svg-control-panel\">\n      <div class=\"name\">\n        <div>\n          Layer\n          <div class=\"select select-num-div\">\n            <select name=\"layer\" class=\"select-num\" id=\"select-layer\">\n              {#each [...Array(12).keys()] as num}\n                <option value={num}>{num + 1}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n\n        <div>\n          Head\n          <div class=\"select select-num-div\">\n            <select name=\"layer\" class=\"select-num\" id=\"select-head\">\n              {#each [...Array(12).keys()] as num}\n                <option value={num}>{num + 1}</option>\n              {/each}\n            </select>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"sep-line-horizontal\" />\n\n      <div class=\"select-row\">\n        <div\n          class=\"setting-icon\"\n          on:click={settingIconClicked}\n          class:active={settingIconActive}\n        >\n          <i class=\"fas fa-sliders-h\" />\n        </div>\n\n        <div class=\"sep-line-vertical\" />\n\n        <div class=\"select\">\n          <select name=\"layout\" id=\"select-layout\">\n            {#each Object.values(layoutOptions) as opt}\n              <option value={opt.value}>{opt.name}</option>\n            {/each}\n          </select>\n        </div>\n      </div>\n\n      <!-- Slider panel -->\n      <div class=\"slider-container\" class:active={settingIconActive}>\n        <div class=\"sep-line-horizontal longer-line\" />\n\n        <div class=\"slider-title\">Edge Force</div>\n\n        <div class=\"sep-line-horizontal\" />\n\n        <div class=\"slider\">\n          <div class=\"slider-text\">\n            <label for=\"attention\">Attention</label>\n            <div class=\"slider-value\">\n              {config.autoAttention\n                ? 'auto'\n                : round(forceStrength.force.attention, 2)}\n            </div>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1000\"\n            value=\"500\"\n            class=\"slider\"\n            id=\"attention\"\n          />\n        </div>\n\n        <div class=\"slider\">\n          <div class=\"slider-text\">\n            <label for=\"textOrder\">Text Order</label>\n            <div class=\"slider-value\">\n              {round(forceStrength.force.textOrder, 2)}\n            </div>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1000\"\n            value=\"500\"\n            class=\"slider\"\n            id=\"textOrder\"\n          />\n        </div>\n\n        <div class=\"slider\">\n          <div class=\"slider-text\">\n            <label for=\"manyBody\">ManyBody</label>\n            <div class=\"slider-value\">\n              {round(forceStrength.force.manyBody, 2)}\n            </div>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1000\"\n            value=\"500\"\n            class=\"slider\"\n            id=\"manyBody\"\n          />\n        </div>\n\n        <div class=\"slider\">\n          <div class=\"slider-text\">\n            <label for=\"collide\">Node Distance</label>\n            <div class=\"slider-value\">\n              {round(forceStrength.force.collideRadius, 2)}\n            </div>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1000\"\n            value=\"500\"\n            class=\"slider\"\n            id=\"collideRadius\"\n          />\n        </div>\n\n        <div class=\"slider-title\">Edge Threshold</div>\n\n        <div class=\"sep-line-horizontal\" />\n\n        <div class=\"slider\">\n          <div class=\"slider-text\">\n            <label for=\"threshold\">Attention > </label>\n            <div class=\"slider-value\">\n              {round(weightThreshold, 2)}\n            </div>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1000\"\n            value=\"500\"\n            step=\"200\"\n            class=\"slider\"\n            id=\"threshold\"\n          />\n        </div>\n      </div>\n    </div>\n\n    <svg class=\"graph-svg\" bind:this={graphSVG} />\n  </div>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = { top: 3, left: 3, right: 3, bottom: 3 };\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout',\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout',\n    },\n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.force,\n  };\n\n  let forceStrength = { manyBody: 0, attention: 0, textOrder: 0 };\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const drag = (simulation) => {\n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    };\n\n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n\n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    };\n\n    return d3\n      .drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (d.saliency !== undefined) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGWidth - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(\n      SVGPadding.left + curRadius,\n      Math.min(width - curRadius, d.x)\n    );\n    const top = Math.max(\n      SVGPadding.top + curRadius,\n      Math.min(height - curRadius, d.y)\n    );\n\n    if (config.borderConstraint) {\n      return { top: top, left: left };\n    } else {\n      return { top: d.y, left: d.x };\n    }\n  };\n\n  const bindCheckBox = (simulation, links) => {\n    // Border checkbox\n    let borderCheckBox = d3\n      .select('#checkbox-border')\n      .property('checked', config.borderConstraint);\n\n    borderCheckBox.on('change', (event) => {\n      config.borderConstraint = event.target.checked;\n      simulation.alpha(0.2).restart();\n    });\n\n    // Hidden links\n    let hiddenLinkCheckBox = d3\n      .select('#checkbox-hidden-link')\n      .property('checked', config.showHiddenLink);\n\n    hiddenLinkCheckBox.on('change', (event) => {\n      config.showHiddenLink = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.text-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n\n      d3.select(graphSVG)\n        .select('g.text-hidden-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n    });\n\n    // Hidden nodes\n    let hiddenNodeCheckBox = d3\n      .select('#checkbox-hidden-node')\n      .property('checked', config.showHiddenNode);\n\n    hiddenNodeCheckBox.on('change', (event) => {\n      config.showHiddenNode = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.hidden-node-group')\n        .style('visibility', config.showHiddenNode ? 'visible' : 'hidden');\n      simulation.alpha(0.05).restart();\n    });\n\n    // Automatic attention link strength checkbox\n    let autoCheckBox = d3\n      .select('#checkbox-auto-attention')\n      .property('checked', config.autoAttention);\n\n    autoCheckBox.on('change', (event) => {\n      config.autoAttention = event.target.checked;\n\n      if (config.autoAttention) {\n        simulation.force(\n          'attentionLink',\n          d3.forceLink(links).id((d) => d.id)\n        );\n        simulation.alpha(0.3).restart();\n      } else {\n        simulation.force('attentionLink').strength(forceStrength.attention);\n        simulation.alpha(0.3).restart();\n      }\n    });\n  };\n\n  const bindSlider = (\n    name,\n    simulation,\n    min,\n    max,\n    defaultValue,\n    nodeRadiusScale = null\n  ) => {\n    let slider = d3\n      .select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      forceStrength[name] = value;\n\n      switch (name) {\n        case 'attention':\n          simulation.force('attentionLink').strength(value);\n          // Disable the auto attention\n          d3.select('#checkbox-auto-attention').property('checked', false);\n          config.autoAttention = false;\n          break;\n        case 'textOrder':\n          simulation.force('textLink').strength(value);\n          simulation.force('hiddenTextLink').strength(value);\n          break;\n        case 'manyBody':\n          simulation.force('charge').strength(value);\n          break;\n        case 'collide':\n          simulation.force('collide').radius((d) => minNodeRadius + value);\n          break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const bindSelect = () => {\n    let selectOption = d3\n      .select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayout = selectOption.property('value');\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3\n      .select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter((d) => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map((d) => Object.create(d));\n    links = links.map((d) => Object.create(d));\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach((d) => nodeIndices.add(+d.id));\n\n    // Add text order hidden links\n    let hiddenLinks = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +nodes[i].id,\n        target: +nodes[i + 1].id,\n      };\n      hiddenLinks.push(hiddenLink);\n    }\n    // hiddenLinks.push({\n    //   source: +nodes[nodes.length - 1].id,\n    //   target: nodes[0].id\n    // });\n    hiddenLinks = hiddenLinks.map((d) => Object.create(d));\n\n    // console.log(nodes, links);\n\n    // Add intermediate nodes to create bezier curves\n    let nodeByID = new Map(nodes.map((d) => [d.id, d]));\n    let bilinks = [];\n\n    links.forEach((d) => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let intermediate = { hidden: true };\n\n      let curBilink = [source, intermediate, target];\n      curBilink.selfLoop = source === target;\n\n      // nodes.push(intermediate);\n      // links.push(\n      //   {source: source, target: intermediate},\n      //   {source: intermediate, target: target}\n      // );\n\n      bilinks.push(curBilink);\n    });\n\n    // Add grid links\n    let gridLinks = [];\n    let nodeIndexArray = Array.from(nodeIndices);\n    const rowSize = 10;\n\n    nodeIndexArray.sort((a, b) => +a - +b);\n    for (let i = 0; i < nodes.length; i++) {\n      if ((i % rowSize !== rowSize - 1) & nodeByID.has(i + 1)) {\n        gridLinks.push({\n          source: nodeByID.get(i),\n          target: nodeByID.get(i + 1),\n        });\n      }\n      if (nodeByID.has(i + rowSize)) {\n        gridLinks.push({\n          source: nodeByID.get(i),\n          target: nodeByID.get(i + rowSize),\n        });\n      }\n    }\n\n    // console.log(gridLinks);\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map((d) => +d.saliency);\n    let nodeRadiusScale = d3\n      .scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .nice();\n\n    // Define the force\n    let simulation = d3.forceSimulation(nodes);\n    const initManyBodyStrength = -1400;\n    const initAttentionStrength = 0.5;\n    const initTextOrderStrength = 2;\n    const initRadialStrength = 1;\n    const initCollideRadius = 7;\n\n    forceStrength.manyBody = initManyBodyStrength;\n    forceStrength.attention = initAttentionStrength;\n    forceStrength.textOrder = initTextOrderStrength;\n    forceStrength.radial = initRadialStrength;\n    forceStrength.collide = initCollideRadius;\n\n    // Force 1 (ManyBody force)\n    simulation.force(\n      'charge',\n      d3.forceManyBody().strength((d) => (d.selfLoop == undefined ? -200 : 0))\n    );\n\n    // Force 2 (Center force)\n    simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // Force 3 (Link force)\n    // simulation.force('attentionLink', d3.forceLink(links)\n    //   .id(d => d.id)\n    //   //.strength(initAttentionStrength)\n    // );\n\n    // Force 4 (Text order link force)\n    // simulation.force('textLink', d3.forceLink(hiddenLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );\n\n    // Force 8 (Grid force)\n    simulation.force(\n      'grid',\n      d3\n        .forceLink(gridLinks)\n        .iterations(80)\n        .distance(50)\n        .id((d) => d.id)\n    );\n\n    simulation.force(\n      'posY',\n      d3\n        .forceY()\n        .y((d) => (Math.floor(d.index / rowSize) * SVGHeight) / rowSize)\n    );\n\n    simulation.force(\n      'posX',\n      d3.forceX().x((d) => ((d.index % rowSize) * SVGWidth) / rowSize)\n    );\n\n    // Force 5 (Text order link force on hidden nodes)\n    // simulation.force('hiddenTextLink', d3.forceLink(hiddenTextOrderLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );\n\n    // Force 6 (Radial force)\n    // simulation.force('charge', d3.forceCollide().radius(d => nodeRadiusScale(d.saliency) + 15))\n    //   .force('radial', d3.forceRadial(300)\n    //     .x(SVGWidth / 2)\n    //     .y(SVGHeight / 2)\n    //     .strength(initRadialStrength)\n    //   );\n\n    // Force 7 (Collide force)\n    simulation.force(\n      'collide',\n      d3\n        .forceCollide()\n        .radius((d) => (d.saliency === undefined ? 0 : minNodeRadius + 10))\n    );\n\n    // Change the min alpha so that the nodes do not shake at the end (end earlier)\n    // The default alphaMin is 0.0001\n    simulation.alphaMin(0.001);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg\n      .append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    // Add attention links\n    let linkLines = svg\n      .append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textLinkLines = svg\n      .append('g')\n      .attr('class', 'text-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'red')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    // let textHiddenLinkLines = svg.append('g')\n    //   .attr('class', 'text-hidden-link-group')\n    //   .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n    //   .style('stroke', 'blue')\n    //   .style('stroke-opacity', 1)\n    //   .selectAll('line')\n    //   .data(hiddenTextOrderLinks)\n    //   .join('line')\n    //   .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg\n      .append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(nodes.filter((d) => d.id !== undefined))\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag(simulation));\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3\n      .scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n\n    nodeGroups\n      .append('circle')\n      .attr('class', 'node-circle')\n      //.attr('r', d => nodeRadiusScale(+d.saliency))\n      .attr('r', minNodeRadius)\n      .style('fill', (d) => colorScale(d.id));\n\n    // Add token text to each node\n    nodeGroups\n      .append('text')\n      .attr('class', 'node-text')\n      .text((d) => d.token);\n\n    nodeGroups.append('title').text((d) => d.token);\n\n    // Add hidden nodes\n    let hiddenNodeGroups = svg\n      .append('g')\n      .attr('class', 'hidden-node-group')\n      .style('visibility', config.showHiddenNode ? 'visible' : 'hidden')\n      .selectAll('g.hidden-node')\n      // Need to select intermediate nodes\n      .data(nodes.filter((d) => d.id == undefined))\n      .join('g')\n      .attr('class', 'hidden-node');\n\n    hiddenNodeGroups\n      .append('circle')\n      .attr('class', 'hidden-node-circle')\n      .attr('r', 3)\n      .style('fill', 'lightgreen');\n\n    // Simulation tick updates\n    simulation.on('tick', () => {\n      // console.log('Tick');\n\n      // Update the attention links\n      linkLines.attr('d', (d) => {\n        const sCoord = borderConstraint(d[0], nodeRadiusScale);\n        const tCoord = borderConstraint(d[2], nodeRadiusScale);\n\n        // We need to shorten the path to leave space for arrow\n        let halfLen = Math.sqrt(\n          (tCoord.left - sCoord.left) ** 2 + (tCoord.top - sCoord.top) ** 2\n        );\n\n        let theta = minNodeRadius / halfLen;\n        let modTCoord = {\n          left: tCoord.left + (sCoord.left - tCoord.left) * theta,\n          top: tCoord.top + (sCoord.top - tCoord.top) * theta,\n        };\n\n        return (\n          'M' +\n          sCoord.left +\n          ',' +\n          sCoord.top +\n          'L' +\n          modTCoord.left +\n          ',' +\n          modTCoord.top\n        );\n      });\n\n      // Update the nodes\n      nodeGroups.attr('transform', (d) => {\n        // Maker sure the nodes are inside the box\n        const coord = borderConstraint(d, nodeRadiusScale);\n        return `translate(${coord.left}, ${coord.top})`;\n      });\n\n      // Update the hidden nodes\n      if (config.showHiddenNode) {\n        hiddenNodeGroups.attr('transform', (d) => {\n          // Maker sure the nodes are inside the box\n          const coord = borderConstraint(d);\n          return `translate(${coord.left}, ${coord.top})`;\n        });\n      }\n\n      // Update the text links\n      if (config.showHiddenLink) {\n        textLinkLines\n          .attr('x1', (d) => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', (d) => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', (d) => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', (d) => borderConstraint(d.target, nodeRadiusScale).top);\n\n        textHiddenLinkLines\n          .attr('x1', (d) => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', (d) => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', (d) => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', (d) => borderConstraint(d.target, nodeRadiusScale).top);\n      }\n    });\n\n    // Register UI elements from the control panel\n    bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    bindSlider('manyBody', simulation, -2000, 0, initManyBodyStrength);\n    bindSlider(\n      'collide',\n      simulation,\n      0,\n      20,\n      initCollideRadius,\n      nodeRadiusScale\n    );\n\n    bindCheckBox(simulation, links);\n\n    bindSelect();\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style lang=\"scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}</style>\n\n<div class=\"graph-view\">\n  <div class=\"control-panel\">\n    <!-- Sliders -->\n    <div class=\"slider\">\n      <label for=\"attention\"\n        >Attention Strength [{config.autoAttention\n          ? 'auto'\n          : round(forceStrength.attention, 2)}]\n      </label>\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"attention\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"textOrder\"\n        >Text Order Strength [{round(forceStrength.textOrder, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"textOrder\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"manyBody\"\n        >ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"manyBody\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"collide\"\n        >Node Distance [{round(forceStrength.collide, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"collide\"\n      />\n    </div>\n\n    <!-- Checkboxes -->\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\" />\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\" />\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\" />\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-border\" />\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n\n    <!-- Selection -->\n    <div class=\"select\">\n      <select name=\"layout\" id=\"select-layout\">\n        <option value=\"force\">Force Layout</option>\n        <option value=\"radial\">Radial Layout</option>\n      </select>\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <svg class=\"graph-svg\" bind:this={graphSVG} />\n  </div>\n</div>\n",
    "<script>\n</script>\n\n<style lang=\"scss\">#header {\n  height: 50px;\n  display: flex;\n  padding: 0 20px;\n  align-items: center;\n  background: #312012;\n  justify-content: space-between;\n}\n\n#logo {\n  display: flex;\n  align-items: baseline;\n}\n\n#logo-text {\n  font-size: 2rem;\n  color: white;\n  font-family: \"Fredoka One\";\n  margin-right: 10px;\n}\n\n#logo-icon {\n  width: 26px;\n  margin-right: 10px;\n}\n\n#logo-tagline {\n  font-size: 1.5rem;\n  color: #aaa5a1;\n  font-family: \"Neucha\";\n}\n\n.icons {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  color: white;\n}\n.icons :not(:last-child) {\n  margin-right: 15px;\n}\n\n.icon {\n  font-size: 1.5rem;\n  display: flex;\n  align-items: center;\n  color: white;\n}</style>\n\n<div id=\"header\">\n  <div id=\"logo\">\n    <div id=\"logo-icon\">\n      <img src=\"PUBLIC_URL/figures/dodrio-logo.svg\" alt=\"logo\" />\n    </div>\n    <div id=\"logo-text\">Dodrio</div>\n\n    <div id=\"logo-tagline\">Exploring transformer models in your browser!</div>\n  </div>\n\n  <div class=\"icons\">\n    <a class=\"icon-a\" target=\"_blank\" href=\"https://arxiv.org/abs/2103.14625\">\n      <div class=\"icon\" title=\"Research paper\">\n        <i class=\"fas fa-file-pdf\" />\n      </div>\n    </a>\n\n    <a target=\"_blank\" href=\"https://youtu.be/uboTKqPNU5Y\">\n      <div class=\"icon\" title=\"Demo video\">\n        <i class=\"fab fa-youtube\" />\n      </div>\n    </a>\n\n    <a target=\"_blank\" href=\"https://github.com/poloclub/dodrio\">\n      <div class=\"icon\" title=\"Open-source code\">\n        <i class=\"fab fa-github\" />\n      </div>\n    </a>\n  </div>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import {\n    lowerMapViewConfigStore,\n    attentionHeadColorStore,\n    tooltipConfigStore,\n    mapHeadStore,\n  } from './store';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  export let attentionDataDir;\n  export let saliencyDataFilepath;\n  export let atlasDataFilepath;\n\n  let svg = null;\n  let atlasData = null;\n  let attentions = null;\n  let saliencies = null;\n  let tokenSize = null;\n\n  // Tooltip variables\n  let tooltipConfig = null;\n  tooltipConfigStore.subscribe((value) => {\n    tooltipConfig = value;\n  });\n\n  let viewContainer = null;\n  let mapHead = { layer: 9, head: 8 };\n  let curLayer = 9;\n  let curHead = 8;\n\n  let attentionHeadColors = new Map();\n\n  const red = d3.hcl(23, 85, 56);\n  const purple = d3.hcl(328, 85, 56);\n  const blue = d3.hcl(274, 85, 56);\n\n  let instanceID = 1562;\n  const dispatch = createEventDispatcher();\n  let isShown = true;\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n\n  const SVGPadding = { top: 40, left: 10, right: 10, bottom: 3 };\n\n  const ease = d3.easeCubicInOut;\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const padZeroLeft = (num, digit) => {\n    return Array(Math.max(digit - String(num).length + 1, 0)).join(0) + num;\n  };\n\n  const createGraph = () => {\n    const layerNum = attentions.length;\n    const headNum = attentions[0].length;\n    const layerNameWidth = 35;\n    const headNameHeight = 17;\n\n    let availableWidth =\n      SVGWidth - layerNameWidth - SVGPadding.left - SVGPadding.right;\n    let availableHeight =\n      SVGHeight - SVGPadding.top - SVGPadding.bottom - headNameHeight;\n\n    let availableLength = Math.min(availableHeight, availableWidth);\n    // console.log(SVGHeight, availableLength, availableWidth, availableHeight);\n    const gridGap = 8;\n\n    const gridLength = Math.floor(\n      (availableHeight - (layerNum - 1) * gridGap) / layerNum\n    );\n    const maxOutRadius = gridLength / 2;\n    const minOutRadius = 3;\n\n    let adjustedRowGap = Math.floor(\n      (availableWidth - maxOutRadius - headNum * gridLength) / (layerNum - 1)\n    );\n    let adjustedColGap = Math.floor(\n      (availableHeight - layerNum * gridLength) / (layerNum - 1)\n    );\n\n    svg = d3\n      .select(svg)\n      .attr('width', availableWidth + layerNameWidth)\n      .attr('height', availableHeight + headNameHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', availableLength)\n      .attr('height', availableLength)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    let donutGroup = svg\n      .append('g')\n      .attr('class', 'donut-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left + maxOutRadius + layerNameWidth},\n        ${maxOutRadius + headNameHeight})`\n      );\n\n    // Create color scale\n    let hueScale = d3\n      .scaleLinear()\n      .domain([-1, 0, 1])\n      .range([red, purple, blue]);\n\n    let lightnessScale = d3.scaleLinear().domain([0, 1]).range([130, 40]);\n\n    // Use square root scale\n    let outRadiusScale = d3\n      .scaleLinear()\n      .domain([0, 1])\n      .range([minOutRadius, maxOutRadius]);\n\n    let ringRadiusScale = d3.scaleLinear().domain([0, 1]).range([4, 7]);\n\n    let scales = {\n      hueScale: hueScale,\n      lightnessScale: lightnessScale,\n      outRadiusScale: outRadiusScale,\n      ringRadiusScale: ringRadiusScale,\n    };\n\n    let donuts = donutGroup\n      .selectAll('g.donut')\n      .data(atlasData)\n      .join('g')\n      .attr('class', 'donut')\n      .style('cursor', 'pointer')\n      .attr(\n        'transform',\n        (d) => `translate(${d.head * (maxOutRadius * 2 + adjustedRowGap)},\n        ${(layerNum - d.layer - 1) * (maxOutRadius * 2 + adjustedColGap)})`\n      );\n\n    // Draw the donuts\n    donuts.each((d, i, g) => drawDonut(d, i, g, scales));\n\n    // Record the head color\n    // console.log(attentionHeadColors);\n    attentionHeadColorStore.set(attentionHeadColors);\n\n    donuts\n      .on('mouseover', (e, d) => {\n        // Show the tooltip\n        let node = e.currentTarget;\n        let position = node.getBoundingClientRect();\n        let curWidth = position.right - position.left;\n\n        let tooltipCenterX = position.x + curWidth / 2;\n        let tooltipCenterY = position.y - 90;\n\n        tooltipConfig.html = `\n        <div class='tooltip-tb' style='display: flex; flex-direction: column;\n          justify-content: center; font-weight: 800;'>\n          <div> Layer ${d.layer + 1} Head ${d.head + 1} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Semantic: ${round(\n            d.semantic,\n            2\n          )} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Syntactic ${round(\n            d.syntactic,\n            2\n          )} </div>\n          <div style='font-size: 12px; opacity: 0.6;'> Importance: ${round(\n            d.confidence,\n            2\n          )} </div>\n        </div>\n        `;\n        tooltipConfig.width = 130;\n        tooltipConfig.maxWidth = 130;\n        tooltipConfig.left = tooltipCenterX - tooltipConfig.width / 2;\n        tooltipConfig.top = tooltipCenterY;\n        tooltipConfig.fontSize = '0.8em';\n        tooltipConfig.show = true;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Show the background rect\n        let curDonut = d3.select(e.currentTarget);\n\n        if (!curDonut.classed('selected')) {\n          curDonut.select('.donut-rect').style('opacity', 1);\n        }\n      })\n      .on('mouseleave', (e) => {\n        tooltipConfig.show = false;\n        tooltipConfigStore.set(tooltipConfig);\n\n        // Hide the background rect\n        let curDonut = d3.select(e.currentTarget);\n        if (!curDonut.classed('selected')) {\n          curDonut.select('.donut-rect').style('opacity', 0);\n        }\n      })\n      .on('click', (e) => {\n        let curDonut = d3.select(e.currentTarget);\n        if (curDonut.classed('selected')) {\n          // pass\n        } else {\n          // Restore the currently selected rect\n          let preDonut = d3.select(\n            donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node()\n              .parentNode\n          );\n\n          preDonut\n            .select('.donut-rect')\n            .style('fill', 'hsl(0, 0%, 80%)')\n            .style('opacity', 0);\n\n          preDonut.classed('selected', false);\n\n          // Style the new rect\n          curDonut\n            .select('.donut-rect')\n            .style('fill', 'hsl(27, 47%, 13%)')\n            .style('opacity', 1);\n\n          curDonut.classed('selected', true);\n\n          curLayer = +curDonut.data()[0].layer;\n          curHead = +curDonut.data()[0].head;\n\n          mapHead.layer = curLayer;\n          mapHead.head = curHead;\n          mapHeadStore.set(mapHead);\n        }\n      });\n\n    // Draw horizontal lines between rows\n    donutGroup\n      .selectAll('g.row-line-group')\n      .data(\n        Array(layerNum - 1)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'row-line-group')\n      .append('path')\n      .attr('d', (d) => {\n        return `M${-maxOutRadius}\n        ${(layerNum - d - 1 - 1 / 2) * (maxOutRadius * 2 + adjustedColGap)}\n        L${headNum * (maxOutRadius * 2 + adjustedRowGap) - maxOutRadius}\n        ${(layerNum - d - 1 - 1 / 2) * (maxOutRadius * 2 + adjustedColGap)}`;\n      })\n      .style('stroke', 'hsla(0, 0%, 0%, 0.1)');\n\n    // Draw the label names\n    let nameGroup = svg\n      .append('g')\n      .attr('class', 'name-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left}, ${maxOutRadius + headNameHeight})`\n      );\n\n    nameGroup\n      .selectAll('g.layer-name-group')\n      .data(\n        Array(layerNum)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'layer-name-group')\n      .attr(\n        'transform',\n        (d) => `translate(${layerNameWidth - 5},\n        ${(layerNum - d - 1) * (maxOutRadius * 2 + adjustedColGap)})`\n      )\n      .append('text')\n      .text((d) => (d > 0 ? d + 1 : `Layer ${d + 1}`));\n\n    let headNameGroup = svg\n      .append('g')\n      .attr('class', 'name-group')\n      .attr(\n        'transform',\n        `translate(${SVGPadding.left + layerNameWidth + maxOutRadius},\n        ${5})`\n      );\n\n    headNameGroup\n      .selectAll('g.head-name-group')\n      .data(\n        Array(layerNum)\n          .fill(0)\n          .map((_, i) => i)\n      )\n      .join('g')\n      .attr('class', 'head-name-group')\n      .attr(\n        'transform',\n        (d) => `translate(${d * (maxOutRadius * 2 + adjustedRowGap)},\n        ${0})`\n      )\n      .append('text')\n      .text((d) => (d > 0 ? d + 1 : `Head ${d + 1}`));\n\n    // console.log(atlasData);\n\n    d3.select(viewContainer)\n      .select('.head-arrow')\n      .style('top', `${70 - 40}px`)\n      .style('left', `${availableWidth - 170}px`);\n\n    d3.select(viewContainer)\n      .select('.layer-arrow')\n      .style('top', `${70}px`)\n      .style('left', `${availableWidth + 10}px`);\n\n    // Highlight the initial selection\n    let curDonut = d3.select(\n      donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node().parentNode\n    );\n\n    // Style the new rect\n    curDonut\n      .select('.donut-rect')\n      .style('fill', 'hsl(27, 47%, 13%)')\n      .style('opacity', 1);\n\n    curDonut.classed('selected', true);\n  };\n\n  mapHeadStore.subscribe((value) => {\n    mapHead = value;\n    // console.log(mapHead, curLayer, curHead);\n\n    if (mapHead.layer !== curLayer || mapHead.head !== curHead) {\n      let donutGroup = svg.select('g.donut-group');\n\n      // Restore the currently selected rect\n      let preDonut = d3.select(\n        donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node()\n          .parentNode\n      );\n\n      preDonut\n        .select('.donut-rect')\n        .style('fill', 'hsl(0, 0%, 80%)')\n        .style('opacity', 0);\n\n      preDonut.classed('selected', false);\n\n      curLayer = mapHead.layer;\n      curHead = mapHead.head;\n\n      let curDonut = d3.select(\n        donutGroup.select(`#donut-rect-${curLayer}-${curHead}`).node()\n          .parentNode\n      );\n\n      // Style the new rect\n      curDonut\n        .select('.donut-rect')\n        .style('fill', 'hsl(27, 47%, 13%)')\n        .style('opacity', 1);\n\n      curDonut.classed('selected', true);\n    }\n  });\n\n  const drawDonut = (d, i, g, scales) => {\n    let donut = d3.select(g[i]);\n\n    let outRadius = scales.outRadiusScale(d.confidence);\n    let ringRadius = scales.ringRadiusScale(d.confidence);\n    let inRadius = Math.max(0, outRadius - ringRadius);\n\n    // Draw the background rect\n    let maxLength = 2 * scales.outRadiusScale.range()[1];\n    donut\n      .append('rect')\n      .attr('class', 'donut-rect')\n      .attr('id', `donut-rect-${d.layer}-${d.head}`)\n      .attr('x', -maxLength / 2)\n      .attr('y', -maxLength / 2)\n      .attr('rx', 5)\n      .attr('width', maxLength)\n      .attr('height', maxLength)\n      .style('fill', 'hsl(0, 0%, 80%)')\n      .style('opacity', 0);\n\n    // Draw the rings\n    // Arc's center is at (0, 0) on the local coordinate\n    let arc = d3\n      .arc()\n      .outerRadius(outRadius)\n      .innerRadius(0)\n      .startAngle(0)\n      .endAngle(Math.PI * 2);\n\n    let color = d3.hcl(scales.hueScale(d.syntactic - d.semantic));\n    color.l = scales.lightnessScale(Math.max(d.semantic, d.syntactic));\n\n    // Record the color\n    attentionHeadColors.set([d.layer, d.head].toString(), color.formatHex());\n\n    donut\n      .append('path')\n      .attr('class', 'donut-chart')\n      .attr('d', arc)\n      .style('fill', color);\n\n    // Draw the edges\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < tokenSize; i++) {\n      let curAngle = -Math.PI / 2 + i * ((Math.PI * 2) / tokenSize);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        token: d.token,\n        id: i,\n      });\n    }\n  };\n\n  const initData = async (attentionFile, saliencyFile, atlasFile) => {\n    // Init attention data\n    attentions = await d3.json(attentionFile);\n\n    // init atlas data\n    atlasData = await d3.json(atlasFile);\n\n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n    tokenSize = saliencies.tokens.length;\n  };\n\n  onMount(async () => {\n    // Load the attention and atlas data\n    if (attentions == null || atlasData == null || saliencies == null) {\n      initData(\n        attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`,\n        saliencyDataFilepath,\n        atlasDataFilepath\n      );\n    }\n  });\n\n  lowerMapViewConfigStore.subscribe(async (value) => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined) {\n      if (\n        instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n          instanceViewConfig.compWidth !== value.compWidth)\n      ) {\n        instanceViewConfig = value;\n\n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight;\n\n        // Load the attention and atlas data\n        if (attentions == null || atlasData == null || saliencies == null) {\n          initData(\n            attentionDataDir + `attention-${padZeroLeft(instanceID, 4)}.json`,\n            saliencyDataFilepath,\n            atlasDataFilepath\n          ).then(createGraph);\n        } else {\n          createGraph();\n        }\n      }\n    }\n  });\n</script>\n\n<style lang=\"scss\">:global(.layer-name-group text) {\n  dominant-baseline: middle;\n  text-anchor: end;\n  font-size: 0.7em;\n  fill: rgba(0, 0, 0, 0.3);\n}\n\n:global(.head-name-group text) {\n  dominant-baseline: hanging;\n  text-anchor: middle;\n  font-size: 0.7em;\n  fill: rgba(0, 0, 0, 0.3);\n}\n\n.svg-container {\n  width: 100%;\n  height: 100%;\n  overflow-x: hidden;\n  position: relative;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  align-items: flex-end;\n}\n\n.atlas-view {\n  display: flex;\n  flex-direction: row;\n  max-width: 100%;\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n  transition: max-width 1000ms ease-in-out;\n}\n\n.atlas-svg-container {\n  position: relative;\n}\n\n.control-row {\n  position: absolute;\n  top: 0;\n  left: 0;\n  cursor: default;\n  padding-top: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  user-select: none;\n  font-size: 0.9rem;\n  z-index: 5;\n}\n\n.lower-atlas-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 20px 0 20px;\n}\n\n.expand-button {\n  padding: 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 5px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n\n.icon-wrapper {\n  margin-right: 5px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 0.5;\n}\n.icon-wrapper img {\n  height: 1.2em;\n}\n\n.color-legend {\n  margin-left: 20px;\n  display: flex;\n}\n.color-legend img {\n  height: 22px;\n}</style>\n\n<div class=\"atlas-view\" bind:this={viewContainer}>\n  <div class=\"control-row\">\n    <div class=\"lower-atlas-label\">Attention Head Overview</div>\n\n    <div class=\"select-row\">\n      <div class=\"relation-container\" on:click={() => dispatch('open')}>\n        <div class=\"expand-button\">\n          <div class=\"icon-wrapper\">\n            <img\n              src=\"PUBLIC_URL/figures/expand-outline.svg\"\n              alt=\"expanding icon\"\n            />\n          </div>\n          Show Detail\n        </div>\n      </div>\n    </div>\n\n    <div class=\"color-legend\">\n      <img src=\"PUBLIC_URL/figures/color-legend.png\" alt=\"expanding icon\" />\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <div class=\"atlas-svg-container\">\n      <svg class=\"atlas-svg\" bind:this={svg} />\n    </div>\n  </div>\n</div>\n",
    "<script>\n  import Header from './Header.svelte';\n  import GraphView from './GraphView.svelte';\n  import Dependency from './dependency-view/Dependency.svelte';\n  import Atlas from './Atlas.svelte';\n  import AtlasSide from './AtlasSide.svelte';\n  import Tooltip from './TooltipGlobal.svelte';\n  import LowerAtlas from './LowerAtlas.svelte';\n  import TableModal from './TableModal.svelte';\n  import Article from './article/Article.svelte';\n  import {\n    graphViewConfigStore,\n    instanceViewConfigStore,\n    mapViewConfigStore,\n    lowerMapViewConfigStore,\n    comparisonViewStore,\n    tooltipConfigStore,\n    sideStore,\n  } from './store';\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  const attentionDataDir = 'PUBLIC_URL/data/sst2-attention-data/';\n  const dependencyDataFilepath = 'PUBLIC_URL/data/sst2-dependencies.json';\n  const syntacticHeadDataFilepath =\n    'PUBLIC_URL/data/sst2-sorted-syntactic-heads.json';\n  const semanticHeadDataFilepath =\n    'PUBLIC_URL/data/sst2-sorted-saliency-heads.json';\n  const importantHeadDataFilepath =\n    'PUBLIC_URL/data/sst2-sorted-confidence-heads.json';\n  const saliencyDataFilepath =\n    'PUBLIC_URL/data/sst2-saliency-list-grad-l1.json';\n  const atlasDataFilepath = 'PUBLIC_URL/data/sst2-atlas.json';\n  const embeddingDataFilepath = 'PUBLIC_URL/data/embedding-list-sst2.json';\n  const tableDataFilepath = 'PUBLIC_URL/data/table-list-sst2.json';\n\n  // Set up the tooltip\n  let tooltip = null;\n  let atlasSVGWidth = null;\n  let atlasSVGHeight = null;\n  const headerHeight = 50;\n\n  let downButton;\n  let buttonDown = true;\n  let downButtonPos = {\n    width: 50,\n    height: 20,\n  };\n\n  let tooltipConfig = {\n    show: false,\n    html: '1.23',\n    left: 0,\n    top: 0,\n    width: 80,\n    maxWidth: 80,\n    fontSize: '1em',\n  };\n\n  tooltipConfigStore.subscribe((value) => {\n    tooltipConfig = value;\n  });\n\n  let sideInfo = {};\n  sideStore.subscribe((value) => {\n    sideInfo = value;\n  });\n\n  let lowerContainerDIV = null;\n  let graphViewDIV = null;\n  let graphViewConfig = {\n    compWidth: null,\n    compHeight: null,\n  };\n\n  let originalInstanceViewHeight = null;\n  let instanceViewDIV = null;\n  let instanceViewConfig = {\n    compWidth: null,\n    compHeight: null,\n  };\n\n  let comparisonViewConfig = {};\n  comparisonViewStore.subscribe((value) => {\n    comparisonViewConfig = value;\n  });\n\n  let mapViewDIV = null;\n  let mapViewConfig = {\n    compWidth: null,\n    compHeight: null,\n  };\n\n  let lowerMapViewDIV = null;\n  let lowerMapViewConfig = {\n    compWidth: null,\n    compHeight: null,\n  };\n\n  /**\n   * Open the large map view.\n   */\n  const atlasOpened = () => {\n    mapViewDIV.style['display'] = '';\n    mapViewDIV.style['opacity'] = '1';\n  };\n\n  /**\n   * Close the large map view.\n   */\n  const atlasClosed = () => {\n    d3.select(mapViewDIV).select('.legend-container').style('display', 'none');\n\n    let svg = d3\n      .select(mapViewDIV)\n      .select('.atlas-svg-container')\n      .style('width', '100%')\n      .style('height', '100%')\n      .select('.atlas-svg-full');\n\n    atlasSVGWidth = svg.attr('width');\n    atlasSVGHeight = svg.attr('height');\n\n    svg\n      .attr('width', null)\n      .attr('height', null)\n      .style('padding-top', '36px')\n      .style('padding-left', '8px')\n      .style('width', '100%')\n      .style('height', '100%');\n\n    mapViewDIV.style['width'] = `${lowerMapViewConfig.compWidth}px`;\n    mapViewDIV.style['height'] = `${lowerMapViewConfig.compHeight}px`;\n    mapViewDIV.style['opacity'] = 0;\n\n    const transitionEnd = () => {\n      mapViewDIV.style['display'] = 'none';\n      mapViewDIV.style['visibility'] = '';\n      mapViewDIV.style['width'] = '1000px';\n      mapViewDIV.style['height'] = '100%';\n\n      d3.select(mapViewDIV).select('.legend-container').style('display', null);\n\n      d3.select(mapViewDIV)\n        .select('.atlas-svg-container')\n        .style('width', null)\n        .style('height', null)\n        .select('.atlas-svg-full')\n        .style('padding-top', null)\n        .style('padding-left', null)\n        .style('width', null)\n        .style('height', null)\n        .attr('width', atlasSVGWidth)\n        .attr('height', atlasSVGHeight);\n\n      mapViewDIV.removeEventListener('transitionend', transitionEnd);\n    };\n\n    mapViewDIV.addEventListener('transitionend', transitionEnd);\n  };\n\n  const downButtonClicked = () => {\n    // Enter comparison view\n    if (buttonDown) {\n      instanceViewDIV.style.height = '100%';\n      lowerContainerDIV.style.bottom = `-${graphViewConfig.compHeight - 10}px`;\n      downButton.style.top = `${\n        originalInstanceViewHeight +\n        headerHeight -\n        downButtonPos.height / 2 +\n        graphViewConfig.compHeight -\n        10\n      }px`;\n\n      comparisonViewConfig.height =\n        Math.floor(instanceViewDIV.clientHeight) - 5;\n      comparisonViewConfig.inComparison = true;\n      comparisonViewStore.set(comparisonViewConfig);\n    } else {\n      // Exit comparison view\n      instanceViewDIV.style.height = '34%';\n      lowerContainerDIV.style.bottom = '0px';\n      downButton.style.top = `${\n        originalInstanceViewHeight + headerHeight - downButtonPos.height / 2\n      }px`;\n\n      comparisonViewConfig.height = originalInstanceViewHeight - 5;\n      comparisonViewConfig.inComparison = false;\n      comparisonViewStore.set(comparisonViewConfig);\n    }\n\n    buttonDown = !buttonDown;\n  };\n\n  const comparisonOpenHandler = () => {\n    instanceViewDIV.style.height = '100%';\n    lowerContainerDIV.style.bottom = `-${graphViewConfig.compHeight - 10}px`;\n    downButton.style.top = `${\n      originalInstanceViewHeight +\n      headerHeight -\n      downButtonPos.height / 2 +\n      graphViewConfig.compHeight -\n      10\n    }px`;\n    buttonDown = false;\n\n    comparisonViewConfig.height = Math.floor(instanceViewDIV.clientHeight) - 5;\n    comparisonViewConfig.inComparison = true;\n    comparisonViewStore.set(comparisonViewConfig);\n  };\n\n  const comparisonCloseHandler = () => {\n    instanceViewDIV.style.height = '34%';\n    lowerContainerDIV.style.bottom = '0px';\n    downButton.style.top = `${\n      originalInstanceViewHeight + headerHeight - downButtonPos.height / 2\n    }px`;\n    buttonDown = true;\n\n    comparisonViewConfig.height = originalInstanceViewHeight - 5;\n    comparisonViewConfig.inComparison = false;\n    comparisonViewStore.set(comparisonViewConfig);\n  };\n\n  onMount(() => {\n    graphViewConfig.compWidth = Math.floor(graphViewDIV.clientWidth);\n    graphViewConfig.compHeight = Math.floor(graphViewDIV.clientHeight);\n    graphViewConfigStore.set(graphViewConfig);\n\n    instanceViewConfig.compWidth = Math.floor(instanceViewDIV.clientWidth);\n    // Need to offset the horizontal scroll bar height\n    instanceViewConfig.compHeight =\n      Math.floor(instanceViewDIV.clientHeight) - 5;\n    instanceViewConfigStore.set(instanceViewConfig);\n    originalInstanceViewHeight = Math.floor(instanceViewDIV.clientHeight);\n\n    lowerMapViewConfig.compWidth = Math.floor(lowerMapViewDIV.clientWidth);\n    lowerMapViewConfig.compHeight = Math.floor(lowerMapViewDIV.clientHeight);\n    lowerMapViewConfigStore.set(lowerMapViewConfig);\n\n    // Need to offset the padding\n    mapViewConfig.compWidth = Math.floor(mapViewDIV.clientWidth - 10);\n    mapViewConfig.compHeight = Math.floor(mapViewDIV.clientHeight - 10);\n    mapViewConfigStore.set(mapViewConfig);\n\n    // Hide the large map view\n    mapViewDIV.style['opacity'] = '0';\n    mapViewDIV.style['visibility'] = 'hidden';\n    atlasClosed();\n\n    // Position the down button\n    // console.log(headerHeight, downButtonPos.height);\n    downButton.style.top = `${\n      Math.floor(instanceViewDIV.clientHeight) +\n      headerHeight -\n      downButtonPos.height / 2\n    }px`;\n    downButton.style.left = `${\n      graphViewConfig.compWidth - downButtonPos.width / 2\n    }px`;\n    downButton.style.width = `${downButtonPos.width}px`;\n    downButton.style.height = `${downButtonPos.height}px`;\n    downButton.style.visibility = 'visible';\n  });\n</script>\n\n<style lang=\"scss\">.dodrio-vis {\n  overflow: hidden;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.2);\n}\n\n.main-content {\n  border-bottom: solid 1px rgba(0, 0, 0, 0.2);\n  height: min(800px, calc(100vh - 50px));\n  width: 100vw;\n  display: flex;\n  box-sizing: border-box;\n  overflow: visible;\n}\n\n.select-container {\n  border-right: solid 1px rgba(0, 0, 0, 0.2);\n  height: 100%;\n  display: flex;\n  overflow: scroll;\n  flex-direction: column;\n  box-sizing: border-box;\n}\n\n.attention-container {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  overflow: visible;\n  flex-direction: column;\n  box-sizing: border-box;\n  position: relative;\n}\n\n.instance-container {\n  width: 100%;\n  height: 34%;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n\n.lower-container {\n  border-top: solid 1px rgba(0, 0, 0, 0.2);\n  width: 100%;\n  height: 66%;\n  overflow: hidden;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: row;\n  background: #fcfcfc;\n  box-shadow: 0 -5px 5px rgba(0, 0, 0, 0.07);\n  position: absolute;\n  bottom: 0;\n  transition: bottom 300ms ease-in-out;\n}\n\n.graph-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  box-sizing: border-box;\n  position: relative;\n}\n\n.lower-atlas-container {\n  width: 60%;\n  height: 100%;\n  overflow: hidden;\n  box-sizing: border-box;\n  border-left: solid 1px rgba(0, 0, 0, 0.2);\n}\n\n.atlas-container {\n  width: 1000px;\n  max-width: 100%;\n  height: 100%;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  z-index: 11;\n  padding: 10px 0 0 10px;\n  transition: width 500ms ease-in-out, height 500ms ease-in-out, opacity 500ms ease-in-out;\n}\n\n.atlas-sidebar {\n  justify-self: flex-end;\n  background: #fafafa;\n  box-shadow: -3px 0 5px rgba(0, 0, 0, 0.1);\n  position: absolute;\n  right: 989px;\n  top: 300px;\n  width: 400px;\n  height: 450px;\n}\n\n.hidden {\n  visibility: hidden;\n}\n\n:global(.atlas-container.closed) {\n  transition: right 700ms ease-in-out, background-color 100ms ease-in-out 600ms;\n}\n\n.down-button {\n  position: absolute;\n  width: 50px;\n  height: 8px;\n  font-size: 0.7em;\n  visibility: hidden;\n  border-radius: 15px;\n  z-index: 10;\n  cursor: pointer;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  background: white;\n  box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.2);\n  transition: background 300ms ease-in-out, top 300ms ease-in-out;\n}\n.down-button:hover {\n  background: #ede4de;\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  opacity: 1;\n}\n.icon-wrapper svg {\n  height: 20px;\n  color: #a77e62;\n}\n\n.up-down {\n  transform: rotate(180deg);\n}</style>\n\n<div class=\"main\">\n  <div class=\"dodrio-vis\">\n    <Header />\n\n    <Tooltip bind:this={tooltip} />\n\n    <div class=\"main-content\">\n      <div class=\"select-container\" />\n\n      <div class=\"attention-container\">\n        <!-- Instance View -->\n        <div class=\"instance-container\" bind:this={instanceViewDIV}>\n          <Dependency\n            {dependencyDataFilepath}\n            {saliencyDataFilepath}\n            {attentionDataDir}\n            {syntacticHeadDataFilepath}\n            {semanticHeadDataFilepath}\n            {importantHeadDataFilepath}\n            on:close={comparisonCloseHandler}\n            on:open={comparisonOpenHandler}\n          />\n        </div>\n\n        <div class=\"lower-container\" bind:this={lowerContainerDIV}>\n          <!-- Graph View -->\n          <div class=\"graph-container\" bind:this={graphViewDIV}>\n            <GraphView {attentionDataDir} {saliencyDataFilepath} />\n          </div>\n\n          <div class=\"lower-atlas-container\" bind:this={lowerMapViewDIV}>\n            <LowerAtlas\n              {attentionDataDir}\n              {saliencyDataFilepath}\n              {atlasDataFilepath}\n              on:open={atlasOpened}\n            />\n          </div>\n        </div>\n\n        <!-- Map view -->\n        <div\n          class=\"atlas-container\"\n          style=\"visibility=hidden\"\n          bind:this={mapViewDIV}\n        >\n          <Atlas\n            {attentionDataDir}\n            {saliencyDataFilepath}\n            {atlasDataFilepath}\n            on:close={atlasClosed}\n          />\n        </div>\n\n        <div class=\"atlas-sidebar\" class:hidden={!sideInfo.show}>\n          <AtlasSide />\n        </div>\n      </div>\n\n      <TableModal\n        {tableDataFilepath}\n        {embeddingDataFilepath}\n        on:xClicked={() => {}}\n        on:urlTyped={() => {}}\n      />\n\n      <div class=\"down-button\" bind:this={downButton}>\n        <div class=\"icon-wrapper\" on:click={downButtonClicked}>\n          <svg\n            class=\"icon-down\"\n            class:up-down={!buttonDown}\n            viewBox=\"0 0 512 512\"\n          >\n            <path\n              fill=\"none\"\n              stroke=\"currentColor\"\n              stroke-linecap=\"round\"\n              stroke-linejoin=\"round\"\n              stroke-width=\"80\"\n              d=\"M112 184l144 144 144-144\"\n            />\n          </svg>\n        </div>\n      </div>\n    </div>\n  </div>\n  <Article />\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import * as d3 from 'd3';\n\n  let graphSVG = null;\n  let graphData = null;\n\n  const SVGWidth = 800;\n  const SVGHeight = 800;\n\n  const SVGPadding = { top: 3, left: 3, right: 3, bottom: 3 };\n\n  const minNodeRadius = 19;\n  const maxNodeRadius = 40;\n\n  const radialRadius = 300;\n  const radialStrength = 0.8;\n\n  const layoutOptions = {\n    force: {\n      value: 'force',\n      name: 'Force Layout',\n    },\n    radial: {\n      value: 'radial',\n      name: 'Radial Layout',\n    },\n  };\n\n  let config = {\n    borderConstraint: true,\n    showHiddenLink: false,\n    showHiddenNode: false,\n    autoAttention: true,\n    defaultLayout: layoutOptions.force,\n  };\n\n  let forceStrength = { manyBody: 0, attention: 0, textOrder: 0 };\n\n  const round = (num, decimal) => {\n    return Math.round((num + Number.EPSILON) * 10 ** decimal) / 10 ** decimal;\n  };\n\n  const drag = (simulation) => {\n    const dragstarted = (event) => {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    };\n\n    const dragged = (event) => {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    };\n\n    const dragended = (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    };\n\n    return d3\n      .drag()\n      .on('start', dragstarted)\n      .on('drag', dragged)\n      .on('end', dragended);\n  };\n\n  const borderConstraint = (d, nodeRadiusScale) => {\n    let curRadius = minNodeRadius;\n    if (d.saliency !== undefined) {\n      curRadius = nodeRadiusScale(+d.saliency);\n    }\n\n    let width = SVGWidth - SVGPadding.left - SVGPadding.right;\n    let height = SVGWidth - SVGPadding.top - SVGPadding.bottom;\n\n    const left = Math.max(\n      SVGPadding.left + curRadius,\n      Math.min(width - curRadius, d.x)\n    );\n    const top = Math.max(\n      SVGPadding.top + curRadius,\n      Math.min(height - curRadius, d.y)\n    );\n\n    if (config.borderConstraint) {\n      return { top: top, left: left };\n    } else {\n      return { top: d.y, left: d.x };\n    }\n  };\n\n  const bindCheckBox = (simulation, links) => {\n    // Border checkbox\n    let borderCheckBox = d3\n      .select('#checkbox-border')\n      .property('checked', config.borderConstraint);\n\n    borderCheckBox.on('change', (event) => {\n      config.borderConstraint = event.target.checked;\n      simulation.alpha(0.2).restart();\n    });\n\n    // Hidden links\n    let hiddenLinkCheckBox = d3\n      .select('#checkbox-hidden-link')\n      .property('checked', config.showHiddenLink);\n\n    hiddenLinkCheckBox.on('change', (event) => {\n      config.showHiddenLink = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.text-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n\n      d3.select(graphSVG)\n        .select('g.text-hidden-link-group')\n        .style('visibility', config.showHiddenLink ? 'visible' : 'hidden');\n    });\n\n    // Hidden nodes\n    let hiddenNodeCheckBox = d3\n      .select('#checkbox-hidden-node')\n      .property('checked', config.showHiddenNode);\n\n    hiddenNodeCheckBox.on('change', (event) => {\n      config.showHiddenNode = event.target.checked;\n      d3.select(graphSVG)\n        .select('g.hidden-node-group')\n        .style('visibility', config.showHiddenNode ? 'visible' : 'hidden');\n      simulation.alpha(0.05).restart();\n    });\n\n    // Automatic attention link strength checkbox\n    let autoCheckBox = d3\n      .select('#checkbox-auto-attention')\n      .property('checked', config.autoAttention);\n\n    autoCheckBox.on('change', (event) => {\n      config.autoAttention = event.target.checked;\n\n      if (config.autoAttention) {\n        simulation.force(\n          'attentionLink',\n          d3.forceLink(links).id((d) => d.id)\n        );\n        simulation.alpha(0.3).restart();\n      } else {\n        simulation.force('attentionLink').strength(forceStrength.attention);\n        simulation.alpha(0.3).restart();\n      }\n    });\n  };\n\n  const bindSlider = (\n    name,\n    simulation,\n    min,\n    max,\n    defaultValue,\n    nodeRadiusScale = null\n  ) => {\n    let slider = d3\n      .select(`#${name}`)\n      .property('value', ((defaultValue - min) / (max - min)) * 1000);\n\n    slider.on('input', () => {\n      let sliderValue = +slider.property('value');\n      let value = (sliderValue / 1000) * (max - min) + min;\n      forceStrength[name] = value;\n\n      switch (name) {\n        case 'attention':\n          simulation.force('attentionLink').strength(value);\n          // Disable the auto attention\n          d3.select('#checkbox-auto-attention').property('checked', false);\n          config.autoAttention = false;\n          break;\n        case 'textOrder':\n          simulation.force('textLink').strength(value);\n          simulation.force('hiddenTextLink').strength(value);\n          break;\n        case 'manyBody':\n          simulation.force('charge').strength(value);\n          break;\n        case 'collide':\n          simulation\n            .force('collide')\n            .radius((d) => nodeRadiusScale(d.saliency) + value);\n          break;\n      }\n\n      simulation.restart();\n    });\n\n    slider.on('mousedown', (event) => {\n      if (!event.active) simulation.alphaTarget(0.2).restart();\n    });\n\n    slider.on('mouseup', (event) => {\n      if (!event.active) simulation.alphaTarget(0);\n    });\n  };\n\n  const bindSelect = () => {\n    let selectOption = d3\n      .select('#select-layout')\n      .property('value', config.defaultLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayout = selectOption.property('value');\n    });\n  };\n\n  const drawGraph = () => {\n    // Filter the links based on the weight\n    const weightThreshold = 0.05;\n\n    let svg = d3\n      .select(graphSVG)\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Create the data lists\n    let links = graphData.links.filter((d) => d.weight > weightThreshold);\n\n    // Map nodes and links to arrays of objects\n    let nodes = graphData.nodes.map((d) => Object.create(d));\n    links = links.map((d) => Object.create(d));\n\n    // Maintain a set of all existing node indices\n    let nodeIndices = new Set();\n    graphData.nodes.forEach((d) => nodeIndices.add(+d.id));\n\n    // Add text order hidden links\n    let hiddenLinks = [];\n    for (let i = 0; i < nodes.length - 1; i++) {\n      let hiddenLink = {\n        source: +nodes[i].id,\n        target: +nodes[i + 1].id,\n      };\n      hiddenLinks.push(hiddenLink);\n    }\n\n    // Link the last token to the first token\n    hiddenLinks.push({\n      source: +nodes[nodes.length - 1].id,\n      target: nodes[0].id,\n    });\n\n    hiddenLinks = hiddenLinks.map((d) => Object.create(d));\n\n    // console.log(nodes, links);\n\n    // Add intermediate nodes to create bezier curves\n    let nodeByID = new Map(nodes.map((d) => [d.id, d]));\n    let bilinks = [];\n\n    // Add links between intermediate node and its previous token and afterward\n    // token\n    let hiddenTextOrderLinks = [];\n\n    links.forEach((d) => {\n      let source = nodeByID.get(d.source);\n      let target = nodeByID.get(d.target);\n      let intermediate = { hidden: true };\n\n      let curBilink = [source, intermediate, target];\n      curBilink.selfLoop = source === target;\n\n      //nodes.push(intermediate);\n      links.push(\n        { source: source, target: intermediate },\n        { source: intermediate, target: target }\n      );\n\n      bilinks.push(curBilink);\n\n      if (nodeIndices.has(d.source - 1)) {\n        hiddenTextOrderLinks.push({\n          source: nodeByID.get(d.source - 1),\n          target: intermediate,\n        });\n      }\n\n      if (nodeIndices.has(d.source + 1)) {\n        hiddenTextOrderLinks.push({\n          source: intermediate,\n          target: nodeByID.get(d.source + 1),\n        });\n      }\n\n      if (nodeIndices.has(d.target - 1)) {\n        hiddenTextOrderLinks.push({\n          source: nodeByID.get(d.target - 1),\n          target: intermediate,\n        });\n      }\n\n      if (nodeIndices.has(d.target + 1)) {\n        hiddenTextOrderLinks.push({\n          source: intermediate,\n          target: nodeByID.get(d.target + 1),\n        });\n      }\n    });\n\n    // Create a scale for the node radius\n    let allSaliencyScores = nodes.map((d) => +d.saliency);\n    let nodeRadiusScale = d3\n      .scaleLinear()\n      .domain(d3.extent(allSaliencyScores))\n      .range([minNodeRadius, maxNodeRadius])\n      .nice();\n\n    // Define the force\n    let simulation = d3.forceSimulation(nodes);\n    const initManyBodyStrength = -1400;\n    const initAttentionStrength = 0.5;\n    const initTextOrderStrength = 2;\n    const initRadialStrength = 1;\n    const initCollideRadius = 7;\n\n    forceStrength.manyBody = initManyBodyStrength;\n    forceStrength.attention = initAttentionStrength;\n    forceStrength.textOrder = initTextOrderStrength;\n    forceStrength.radial = initRadialStrength;\n    forceStrength.collide = initCollideRadius;\n\n    // Force 1 (ManyBody force)\n    // simulation.force('charge', d3.forceManyBody()\n    //   .strength(initManyBodyStrength)\n    // );\n\n    // // Force 2 (Center force)\n    // simulation.force('center', d3.forceCenter(SVGWidth / 2, SVGHeight / 2));\n\n    // // Force 3 (Link force)\n    // simulation.force('attentionLink', d3.forceLink(links)\n    //   .id(d => d.id)\n    //   //.strength(initAttentionStrength)\n    // );\n\n    // // Force 4 (Text order link force)\n    simulation.force(\n      'textLink',\n      d3\n        .forceLink(hiddenLinks)\n        .id((d) => d.id)\n        .strength(initTextOrderStrength)\n    );\n\n    // // Force 5 (Text order link force on hidden nodes)\n    // simulation.force('hiddenTextLink', d3.forceLink(hiddenTextOrderLinks)\n    //   .id(d => d.id)\n    //   .strength(initTextOrderStrength)\n    // );\n\n    // Force 6 (Radial force)\n    // simulation.force('radial', d3.forceRadial(300)\n    //   .x(SVGWidth / 2)\n    //   .y(SVGHeight / 2)\n    //   .strength(initRadialStrength)\n    // );\n\n    // Force 9 Custom radial force\n    let nodeIndexArray = Array.from(nodeIndices);\n\n    let radialScale = d3\n      .scaleLinear()\n      .domain(d3.extent(nodeIndexArray))\n      .range([-Math.PI / 2, (Math.PI * 3) / 2])\n      .nice();\n\n    simulation.force(\n      'posY',\n      d3\n        .forceY()\n        .y((d) => SVGWidth / 2 + Math.sin(radialScale(d.index)) * radialRadius)\n        .strength(radialStrength)\n    );\n\n    simulation.force(\n      'posX',\n      d3\n        .forceX()\n        .x((d) => SVGWidth / 2 + Math.cos(radialScale(d.index)) * radialRadius)\n        .strength(radialStrength)\n    );\n\n    // Force 7 (Collide force)\n    simulation.force('collide', d3.forceCollide().radius(minNodeRadius));\n\n    // Change the min alpha so that the nodes do not shake at the end (end earlier)\n    // The default alphaMin is 0.0001\n    simulation.alphaMin(0.001);\n\n    // Add arrow markers\n    const arrowBoxWidth = 20;\n    const arrowBoxHeight = 20;\n    svg\n      .append('defs')\n      .append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', [0, 0, arrowBoxWidth, arrowBoxHeight])\n      .attr('refX', arrowBoxWidth / 2)\n      .attr('refY', arrowBoxHeight / 2)\n      .attr('markerWidth', arrowBoxWidth)\n      .attr('markerHeight', arrowBoxHeight)\n      .attr('orient', 'auto-start-reverse')\n      .append('path')\n      .attr('d', 'M0,5 L0,15 L8,10')\n      .attr('stroke', '#C2C2C2')\n      .attr('fill', '#C2C2C2');\n\n    // Add attention links\n    let linkLines = svg\n      .append('g')\n      .attr('class', 'attention-link-group')\n      .attr('stroke', '#C2C2C2')\n      .selectAll('path')\n      .data(bilinks)\n      .join('path')\n      .attr('marker-end', 'url(#arrow)')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textLinkLines = svg\n      .append('g')\n      .attr('class', 'text-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'red')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add hidden text order links\n    let textHiddenLinkLines = svg\n      .append('g')\n      .attr('class', 'text-hidden-link-group')\n      .style('visibility', config.showHiddenLink ? 'visible' : 'hidden')\n      .style('stroke', 'blue')\n      .style('stroke-opacity', 1)\n      .selectAll('line')\n      .data(hiddenTextOrderLinks)\n      .join('line')\n      .attr('class', 'link');\n\n    // Add token nodes\n    let nodeGroups = svg\n      .append('g')\n      .attr('class', 'node-group')\n      .selectAll('g.node')\n      // Need to filter out intermediate nodes\n      .data(nodes.filter((d) => d.id !== undefined))\n      .join('g')\n      .attr('class', 'node')\n      .attr('transform', `translate(${SVGWidth / 2}, ${SVGHeight / 2})`)\n      .call(drag(simulation));\n\n    // Add circle to each node\n    // Create a color scale to represent the text order\n    let colorScale = d3\n      .scaleLinear()\n      .domain(d3.extent(nodeIndices))\n      .range([d3.rgb('#D4E5F4'), d3.rgb('#1E6CB0')]);\n\n    nodeGroups\n      .append('circle')\n      .attr('class', 'node-circle')\n      //.attr('r', d => nodeRadiusScale(+d.saliency))\n      .attr('r', minNodeRadius)\n      .style('fill', (d) => colorScale(d.id));\n\n    // Add token text to each node\n    nodeGroups\n      .append('text')\n      .attr('class', 'node-text')\n      .text((d) => d.token);\n\n    nodeGroups.append('title').text((d) => d.token);\n\n    // Add hidden nodes\n    let hiddenNodeGroups = svg\n      .append('g')\n      .attr('class', 'hidden-node-group')\n      .style('visibility', config.showHiddenNode ? 'visible' : 'hidden')\n      .selectAll('g.hidden-node')\n      // Need to select intermediate nodes\n      .data(nodes.filter((d) => d.id == undefined))\n      .join('g')\n      .attr('class', 'hidden-node');\n\n    hiddenNodeGroups\n      .append('circle')\n      .attr('class', 'hidden-node-circle')\n      .attr('r', 3)\n      .style('fill', 'lightgreen');\n\n    // Simulation tick updates\n    simulation.on('tick', () => {\n      // console.log('Tick');\n\n      // Update the attention links\n      linkLines.attr('d', (d) => {\n        let source = { x: d[0].x, y: d[0].y };\n        let target = { x: d[2].x, y: d[2].y };\n\n        let center = { x: SVGWidth / 2, y: SVGHeight / 2 };\n\n        // We need to shorten the path to leave space for arrow\n        let theta = 1 - minNodeRadius / radialRadius;\n        let modTarget = {\n          x: center.x + (target.x - center.x) * theta,\n          y: center.y + (target.y - center.y) * theta,\n        };\n\n        let modSource = {\n          x: center.x + (source.x - center.x) * theta,\n          y: center.y + (source.y - center.y) * theta,\n        };\n\n        let controlAlpha = 3 / 5;\n\n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (modSource.x - center.x) * controlAlpha,\n          y: center.y + (modSource.y - center.x) * controlAlpha,\n        };\n\n        let controlP2 = {\n          x: center.x + (modTarget.x - center.x) * controlAlpha,\n          y: center.y + (modTarget.y - center.x) * controlAlpha,\n        };\n\n        return `M ${modSource.x},${modSource.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${modTarget.x},${modTarget.y}`;\n      });\n\n      // Update the nodes\n      nodeGroups.attr('transform', (d) => {\n        // Maker sure the nodes are inside the box\n        const coord = borderConstraint(d, nodeRadiusScale);\n        return `translate(${coord.left}, ${coord.top})`;\n      });\n\n      // Update the hidden nodes\n      if (config.showHiddenNode) {\n        hiddenNodeGroups.attr('transform', (d) => {\n          // Maker sure the nodes are inside the box\n          const coord = borderConstraint(d);\n          return `translate(${coord.left}, ${coord.top})`;\n        });\n      }\n\n      // Update the text links\n      if (config.showHiddenLink) {\n        textLinkLines\n          .attr('x1', (d) => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', (d) => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', (d) => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', (d) => borderConstraint(d.target, nodeRadiusScale).top);\n\n        textHiddenLinkLines\n          .attr('x1', (d) => borderConstraint(d.source, nodeRadiusScale).left)\n          .attr('y1', (d) => borderConstraint(d.source, nodeRadiusScale).top)\n          .attr('x2', (d) => borderConstraint(d.target, nodeRadiusScale).left)\n          .attr('y2', (d) => borderConstraint(d.target, nodeRadiusScale).top);\n      }\n    });\n\n    // Register UI elements from the control panel\n    bindSlider('attention', simulation, 0, 10, initAttentionStrength);\n    bindSlider('textOrder', simulation, 0, 10, initTextOrderStrength);\n    bindSlider('manyBody', simulation, -2000, 0, initManyBodyStrength);\n    bindSlider(\n      'collide',\n      simulation,\n      0,\n      20,\n      initCollideRadius,\n      nodeRadiusScale\n    );\n\n    bindCheckBox(simulation, links);\n\n    bindSelect();\n  };\n\n  onMount(async () => {\n    console.log('loading matrix');\n    graphData = await d3.json('PUBLIC_URL/data/twitter_graph_800_9_7.json');\n    console.log('loaded matrix');\n\n    drawGraph();\n  });\n</script>\n\n<style lang=\"scss\">.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 50px;\n}\n\n.slider {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.checkbox {\n  display: flex;\n  flex-direction: row;\n  align-items: baseline;\n  margin-bottom: 5px;\n}\n.checkbox input {\n  margin-right: 7px;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.node-text) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  font-size: 10px;\n  cursor: default;\n}\n\n:global(.link) {\n  fill: none;\n}</style>\n\n<div class=\"graph-view\">\n  <div class=\"control-panel\">\n    <!-- Sliders -->\n    <div class=\"slider\">\n      <label for=\"attention\"\n        >Attention Strength [{config.autoAttention\n          ? 'auto'\n          : round(forceStrength.attention, 2)}]\n      </label>\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"attention\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"textOrder\"\n        >Text Order Strength [{round(forceStrength.textOrder, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"textOrder\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"manyBody\"\n        >ManyBody Strength [{round(forceStrength.manyBody, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"manyBody\"\n      />\n    </div>\n\n    <div class=\"slider\">\n      <label for=\"collide\"\n        >Node Distance [{round(forceStrength.collide, 2)}]</label\n      >\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"1000\"\n        value=\"500\"\n        class=\"slider\"\n        id=\"collide\"\n      />\n    </div>\n\n    <!-- Checkboxes -->\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-auto-attention\" />\n      <label for=\"checkbox-auto-attention\">Auto attention strength </label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-link\" />\n      <label for=\"checkbox-hidden-link\">Show hidden link</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-hidden-node\" />\n      <label for=\"checkbox-hidden-node\">Show hidden node</label>\n    </div>\n\n    <div class=\"checkbox\">\n      <input type=\"checkbox\" id=\"checkbox-border\" />\n      <label for=\"checkbox-border\">Border Constraint</label>\n    </div>\n\n    <!-- Selection -->\n    <div class=\"select\">\n      <select name=\"layout\" id=\"select-layout\">\n        <option value=\"force\">Force Layout</option>\n        <option value=\"radial\">Radial Layout</option>\n      </select>\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <svg class=\"graph-svg\" bind:this={graphSVG} />\n  </div>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import Tooltip from './Tooltip.svelte';\n  import TextClassificationStats from './TextClassificationStats.svelte';\n  import SmallMatrix from './SmallMatrix.svelte';\n  import GraphView from './GraphView.svelte';\n  import * as d3 from 'd3';\n\n  export let width = 400;\n\n  let saliencyDiv = null;\n  let saliencySVG = null;\n  let rightSVG = null;\n  let saliencyComponent = null;\n  let saliencyRow = null;\n  let tooltip = null;\n\n  let tooltipLeft = 0;\n  let tooltipTop = 0;\n  let tooltipHtml = 'tooltip';\n  let tooltipWidth = 65;\n  let tooltipShow = false;\n\n  let svgWidth = 950;\n  let svgHeight = 600;\n\n  let heatmapMode = false;\n\n  const rightSVGWidth = 100;\n  const legendPos = {\n    width: 20,\n    height: 300,\n    top: 5,\n    left: 30,\n  };\n\n  let saliencySVGPadding = {\n    top: 10,\n    left: 10,\n    right: 10,\n    bottom: 20,\n  };\n\n  const tokenPadding = {\n    left: 3,\n    right: 2,\n    top: 4,\n    bottom: 0,\n  };\n\n  // HTML input\n  let saliencyKey = 'negative';\n  let saliencies = null;\n  let filename = 'saliency_list.json';\n\n  const newJSONUploaded = (evt) => {\n    // Load the file\n    let files = evt.target.files;\n    let file = files[0];\n    filename = file.name;\n\n    // Read the file\n    let reader = new FileReader();\n    reader.onload = async (evt) => {\n      // Renew the data and frame count\n      saliencies = await d3.json(evt.target.result);\n    };\n    reader.readAsDataURL(file);\n  };\n\n  const submitClicked = (evt) => {\n    // Remove the preivious views\n    d3.select(saliencyDiv).selectAll('.token').remove();\n\n    d3.select(saliencyRow).select('svg').remove();\n\n    drawSaliencies(saliencies, saliencyKey);\n  };\n\n  const drawSaliencyLegend = (saliencyRow, largestAbs) => {\n    // Add a svg element\n    let rightSVGHeight = +d3.select(saliencySVG).attr('height');\n    rightSVG = d3\n      .select(saliencyRow)\n      .append('svg')\n      .attr('class', 'right-svg')\n      .attr('height', rightSVGHeight)\n      .attr('width', rightSVGWidth);\n\n    // Define the gradient\n    let legentGradientDef = rightSVG\n      .append('defs')\n      .append('linearGradient')\n      .attr('x1', 0)\n      .attr('y1', 1)\n      .attr('x2', 0)\n      .attr('y2', 0)\n      .attr('id', 'legend-gradient');\n\n    legentGradientDef\n      .append('stop')\n      .attr('stop-color', '#eb2f06')\n      .attr('offset', 0);\n\n    legentGradientDef\n      .append('stop')\n      .attr('stop-color', '#ffffff')\n      .attr('offset', 0.5);\n\n    legentGradientDef\n      .append('stop')\n      .attr('stop-color', '#4690C2')\n      .attr('offset', 1);\n\n    // Draw the legend\n    let legendGroup = rightSVG\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', `translate(${legendPos.left}, ${legendPos.top})`);\n\n    legendGroup\n      .append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', legendPos.width)\n      .attr('height', legendPos.height)\n      .style('fill', 'url(#legend-gradient)')\n      .style('stroke', 'black');\n\n    // Draw the legend axis\n    let legendScale = d3\n      .scaleLinear()\n      .domain([-largestAbs, largestAbs])\n      .range([legendPos.height, 0])\n      .nice();\n\n    legendGroup\n      .append('g')\n      .attr('transform', `translate(${legendPos.width}, ${0})`)\n      .call(d3.axisRight(legendScale).ticks(10));\n  };\n\n  const enterHeatmap = () => {\n    const buttonAnimationTime = 1000;\n    const buttonAnimationEase = d3.easeCubicInOut;\n    let tokens = d3\n      .select(saliencySVG)\n      .select('.text-group')\n      .selectAll('.token');\n\n    // Hide the texts\n    tokens\n      .select('.text-token')\n      .transition('text-opacity')\n      .duration(buttonAnimationTime / 2)\n      .ease(buttonAnimationEase)\n      .style('opacity', 0)\n      .on('end', (d, i, g) => {\n        d3.select(g[i]).style('visibility', 'hidden');\n      });\n\n    let tileHeight = +tokens.select('.text-background').attr('height');\n    let containerWidth =\n      svgWidth - saliencySVGPadding.left - saliencySVGPadding.right;\n    let tileGap = 3;\n    let tileColumnNum = Math.floor(containerWidth / (tileHeight + tileGap));\n    let tileNumRow = Math.floor(tokens.nodes().length / tileColumnNum) + 1;\n\n    // To center the heatmap, we need to re-calculate the starting gap\n    let startSpace =\n      (containerWidth - tileColumnNum * (tileHeight + tileGap) + tileGap) / 2;\n\n    // Move the rect positions and change their width\n    tokens\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('transform', (_, i) => {\n        // Compute the current tile's location\n        let cur_r = Math.floor(i / tileColumnNum);\n        let cur_c = i % tileColumnNum;\n        return `translate(${startSpace + cur_c * (tileHeight + tileGap)},\n        ${cur_r * (tileHeight + tileGap)})`;\n      });\n\n    tokens\n      .select('.text-background')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('width', function () {\n        return +d3.select(this).attr('height');\n      });\n\n    // Change the SVG height\n    let tempSVGHeight =\n      saliencySVGPadding.top +\n      saliencySVGPadding.bottom / 2 +\n      tileNumRow * (tileHeight + tileGap) -\n      tileGap;\n\n    d3.select(saliencySVG)\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n\n    d3.select(saliencySVG)\n      .select('.svg-border-rect')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n\n    rightSVG\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', tempSVGHeight);\n  };\n\n  const exitHeatmap = (textTokenPositions, textTokenWidths) => {\n    const buttonAnimationTime = 1000;\n    const buttonAnimationEase = d3.easeCubicInOut;\n    let tokens = d3\n      .select(saliencySVG)\n      .select('.text-group')\n      .selectAll('.token');\n\n    // Show the texts\n    tokens.select('.text-token').style('visibility', 'visible');\n\n    // Restore the position of the text token\n    tokens\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('transform', (_, i) => {\n        let curPos = textTokenPositions[i];\n        return `translate(${curPos.x}, ${curPos.y})`;\n      });\n\n    // Restore text token rect width\n    tokens\n      .select('.text-background')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr(\n        'width',\n        (_, i) => textTokenWidths[i] + tokenPadding.left + tokenPadding.right\n      );\n\n    // Change the SVG height\n    d3.select(saliencySVG)\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n\n    d3.select(saliencySVG)\n      .select('.svg-border-rect')\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n\n    rightSVG\n      .transition('button-animation')\n      .duration(buttonAnimationTime)\n      .ease(buttonAnimationEase)\n      .attr('height', svgHeight);\n\n    // Show the texts\n    tokens\n      .select('.text-token')\n      .transition('text-animation')\n      .delay(buttonAnimationTime / 2)\n      .duration(buttonAnimationTime / 2)\n      .ease(buttonAnimationEase)\n      .style('opacity', 1);\n  };\n\n  const drawSaliencyControl = (textTokenPositions, textTokenWidths) => {\n    if (rightSVG === null) {\n      return;\n    }\n\n    let rectY = legendPos.top + legendPos.height + 10;\n    let heatmapButton = rightSVG\n      .append('rect')\n      .attr('x', legendPos.left)\n      .attr('y', rectY)\n      .attr('class', 'rect-button')\n      .attr('width', 30)\n      .attr('height', 30)\n      .attr('rx', 5)\n      .style('fill', '#F5F5F5')\n      .style('stroke-width', 1)\n      .style('stroke', '#DBDBDB');\n\n    heatmapButton.on('mouseover', (event, d) => {\n      let node = event.currentTarget;\n      let button = d3.select(node);\n      button.style('stroke', 'black');\n    });\n\n    heatmapButton.on('mouseleave', (event, d) => {\n      let node = event.currentTarget;\n      let button = d3.select(node);\n      button.style('stroke', '#DBDBDB');\n    });\n\n    heatmapButton.on('click', () => {\n      if (!heatmapMode) {\n        enterHeatmap();\n        heatmapMode = true;\n      } else {\n        exitHeatmap(textTokenPositions, textTokenWidths);\n        heatmapMode = false;\n      }\n    });\n  };\n\n  const drawSaliencies = (saliencies, key) => {\n    if (saliencySVG === null) {\n      return;\n    }\n\n    let saliencyTokens = saliencies.tokens;\n    // console.log(saliencyTokens);\n\n    // Create a divering color scale from red to green\n    let largestAbs = d3.max(saliencyTokens.map((d) => Math.abs(d[key])));\n    const tokenGap = 4;\n    const rowGap = 30;\n\n    let colorScale = d3\n      .scaleLinear()\n      .domain([-largestAbs, 0, largestAbs])\n      .range([d3.rgb('#eb2f06'), d3.rgb('#ffffff'), d3.rgb('#458FC1')]);\n\n    let container = d3\n      .select(saliencySVG)\n      .attr('height', svgHeight)\n      .attr('width', svgWidth)\n      .append('g')\n      .attr('class', 'main-svg')\n      .attr(\n        'transform',\n        `translate(${saliencySVGPadding.left}, ${saliencySVGPadding.top})`\n      );\n\n    // Add svg border rect\n    d3.select(saliencySVG)\n      .append('rect')\n      .attr('class', 'svg-border-rect')\n      .attr('height', svgHeight)\n      .attr('width', svgWidth)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Add svg control buttons\n\n    let containerWidth =\n      svgWidth - saliencySVGPadding.left - saliencySVGPadding.right;\n\n    let textGroup = container.append('g').attr('class', 'text-group');\n\n    let tokenGroups = textGroup\n      .selectAll('g.token')\n      .data(saliencyTokens)\n      .enter()\n      .append('g')\n      .attr('class', 'token')\n      .attr('id', (_, i) => `token-${i}`);\n\n    let tokenTexts = tokenGroups\n      .append('text')\n      .attr('class', 'text-token')\n      .attr('x', tokenPadding.left)\n      .attr('y', tokenPadding.top)\n      .text((d) => d.token);\n\n    // After the text elements are created, we need to query again to get the\n    // length and width of these elements\n    let textTokenWidths = {};\n    let textTokenPositions = {};\n    let textTokenHeight = null;\n\n    tokenTexts.each(function (_, i) {\n      let bbox = this.getBBox();\n      textTokenWidths[i] = +Number(bbox.width).toFixed(2);\n\n      if (textTokenHeight == null) {\n        textTokenHeight = bbox.height;\n      }\n    });\n\n    let tokenRects = tokenGroups\n      .append('rect')\n      .attr('class', 'text-background')\n      .attr(\n        'width',\n        (_, i) => textTokenWidths[i] + tokenPadding.left + tokenPadding.right\n      )\n      .attr('height', textTokenHeight + tokenPadding.top + tokenPadding.bottom)\n      .style('fill', (d) => colorScale(+d[key]))\n      .lower();\n\n    // Change the positions of tokens based on their width\n    let curPos = { x: 0, y: 0 };\n    let tokenNum = Object.keys(textTokenWidths).length;\n\n    // Change the position of the text token\n    tokenGroups.each(function (_, i) {\n      d3.select(this).attr('transform', `translate(${curPos.x}, ${curPos.y})`);\n\n      // Record the new position\n      textTokenPositions[i] = { x: curPos.x, y: curPos.y };\n\n      // Update the next position\n      let curLineLength =\n        curPos.x +\n        textTokenWidths[i] +\n        tokenPadding.left +\n        tokenPadding.right +\n        tokenGap;\n      if (i + 1 < tokenNum) {\n        curLineLength += textTokenWidths[i + 1];\n      }\n\n      // Shift to next row if needed\n      if (curLineLength > containerWidth) {\n        curPos.y += rowGap;\n        curPos.x = 0;\n      } else {\n        curPos.x =\n          curPos.x +\n          textTokenWidths[i] +\n          tokenPadding.left +\n          tokenPadding.right +\n          tokenGap;\n      }\n    });\n\n    // Resize the SVG based on the content height\n    svgHeight =\n      curPos.y +\n      textTokenHeight +\n      tokenPadding.top +\n      tokenPadding.bottom +\n      saliencySVGPadding.bottom;\n    d3.select(saliencySVG)\n      .attr('height', svgHeight)\n      .select('.svg-border-rect')\n      .attr('height', svgHeight);\n\n    // Mouseover function\n    tokenGroups.on('mouseover', (event, d) => {\n      let node = event.currentTarget;\n      let curGroup = d3.select(node);\n      let curI = d3\n        .select(node.parentNode)\n        .nodes()\n        .indexOf(event.currentTarget);\n\n      // Highlight the border\n      curGroup.select('.text-background').style('stroke', 'rgba(0, 0, 0, 1)');\n\n      // Show the tooltip\n      tooltipShow = true;\n      let position = node.getBoundingClientRect();\n\n      let curWidth = position.right - position.left;\n      let tooltipCenterX = position.x + curWidth / 2;\n      let tooltipCenterY = position.y - 40 + window.scrollY;\n\n      tooltipHtml = d3.format('.4f')(+d[key]);\n      tooltipLeft = tooltipCenterX - tooltipWidth / 2;\n      tooltipTop = tooltipCenterY;\n    });\n\n    // Mouseleave function\n    tokenGroups.on('mouseleave', (event, d) => {\n      let node = event.currentTarget;\n      let curGroup = d3.select(node);\n      let curI = d3\n        .select(node.parentNode)\n        .nodes()\n        .indexOf(event.currentTarget);\n\n      // Dehighlight the border\n      curGroup.select('.text-background').style('stroke', 'none');\n\n      // Hide the tooltip\n      tooltipShow = false;\n    });\n\n    drawSaliencyLegend(saliencyRow, largestAbs);\n    drawSaliencyControl(textTokenPositions, textTokenWidths);\n  };\n\n  onMount(async () => {\n    console.log('loading');\n    saliencies = await d3.json('PUBLIC_URL/data/saliency_list.json');\n    console.log('loaded');\n\n    drawSaliencies(saliencies, saliencyKey);\n  });\n</script>\n\n<style lang=\"scss\">.saliency-component {\n  display: flex;\n  flex-direction: column;\n}\n\n.saliency-row {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n}\n\n:global(.saliency-svg .token) {\n  cursor: pointer;\n}\n\n:global(.saliency-svg .text-token) {\n  font-size: 1em;\n  dominant-baseline: hanging;\n}\n\n:global(.saliency-svg .text-background) {\n  shape-rendering: crispEdges;\n  stroke-width: 1px;\n}\n\n:global(.right-svg .rect-button) {\n  cursor: pointer;\n}\n\n.control-panel {\n  display: flex;\n  flex-direction: row-reverse;\n  margin: 10px 0;\n  padding: 0 100px 0 0;\n}\n.control-panel .input {\n  margin: 0 10px;\n  width: 120px;\n}\n\n.large {\n  font-size: 1em;\n  padding-left: 1em;\n  padding-right: 1em;\n  padding-top: 1.2em;\n  padding-bottom: 1.2em;\n  margin-right: 10px;\n}</style>\n\n<div class=\"saliency-component\" bind:this={saliencyComponent}>\n  <Tooltip\n    bind:this={tooltip}\n    left={tooltipLeft}\n    top={tooltipTop}\n    {tooltipHtml}\n    width={tooltipWidth}\n    {tooltipShow}\n  />\n\n  <GraphView />\n  <SmallMatrix />\n\n  <div class=\"saliency-row\" bind:this={saliencyRow}>\n    <svg class=\"saliency-svg\" bind:this={saliencySVG} />\n  </div>\n\n  <div class=\"control-panel\">\n    <button class=\"button\" on:click={submitClicked}>Submit</button>\n\n    <input\n      class=\"input\"\n      type=\"text\"\n      placeholder=\"Saliency Key\"\n      bind:value={saliencyKey}\n    />\n\n    <div class=\"file is-normal-small\">\n      <label class=\"file-label\">\n        <input\n          class=\"file-input is-normal-small\"\n          type=\"file\"\n          name=\"json\"\n          accept=\".json\"\n          on:change={newJSONUploaded}\n        />\n        <span class=\"file-cta is-normal-small no-top-border-radius\">\n          <span class=\"file-icon\">\n            <i class=\"fas fa-upload\" />\n          </span>\n          <span class=\"file-label\"> JSON </span>\n        </span>\n      </label>\n    </div>\n\n    {#if filename !== null}\n      <div class=\"tag is-light is-large large\">\n        {filename}\n      </div>\n    {/if}\n    {#if saliencies != null}\n      <TextClassificationStats\n        trueLabel={saliencies.meta['true_label']}\n        predictedLabel={saliencies.meta['predicted_label']}\n        softmaxScores={saliencies.meta['softmax_scores']}\n      />\n    {/if}\n  </div>\n</div>\n",
    "<script>\n  import { onMount, createEventDispatcher } from 'svelte';\n  import { tableModalStore, instanceIDStore, currInstanceStore } from './store';\n  import EmbeddingView from './EmbeddingView.svelte';\n  import TableView from './TableView.svelte';\n\n  export let tableDataFilepath;\n  export let embeddingDataFilepath;\n\n  let modalComponent;\n\n  const dispatch = createEventDispatcher();\n  let modalInfo = {\n    show: false\n  };\n  let tempID = null;\n  currInstanceStore.subscribe(value => {tempID = value;});\n\n  tableModalStore.set(modalInfo);\n  tableModalStore.subscribe(value => {modalInfo = value});\n\n  const crossClicked = () => {\n    modalInfo.show = false;\n    tableModalStore.set(modalInfo);\n    // Dispatch the parent component\n    dispatch('xClicked', {preImage: modalInfo.preImage});\n  };\n\n  const okClicked = () => {\n    modalInfo.show = false;\n    instanceIDStore.set(tempID);\n    // Dispatch the parent component\n    dispatch('xClicked', {preImage: modalInfo.preImage});\n  };\n\n  onMount(() => {\n\n  });\n</script>\n\n<style>\n\n  .modal-container {\n    margin: 0 auto;\n    display: flex;\n    flex-direction: row-reverse;\n    align-items: center;\n  }\n\n  .modal-card {\n    width: '';\n    max-width: 700px;\n    max-height: 600px;\n    position: relative;\n  }\n\n  .modal-card-title {\n    font-size: 20px;\n  }\n\n  .modal-card-head {\n    padding: 15px 20px;\n  }\n\n  .modal-card-body {\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-start;\n    align-items: flex-start;\n    padding: 0;\n  }\n\n  .modal-card-foot {\n    padding: 12px 20px;\n    justify-content: space-between;\n  }\n\n  .is-smaller {\n    font-size: 15px;\n    padding: 0.5em 0.8em;\n    max-height: 2.2em;\n  }\n\n  .embedding-div {\n    width: 350px;\n    height: 351px;\n    /* margin-top: 50px; */\n    margin-right: 20px;\n    z-index: 1;\n    background: white;\n    border-top-right-radius: 6px;\n    border-bottom-right-radius: 6px;\n    border-radius: 6px;\n  }\n\n  .center {\n    text-align: center;\n  }\n\n</style>\n\n\n<div class=\"modal-component\"\n  bind:this={modalComponent}>\n\n  <div class=\"modal\"\n    id=\"input-modal\"\n    class:is-active={modalInfo.show}>\n\n    <div class=\"modal-background\" on:click={crossClicked}></div>\n\n    <div class='modal-container'>\n\n      <div class=\"modal-card\">\n        <header class=\"modal-card-head\">\n          <p class=\"modal-card-title\">Select Input Sentence</p>\n          <button class=\"delete\" aria-label=\"close\" on:click={crossClicked}></button>\n        </header>\n\n        <section class=\"modal-card-body\">\n          \n          <TableView tableDataFilepath={tableDataFilepath} />\n\n        </section>\n\n        <footer class=\"modal-card-foot\">\n\n          <div class=\"button-container\">\n            <button class=\"button is-smaller\"\n              on:click={crossClicked}>\n              Cancel\n            </button>\n\n            <button class=\"button is-success is-smaller\"\n              on:click={okClicked}>\n              Add\n            </button>\n          </div>\n\n        </footer>\n\n      </div>\n\n      <div class='embedding-div'>\n        <header class=\"modal-card-head\">\n          <p class=\"modal-card-title center\">Instance Embedding</p>\n        </header>\n\n        <EmbeddingView embeddingDataFilepath={embeddingDataFilepath} />\n      </div>\n\n    </div>\n\n  </div>\n\n</div>",
    "<script>\n  import { onMount, afterUpdate } from 'svelte';\n  import { tableViewConfigStore, currInstanceStore } from './store';\n  import * as d3 from 'd3';\n\n  export let tableDataFilepath;\n\n  // Shared states\n  let tableViewConfig = undefined;\n\n  let tableData = [];\n  let selectedInstanceId = 23;\n  let currHighlightedRow = 0;\n  let mostRecentColumnSortCriterion = 'true_label';\n  let isEmbeddingViewUpdate = false;\n\n  let sortState = {\n    sentence: {\n      selected: false,\n      up: false,\n    },\n    true_label: {\n      selected: false,\n      up: false,\n    },\n    predicted_label: {\n      selected: false,\n      up: false,\n    },\n    logit_distance: {\n      selected: false,\n      up: false,\n    },\n  };\n\n  let selectedRowColor = 'hsla(0, 0%, 0%, 0.1)';\n\n  let sortBy = { col: 'id', ascending: true };\n\n  $: selectedInstanceId,\n    (function () {\n      if (\n        document.getElementsByTagName('table')[0] &&\n        document.getElementsByTagName('table')[0].children[1].children[\n          currHighlightedRow\n        ]\n      ) {\n        // We sort by most recent column so that placing\n        // the selected instance at the top of the table does\n        // not affect the previous sorting. Reactive for\n        // when the instanceId store value changes from\n        // another source (ie. EmbeddingView).\n        if (isEmbeddingViewUpdate) {\n          // console.log(mostRecentColumnSortCriterion);\n          sort(mostRecentColumnSortCriterion);\n        }\n      }\n      isEmbeddingViewUpdate = true;\n    })();\n\n  $: sort = (column) => {\n    mostRecentColumnSortCriterion = column;\n\n    if (sortBy.col == column) {\n      sortBy.ascending = !sortBy.ascending;\n      sortState[column].up = sortBy.ascending;\n      sortState = sortState;\n    } else {\n      if (sortState[sortBy.col] !== undefined) {\n        sortState[sortBy.col].selected = false;\n      }\n\n      sortBy.col = column;\n      sortBy.ascending = true;\n      sortState[column].selected = true;\n      sortState[column].up = true;\n      sortState = sortState;\n    }\n\n    let sortModifier = sortBy.ascending ? 1 : -1;\n\n    let sort = (a, b) =>\n      a[column] < b[column]\n        ? -1 * sortModifier\n        : a[column] > b[column]\n        ? 1 * sortModifier\n        : 0;\n\n    tableData = tableData.sort(sort);\n\n    // If we have an active instance, move it to the begining of the\n    // table regardless of the sort.\n    tableData.forEach(function (item, i) {\n      if (item.id == selectedInstanceId) {\n        tableData.splice(i, 1);\n        tableData.unshift(item);\n      }\n    });\n    // Update background row color.\n    // Remove style from previously selected row.\n    document.getElementsByTagName('table')[0].children[1].children[\n      currHighlightedRow\n    ].style = 'background-color: inherit;';\n\n    // Add style to top row, since sorting\n    // by column moves selected row to the top.\n    document.getElementsByTagName('table')[0].children[1].children[0].style =\n      'background-color: ' + selectedRowColor;\n    currHighlightedRow = 0;\n    isEmbeddingViewUpdate = false;\n  };\n\n  $: getInstance = (row) => {\n    currInstanceStore.set(row.cells[0].innerText);\n    isEmbeddingViewUpdate = false;\n    // console.log('selected row id: ' + row.cells[0].innerText);\n    // Remove style from previously selected row.\n    document.getElementsByTagName('table')[0].children[1].children[\n      currHighlightedRow\n    ].style = 'background-color: inherit;';\n\n    // Style newly selected row.\n    row.style = 'background-color: ' + selectedRowColor;\n    currHighlightedRow = row.rowIndex - 1;\n  };\n\n  tableViewConfigStore.subscribe((value) => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined) {\n      if (\n        tableViewConfig === undefined ||\n        (tableViewConfig.compHeight !== value.compHeight &&\n          tableViewConfig.compWidth !== value.compWidth)\n      ) {\n        tableViewConfig = value;\n      }\n    }\n  });\n\n  currInstanceStore.subscribe((value) => {\n    selectedInstanceId = value;\n  });\n\n  onMount(async () => {\n    // console.log('loading table');\n    tableData = await d3.json(tableDataFilepath);\n    // console.log('loaded table');\n  });\n</script>\n\n<style lang=\"scss\">table,\nth,\ntd {\n  font-size: 0.9em;\n}\n\ntable {\n  width: 100%;\n  table-layout: auto;\n  text-align: center;\n  border-collapse: collapse;\n}\n\ntd {\n  padding: 0 20px 10px 20px;\n}\n\nth {\n  padding: 10px 10px;\n  position: sticky;\n  z-index: 100;\n  top: 0;\n  background: #fafafa;\n  background-clip: padding-box;\n  border-bottom: 1px solid #c7c7c7;\n}\nth.sentence {\n  width: 61%;\n  padding: 10px 20px;\n}\nth.true {\n  width: 11%;\n  padding: 10px 15px;\n}\nth.predicted {\n  width: 15%;\n  padding: 10px 15px;\n}\nth.error {\n  width: 13%;\n  padding: 10px 15px;\n}\n\n.sentence-div {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  cursor: pointer;\n}\n.sentence-div:hover img {\n  opacity: 0.5;\n}\n.sentence-div img {\n  margin-left: 3px;\n  width: 20px;\n  opacity: 0.1;\n}\n.sentence-div img.selected {\n  opacity: 1;\n}\n\n.true-div,\n.predicted-div,\n.error-div {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n  cursor: pointer;\n}\n.true-div:hover img,\n.predicted-div:hover img,\n.error-div:hover img {\n  opacity: 0.5;\n}\n.true-div img,\n.predicted-div img,\n.error-div img {\n  margin-left: 3px;\n  width: 20px;\n  opacity: 0.1;\n}\n.true-div img.selected,\n.predicted-div img.selected,\n.error-div img.selected {\n  opacity: 1;\n}\n\ntr:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n  cursor: default;\n}\n\ntr:first-child {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n\ntd.number-row {\n  text-align: right;\n}\n\ntd.text-row {\n  text-align: left;\n}</style>\n\n<div class=\"table-view\">\n  <table>\n    <thead>\n      <tr>\n        <th style=\"display: none;\" on:click={sort('id')}>id</th>\n        <th class=\"sentence\" on:click={sort('sentence')}>\n          <div class=\"sentence-div\">\n            Sentence\n            <img\n              src={sortState.sentence.up\n                ? 'PUBLIC_URL/figures/up.svg'\n                : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState.sentence.selected}\n              alt=\"sort logo\"\n            />\n          </div>\n        </th>\n\n        <th class=\"true\" on:click={sort('true_label')}>\n          <div class=\"true-div\">\n            True\n            <img\n              src={sortState['true_label'].up\n                ? 'PUBLIC_URL/figures/up.svg'\n                : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['true_label'].selected}\n              alt=\"sort logo\"\n            />\n          </div>\n        </th>\n\n        <th class=\"predicted\" on:click={sort('predicted_label')}>\n          <div class=\"predicted-div\">\n            Predicted\n            <img\n              src={sortState['predicted_label'].up\n                ? 'PUBLIC_URL/figures/up.svg'\n                : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['predicted_label'].selected}\n              alt=\"sort logo\"\n            />\n          </div>\n        </th>\n\n        <th class=\"error\" on:click={sort('logit_distance')}>\n          <div class=\"error-div\">\n            Error\n            <img\n              src={sortState['logit_distance'].up\n                ? 'PUBLIC_URL/figures/up.svg'\n                : 'PUBLIC_URL/figures/down.svg'}\n              class:selected={sortState['logit_distance'].selected}\n              alt=\"sort logo\"\n            />\n          </div>\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      {#each tableData as row}\n        <tr on:click={getInstance(this)}>\n          <td style=\"display: none;\">{row.id}</td>\n          <td class=\"text-row\">{row.sentence}</td>\n          <td class=\"number-row\">{row.true_label}</td>\n          <td class=\"number-row\">{row.predicted_label}</td>\n          <td class=\"number-row\">{Number(row.logit_distance.toFixed(2))}</td>\n        </tr>\n      {/each}\n    </tbody>\n  </table>\n</div>\n",
    "<script>\n  import { onMount } from 'svelte';\n  \n  export let trueLabel;\n  export let predictedLabel;\n  // Dictionary of {label : score}\n  export let softmaxScores;\n  $: {\n    d3.select(chart)\n      .selectAll('*')\n      .remove();\n    drawSoftmaxChart(); \n  }\n\n  let chart;\n  let softmaxScoreDicts;\n  let trueLabelTagStyle\n    $: {\n      switch(trueLabel) {\n        case \"positive\":\n          trueLabelTagStyle = \"tag is-rounded is-success\"\n          break;\n        case \"negative\":\n          trueLabelTagStyle = \"tag is-rounded is-danger\"\n          break;\n        default:\n          trueLabelTagStyle = \"tag is-rounded is-light\"\n      }\n    };\n  let predictedLabelTagStyle\n    $: {\n      switch(predictedLabel) {\n        case \"positive\":\n          predictedLabelTagStyle = \"tag is-rounded is-success\"\n          break;\n        case \"negative\":\n          predictedLabelTagStyle = \"tag is-rounded is-danger\"\n          break;\n        default:\n          predictedLabelTagStyle = \"tag is-rounded is-light\"\n      }\n    };\n\n  function preprocessSoftmaxScores() {\n    let softmaxScoreDicts = [];\n    let labels = Object.keys(softmaxScores);\n    labels.forEach(function(label) {\n      let softmaxScoreEntry = {}\n      softmaxScoreEntry['label'] = label;\n      softmaxScoreEntry['score'] = softmaxScores[label];\n      softmaxScoreDicts.push(softmaxScoreEntry);\n    })\n    return softmaxScoreDicts;\n  }\n\n  const drawSoftmaxChart = () => {\n    softmaxScoreDicts = preprocessSoftmaxScores();\n\n    let margin = {top: 10, right: 10, bottom: 30, left: 40};\n    let svgWidth = 180, svgHeight = 110;\n    let height = svgHeight- margin.top- margin.bottom, width = svgWidth - margin.left - margin.right;\n\n    let x = d3.scaleBand().rangeRound([0, width]).padding(0.1),\n        y = d3.scaleLinear().rangeRound([height, 0]);\n\n    x.domain(softmaxScoreDicts.map(function(d) { return d.label; }));\n    y.domain([0, d3.max(softmaxScoreDicts, function(d) { return d.score; })]);\n\n    let svg = d3.select(chart).append(\"svg\");\n    svg.attr('height', svgHeight)\n        .attr('width', svgWidth);\n\n    svg = svg.append(\"g\")\n             .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    svg.append(\"g\")\n        .attr(\"class\", \"axis axis--x\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(d3.axisBottom(x));\n\n    svg.append(\"g\")\n        .attr(\"class\", \"axis axis--y\")\n        .call(d3.axisLeft(y).ticks(5));\n            \n    let bars = svg.selectAll('.bar')\n        .data(softmaxScoreDicts)\n        .enter()\n        .append(\"g\");\n\n    bars.append('rect')\n        .attr('class', 'bar')\n        .attr(\"x\", function(d) { return x(d.label); })\n        .attr(\"y\", function(d) { return y(d.score); })\n        .attr(\"width\", x.bandwidth())\n        .attr(\"height\", function(d) { return height - y(d.score); })\n        .attr(\"fill\", \"#DCDCDC\");\n  }\n\n  onMount(async () => {\n    drawSoftmaxChart();\n  })\n</script>\n\n<style>\n  .text-classification-stats {\n    display: flex;\n    flex-basis: 0;\n    flex-grow: 1;\n    flex-shrink: 1;\n  }\n\n  .stats-1 {\n    flex: 70%;\n  }\n  .stats-2 {\n    flex: 30%;\n    text-align: center;\n  }\n\n  .stats-1 span {\n    font-size: 0.75em;\n    font-weight: bold;\n  }\n  .stats-2 span {\n    font-size: 0.75em;\n    font-weight: bold;\n  }\n\n  .tag {\n    vertical-align: middle;\n  }\n</style>\n\n<div class='text-classification-stats'>\n  <div class=\"stats-1\">\n    <span>\n      Predicted Label:\n      <span id=\"predictedLabel\" class={predictedLabelTagStyle}>{predictedLabel}</span>&nbsp;\n      True Label:\n      <span id=\"trueLabel\" class={trueLabelTagStyle}>{trueLabel}</span>\n    </span>\n  </div>\n\n  <div class=\"stats-2\">\n    <span class=\"has-text-centered\">\n      Softmax Scores\n    </span>\n    <div bind:this={chart}></div>\n  </div>\n</div>",
    "<script>\n  import * as d3 from 'd3';\n\n  export let tooltipShow = false;\n  export let tooltipHtml = \"1.23\";\n  export let left = 0;\n  export let top = 0;\n  export let width = 80;\n  export let maxWidth = 80;\n  export let fontSize = '1em';\n\n  let tooltip = null;\n\n  $: style = `left: ${left}px; top: ${top}px; width: ${width}px; max-width: \n              ${maxWidth}px; font-size: ${fontSize}`;\n  $: tooltipShow, function() {\n    if (tooltip === null) return;\n    let selection = d3.select(tooltip);\n\n    if (tooltipShow) {\n      selection.style('visibility', 'visible');\n\n      d3.select(tooltip)\n        .transition()\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 1);\n    } else {\n      d3.select(tooltip)\n        .transition()\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 0)\n        .on('end', function() {\n          d3.select(this)\n            .style('visibility', 'hidden');\n        });\n    }\n  }();\n\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    color: white;\n    background-color: black;\n    padding: 5px 5px;\n    border-radius: 5px;\n    opacity: 1;\n    z-index: 10;\n    visibility: visible;\n    transition: opacity 150ms, visibility 150ms;\n    display: flex;\n    justify-content: center;\n    box-sizing: border-box;\n  }\n</style>\n\n<div class=\"tooltip\" style={style} bind:this={tooltip}>\n  {@html tooltipHtml}\n</div>",
    "<script>\n  import * as d3 from 'd3';\n  import { onMount } from 'svelte';\n  import { tooltipConfigStore } from './store';\n\n  let tooltipConfig = {\n    show: false,\n    html: 'null',\n    left: 0,\n    top: 0,\n    width: 80,\n    maxWidth: 80,\n    fontSize: '1em'\n  };\n\n  let tooltip = null;\n\n  $: style = `left: ${tooltipConfig.left}px; top: ${tooltipConfig.top}px;\n    width: ${tooltipConfig.width}px; max-width: ${tooltipConfig.maxWidth}px;\n    font-size: ${tooltipConfig.fontSize}`;\n\n  tooltipConfigStore.subscribe(value => {\n\n    let selection = d3.select(tooltip);\n    if (value.show) {\n      selection.style('visibility', 'visible');\n      d3.select(tooltip)\n        .transition()\n        .duration(100)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 1);\n    } else {\n      d3.select(tooltip)\n        .transition()\n        .delay(100)\n        .duration(200)\n        .ease(d3.easeQuadInOut)\n        .style('opacity', 0)\n        .on('end', function() {\n          d3.select(this)\n            .style('visibility', 'hidden');\n        });\n    }\n\n    tooltipConfig = value;\n  });\n\n  onMount(() => {\n    d3.select(tooltip).style('visibility', 'hidden');\n    tooltipConfigStore.set(tooltipConfig);\n  });\n\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    color: white;\n    background-color: black;\n    padding: 5px 5px;\n    border-radius: 5px;\n    opacity: 1;\n    z-index: 20;\n    visibility: visible;\n    transition: opacity 150ms, visibility 150ms;\n    display: flex;\n    justify-content: center;\n    box-sizing: border-box;\n    pointer-events: none;\n  }\n</style>\n\n<div class=\"tooltip\" style={style} bind:this={tooltip}>\n  {@html tooltipConfig.html}\n</div>",
    "<script>\n  import Youtube from './Youtube.svelte';\n  let currentPlayer;\n</script>\n\n<style lang=\"scss\">#description {\n  margin-bottom: 60px;\n  margin-left: auto;\n  margin-right: auto;\n  max-width: 78ch;\n}\n\n#description h2 {\n  color: #444;\n  font-size: 40px;\n  font-weight: 450;\n  margin-bottom: 12px;\n  margin-top: 60px;\n  border-bottom: 1px solid #eaecef;\n}\n\n#description h4 {\n  color: #444;\n  font-size: 32px;\n  font-weight: 450;\n  margin-bottom: 8px;\n  margin-top: 44px;\n}\n\n#description h6 {\n  color: #444;\n  font-size: 24px;\n  font-weight: 450;\n  margin-bottom: 8px;\n  margin-top: 44px;\n}\n\n#description p {\n  margin: 16px 0;\n}\n\n#description p img {\n  vertical-align: middle;\n}\n\n#description .figure-caption {\n  font-size: 13px;\n  margin-top: 5px;\n}\n\n#description ol {\n  margin-left: 40px;\n}\n\n#description p,\n#description div,\n#description li {\n  color: #555;\n  font-size: 17px;\n  line-height: 1.6;\n}\n\n#description small {\n  font-size: 12px;\n}\n\n#description ol li img {\n  vertical-align: middle;\n}\n\n#description .video-link {\n  color: #3273dc;\n  cursor: pointer;\n  font-weight: normal;\n  text-decoration: none;\n}\n\n#description ul {\n  list-style-type: disc;\n  margin-top: -10px;\n  margin-left: 40px;\n  margin-bottom: 15px;\n}\n\n#description a:hover,\n#description .video-link:hover {\n  text-decoration: underline;\n}\n\n.figure,\n.video {\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.dodrio-text {\n  color: #613f23;\n  font-family: \"Fredoka One\";\n}\n\n.paper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  margin-top: 30px;\n}\n\n.paper-image {\n  height: 100%;\n  border-radius: 5px;\n  border: 2px solid #e6e6e6;\n  margin-right: 15px;\n}\n.paper-image img {\n  height: 110px;\n}\n.paper-image:hover {\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.1);\n}\n\n.paper-info__title {\n  font-weight: 500;\n}\n.paper-info__title a {\n  color: #444;\n}\n\n.paper-info {\n  display: flex;\n  flex-direction: column;\n}</style>\n\n<body>\n  <div id=\"description\">\n    <h2>\n      What is <span class=\"dodrio-text\"\n        ><img\n          class=\"icon is-rounded\"\n          src=\"PUBLIC_URL/figures/dodrio-logo.svg\"\n          style=\"height: 30px; width: 30px;\"\n          alt=\"Dodrio logo\"\n        />&nbsp;Dodrio</span\n      >?\n    </h2>\n    <p>\n      <a\n        href=\"https://arxiv.org/pdf/1706.03762.pdf\"\n        title=\"Attention Is All You Need\">Transformers</a\n      >\n      are sequence transduction models that excel at modeling long-term dependencies\n      with non-sequential processing. These attributes have made Transformers pervasive\n      in the NLP domain as natural language tasks benefit from the multi-headed attention\n      mechanism to more effectively model longer text, and non-sequential computations\n      no longer inhibit parallelization. Transformers now replace\n      <a\n        href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.676.4320&rep=rep1&type=pdf\"\n        title=\"Long Short-Term Memory\">LSTMs</a\n      >\n      as the state-of-the-art model architecture for\n      <a\n        href=\"https://www.aclweb.org/anthology/W18-5446.pdf\"\n        title=\"GLUE NLP Benchmarks\">NLP tasks</a\n      >.\n    </p>\n    <p>\n      We present <span class=\"dodrio-text\">Dodrio</span>, an interactive\n      visualization tool to help NLP researchers and practitioners analyze and\n      compare attention mechanisms with linguistic knowledge.\n    </p>\n    <h2>Why is <span class=\"dodrio-text\">Dodrio</span> useful?</h2>\n    <p>\n      In a large, pre-trained, high-performing model like <a\n        href=\"https://www.aclweb.org/anthology/N19-1423.pdf\"\n        title=\"BERT\">BERT</a\n      >, there are 12 layers each with 12 distinct self-attention heads.\n      Attention heads in Transformers are comprised of weights incurred from\n      tokens when calculating the next representation of the current token.\n      These attention weights then make up an attention map at every attention\n      head (a detailed explanation of this matrix calculation is available\n      <a\n        href=\"http://jalammar.github.io/illustrated-transformer/\"\n        title=\"Self-attention Calculation\">here</a\n      >). As every token in a sentence attends to every other token, we have 12\n      &times; 12 &times; number of tokens &times; number of tokens attention\n      weights in BERT per text instance! In addition, researchers find some\n      attention heads are correlated to linguistic knowledge such as word\n      semantics and text syntactic dependencies. Therefore, to more easily\n      analyze attention weights, researchers need (1) <em>abstractions</em> and\n      (2) <em>linguistic knowledge contexts</em>.\n    </p>\n    <p>\n      <span class=\"dodrio-text\">Dodrio</span> addresses the challenges of\n      interpreting attention weights through an interactive visualization system\n      that provides <em>attention head summarization</em> and\n      <em>semantic and syntractic knowledge contexts</em>. By identifying the\n      linguistic properties that an attention head attends to in the\n      <em>Attention Head Overview</em>\n      (bottom right), you can click the attention head to explore the semantic\n      and syntactic significance of the sentence at the selected attention head.\n      If you are interested in the lexical dependencies in a sentence, you can\n      explore a syntactically important head in the <em>Dependency View</em> and\n      accompanying <em>Comparison View</em> (top), while semantically important\n      heads can be investigated in the <em>Semantic Attention Graph</em> view\n      (bottom left). We encourage you to further investigate the multi-headed\n      attention mechanism across various text instances with interesting\n      linguistic features (eg. coreferences, word sense, etc.) in the\n      <em>Instance Selection View</em>\n      by clicking the\n      <img\n        class=\"icon is-rounded\"\n        src=\"PUBLIC_URL/figures/edit.svg\"\n        alt=\"edit icon\"\n      /> icon in the toolbar at the top of the interface.\n    </p>\n    <h2>Interactive features</h2>\n    <ol>\n      <li>\n        <strong>Explore sentences with interesting lexical features</strong> by\n        changing the active instance being visualized\n        <img\n          class=\"icon is-rounded\"\n          src=\"PUBLIC_URL/figures/edit.svg\"\n          alt=\"edit sentence icon\"\n        /> to understand how a Transformer attends to tokens in a sentence when solving\n        language tasks.\n      </li>\n      <li>\n        <strong>Open the expanded <em>Attention Head Overview</em></strong> by\n        clicking the\n        <img\n          class=\"is-rounded\"\n          style=\"height: 26px;\"\n          src=\"PUBLIC_URL/figures/article-overview-detail.png\"\n          alt=\"detail icon\"\n        /> button to see an detailed overview of attention heads.\n      </li>\n      <li>\n        <strong\n          >Edit the <em>Semantic Attention Graph</em> visualization parameters</strong\n        >\n        to more easily identify strong attention weights and customize the graph\n        representation by adjusting the parameters in\n        <i class=\"fas fa-sliders-h\" />.\n      </li>\n      <li>\n        <strong>Filter dependency relations</strong> visualized by selecting the\n        <img\n          class=\"is-rounded\"\n          style=\"height: 26px;\"\n          src=\"PUBLIC_URL/figures/article-syntactic-rel-selection.png\"\n          alt=\"filter relations icon\"\n        /> icon in the upper toolbar.\n      </li>\n    </ol>\n    <h2>Video Tutorial</h2>\n    <ul>\n      <li class=\"video-link\" on:click={currentPlayer.play(0)}>\n        Dodrio Introduction\n        <small>(0:00-0:08)</small>\n      </li>\n      <li class=\"video-link\" on:click={currentPlayer.play(8)}>\n        <em>Attention Head Overview</em>\n        <small>(0:08-0:36)</small>\n      </li>\n      <li class=\"video-link\" on:click={currentPlayer.play(36)}>\n        <em>Semantic Attention Graph</em>\n        <small>(0:36-1:19)</small>\n      </li>\n      <li class=\"video-link\" on:click={currentPlayer.play(79)}>\n        <em>Dependency View</em> and <em>Dependency Comparison View</em>\n        <small>(1:19-1:49)</small>\n      </li>\n      <li class=\"video-link\" on:click={currentPlayer.play(109)}>\n        <em>Instance Selection View</em>\n        <small>(1:49-1:53)</small>\n      </li>\n      <li class=\"video-link\" on:click={currentPlayer.play(117)}>\n        Credits\n        <small>(1:57-1:59)</small>\n      </li>\n    </ul>\n    <div class=\"video\">\n      <Youtube\n        videoId=\"qB-T9j7UTgE\"\n        playerId=\"demo_video\"\n        bind:this={currentPlayer}\n      />\n    </div>\n\n    <h2>How is <span class=\"dodrio-text\">Dodrio</span> implemented?</h2>\n    <p>\n      <span class=\"dodrio-text\">Dodrio</span> visualizes Transformer data\n      generated offline as detailed\n      <a href=\"https://github.com/poloclub/dodrio/tree/master/data-generation\"\n        >here</a\n      >. Try visualizing your own model/dataset! The entire interactive system\n      is written in Javascript using\n      <a href=\"https://svelte.dev/\"><em>Svelte</em></a>\n      framework and <a href=\"https://d3js.org/\"><em>D3.js</em></a> for\n      visualizations. You only need a web browser to start exploring the\n      attention mechanism in complex Transformers today!\n\n      <span class=\"dodrio-text\">Dodrio</span> is an\n      <a href=\"https://github.com/poloclub/dodrio\">open-source project</a>; if\n      you have any questions, feel free to open an issue\n      <a href=\"https://github.com/poloclub/dodrio/issues\">here</a>. To learn\n      more about <span class=\"dodrio-text\">Dodrio</span>, please check out our\n      pre-print paper\n      <a href=\"https://arxiv.org/abs/2103.14625\"\n        >\"Dodrio: Exploring Transformer Models with Interactive Visualization.\"</a\n      >\n    </p>\n\n    <div class=\"paper\">\n      <div class=\"paper-image\">\n        <a href=\"https://arxiv.org/abs/2103.14625\">\n          <!-- <img src='https://i.imgur.com/PqfUQEN.png' alt='paper'> -->\n          <img src=\"https://i.imgur.com/PE4GN50.png\" alt=\"paper\" />\n        </a>\n      </div>\n\n      <div class=\"paper-info\">\n        <div class=\"paper-info__title\">\n          <a href=\"https://arxiv.org/abs/2103.14625\">\n            Dodrio: Exploring Transformer Models with Interactive Visualization\n          </a>\n        </div>\n        <div class=\"paper-info__author\">\n          <a href=\"https://zijie.wang/\">Zijie J. Wang</a>,\n          <a href=\"https://www.linkedin.com/in/robert-turko/\">Robert Turko</a>,\n          and\n          <a href=\"https://www.cc.gatech.edu/~dchau/\">Duen Horng (Polo) Chau</a\n          >.\n        </div>\n        <div class=\"paper-info__venue\">\n          <em>arXiv preprint arXiv:2103.14625. 2021.</em>\n        </div>\n      </div>\n    </div>\n\n    <h2>Who developed <span class=\"dodrio-text\">Dodrio</span>?</h2>\n    <p>\n      <span class=\"dodrio-text\">Dodrio</span> was created by\n      <a href=\"https://zijie.wang/\">Jay Wang</a>,\n      <a href=\"https://www.linkedin.com/in/robert-turko/\">Robert Turko</a>, and\n      <a href=\"https://www.cc.gatech.edu/~dchau/\">Polo Chau</a> in the College of\n      Computing at Georgia Tech. This work was supported in part by NSF grants IIS-1563816,\n      CNS-1704701, NASA NSTRF, DARPA GARD, gifts from Bosch, Intel, NVIDIA, Google,\n      Amazon.\n    </p>\n  </div>\n</body>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import {\n    instanceViewConfigStore,\n    hoverTokenStore,\n    wordToSubwordMapStore,\n    tableModalStore,\n    instanceIDStore,\n    comparisonViewStore,\n  } from '../store';\n  import { isSpecialToken, padZeroLeft } from './utils';\n  import { drawParagraph } from './saliency-view';\n  import { drawGraph } from './dependency-view';\n  import RadialModal from './RadialModal.svelte';\n  import {\n    drawDependencyComparison,\n    removeDependencyComparison,\n  } from './comparison-view';\n  import { drawTree } from './tree-view';\n  import { createEventDispatcher } from 'svelte';\n  import * as d3 from 'd3';\n\n  export let attentionDataDir;\n  export let saliencyDataFilepath;\n  export let dependencyDataFilepath;\n  export let syntacticHeadDataFilepath;\n  export let semanticHeadDataFilepath;\n  export let importantHeadDataFilepath;\n\n  const dispatch = createEventDispatcher();\n\n  let svg = null;\n  let data = null;\n  let existingLinkSet = null;\n  let saliencies = null;\n  let attentions = null;\n  let headOrderMap = {};\n\n  let wordToSubwordMap = null;\n  let relations = [];\n  let selectedRelations = {};\n  let instanceID = 1562;\n\n  let textTokenWidths = {};\n  let tokenXs = [];\n\n  let SVGWidth = 800;\n  let SVGHeight = 800;\n\n  let instanceViewConfig = undefined;\n  let SVGInitialized = false;\n  let inComparisonView = false;\n  let comparisonViewConfig = {};\n\n  comparisonViewStore.subscribe((value) => {\n    comparisonViewConfig = value;\n    SVGHeight = comparisonViewConfig.height - 41;\n\n    if (comparisonViewConfig.inComparison && !inComparisonView) {\n      comparisonButtonClickedHandler();\n    } else if (!comparisonViewConfig.inComparison && inComparisonView) {\n      comparisonButtonClickedHandler();\n    }\n  });\n\n  // Table Modal info\n  let tableModalInfo = null;\n  tableModalStore.subscribe((value) => {\n    tableModalInfo = value;\n  });\n\n  const SVGPadding = { top: 10, left: 15, right: 15, bottom: 10 };\n  const textTokenPadding = { top: 3, left: 3, right: 3, bottom: 3 };\n\n  // Global stores\n  let curHoverToken = null;\n\n  // Control panel variables\n  const layoutOptions = {\n    saliency: {\n      value: 'saliency',\n      name: 'Saliency View',\n    },\n    dependency: {\n      value: 'dependency',\n      name: 'Dependency List',\n    },\n    tree: {\n      value: 'tree',\n      name: 'Dependency Tree',\n    },\n  };\n\n  const headListOptions = {\n    syntactic: {\n      value: 'syntactic',\n      name: 'syntactic correlations',\n    },\n    semantic: {\n      value: 'semantic',\n      name: 'semantic correlations ',\n    },\n    importance: {\n      value: 'important',\n      name: 'importance scores',\n    },\n  };\n\n  let dependencyViewInitialized = false;\n  let saliencyViewInitialized = false;\n  let treeViewInitialized = false;\n\n  let currentLayout = layoutOptions.dependency;\n  let linkColor = 'hsl(0, 0%, 80%)';\n  let linkHoverColor = 'hsl(42, 95%, 58%)';\n  linkHoverColor = 'hsl(36, 100%, 55%)';\n  // linkHoverColor = 'hsl(174, 65%, 48%)';\n\n  // let linkHoverGradient1 = 'hsl(173, 66%, 90%)';\n  // let linkHoverGradient2 = 'hsl(176, 74%, 70%)';\n  // let linkHoverGradient3 = 'hsl(173, 66%, 35%)';\n\n  let linkHoverGradient1 = 'hsl(36, 100%, 90%)';\n  let linkHoverGradient2 = 'hsl(36, 100%, 80%)';\n  let linkHoverGradient3 = 'hsl(36, 100%, 55%)';\n\n  let showRelationCheckboxes = false;\n\n  const ease = d3.easeCubicInOut;\n  const animationTime = 300;\n\n  const bindSelect = () => {\n    let selectOption = d3\n      .select('#instance-select')\n      .property('value', currentLayout.value);\n\n    selectOption.on('change', () => {\n      let newLayoutValue = selectOption.property('value');\n\n      // Need to switch layout\n      if (newLayoutValue !== currentLayout.value) {\n        switch (newLayoutValue) {\n          case 'saliency':\n            // Hide the old view\n            if (\n              currentLayout.value === 'dependency' &&\n              dependencyViewInitialized\n            ) {\n              svg.select('g.token-group').style('display', 'none');\n            }\n\n            if (currentLayout.value === 'tree' && treeViewInitialized) {\n              svg.select('g.tree-group').style('display', 'none');\n            }\n\n            // Draw the new view\n            if (saliencyViewInitialized) {\n              svg.select('g.token-group-saliency').style('display', null);\n              svg.select('g.legend-group').style('display', null);\n            } else {\n              if (!SVGInitialized) {\n                initSVG();\n              }\n              drawParagraph(\n                saliencies,\n                svg,\n                SVGWidth,\n                SVGPadding,\n                textTokenPadding,\n                wordToSubwordMap,\n                tokenNodeMouseover,\n                tokenNodeMouseleave\n              );\n              saliencyViewInitialized = true;\n            }\n            currentLayout = layoutOptions[newLayoutValue];\n            break;\n\n          case 'dependency':\n            console.log('change to dependency view');\n\n            // Hide the old view\n            if (currentLayout.value === 'tree' && treeViewInitialized) {\n              svg.select('g.tree-group').style('display', 'none');\n            }\n\n            if (currentLayout.value === 'saliency' && saliencyViewInitialized) {\n              svg.select('g.token-group-saliency').style('display', 'none');\n              svg.select('g.legend-group').style('display', 'none');\n            }\n\n            // Draw the new view\n            if (dependencyViewInitialized) {\n              svg.select('g.token-group').style('display', null);\n            } else {\n              if (!SVGInitialized) {\n                initSVG();\n              }\n              let results = drawGraph(\n                data,\n                saliencies,\n                wordToSubwordMap,\n                svg,\n                tokenXs,\n                textTokenPadding,\n                SVGPadding,\n                SVGHeight,\n                tokenNodeMouseover,\n                tokenNodeMouseleave,\n                initWordToSubwordMap\n              );\n\n              tokenXs = results.tokenXs;\n              textTokenWidths = results.textTokenWidths;\n              dependencyViewInitialized = true;\n            }\n\n            currentLayout = layoutOptions[newLayoutValue];\n            break;\n\n          case 'tree':\n            console.log('change to tree view');\n\n            // Hide the old view\n            if (\n              currentLayout.value === 'dependency' &&\n              dependencyViewInitialized\n            ) {\n              svg.select('g.token-group').style('display', 'none');\n            }\n\n            if (currentLayout.value === 'saliency' && saliencyViewInitialized) {\n              svg.select('g.token-group-saliency').style('display', 'none');\n              svg.select('g.legend-group').style('display', 'none');\n            }\n\n            // Draw the new view\n            if (treeViewInitialized) {\n              svg.select('g.tree-group').style('display', null);\n            } else {\n              if (!SVGInitialized) {\n                initSVG();\n              }\n              drawTree(\n                data,\n                saliencies,\n                svg,\n                SVGWidth,\n                SVGHeight,\n                SVGPadding,\n                tokenNodeMouseoverTree,\n                tokenNodeMouseleave,\n                textTokenPadding,\n                wordToSubwordMap,\n                initWordToSubwordMap\n              );\n              treeViewInitialized = true;\n            }\n\n            currentLayout = layoutOptions[newLayoutValue];\n            break;\n        }\n      }\n    });\n  };\n\n  const initSVG = () => {\n    svg = d3\n      .select('svg.dependency-svg')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight);\n\n    // Add a border\n    svg\n      .append('rect')\n      .attr('class', 'border-rect')\n      .attr('width', SVGWidth)\n      .attr('height', SVGHeight)\n      .style('stroke', 'black')\n      .style('fill', 'none');\n\n    // Add arrow markers\n    let arrowMarker = svg.append('defs');\n\n    arrowMarker\n      .append('marker')\n      .attr('id', 'dep-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 0)\n      .attr('refY', 5)\n      .attr('markerWidth', 10)\n      .attr('markerHeight', 5)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', linkColor)\n      .attr('fill', linkColor);\n\n    arrowMarker\n      .clone(true)\n      .select('marker')\n      .attr('id', 'dep-arrow-hover')\n      .select('path')\n      .attr('stroke', linkHoverColor)\n      .attr('fill', linkHoverColor);\n\n    arrowMarker\n      .clone(true)\n      .select('marker')\n      .attr('id', 'dep-attention-arc-arrow')\n      .select('path')\n      .attr('stroke', 'none')\n      .attr('refX', 2)\n      .attr('fill', 'hsl(0, 0%, 10%)');\n\n    arrowMarker\n      .clone(true)\n      .select('marker')\n      .attr('id', 'dep-attention-arrow')\n      .select('path')\n      .attr('stroke', 'none')\n      .attr('refX', 2)\n      .attr('fill', 'hsl(0, 0%, 80%)');\n\n    // Create opacity gradient\n    let gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-opacity-gradient')\n      .attr('x2', '0%')\n      .attr('y2', '100%');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0.9');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0)\n      .style('stop-color', 'white')\n      .attr('offset', '1');\n\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'bottom-opacity-gradient')\n      .attr('x2', '0%')\n      .attr('y2', '100%');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0)\n      .style('stop-color', 'white')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '0.5');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'white')\n      .attr('offset', '1');\n\n    // Line gradient right to left\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'link-opacity-gradient-rl');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.6');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '1');\n\n    // Line gradient left to right\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'link-opacity-gradient-lr');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.4');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '1');\n\n    // Matched line gradient right to left\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'matched-link-opacity-gradient-rl');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient1)\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient2)\n      .attr('offset', '0.6');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient3)\n      .attr('offset', '1');\n\n    // Matched line gradient left to right\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'matched-link-opacity-gradient-lr');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient3)\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient2)\n      .attr('offset', '0.4');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 1)\n      .style('stop-color', linkHoverGradient1)\n      .attr('offset', '1');\n\n    // Top line gradient right to left\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-link-opacity-gradient-rl');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.3');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '1');\n\n    // Line gradient left to right\n    gradient = svg\n      .append('defs')\n      .append('linearGradient')\n      .attr('id', 'top-link-opacity-gradient-lr');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 90%)')\n      .attr('offset', '0');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 70%)')\n      .attr('offset', '0.7');\n\n    gradient\n      .append('stop')\n      .style('stop-opacity', 0.8)\n      .style('stop-color', 'hsl(0, 0%, 20%)')\n      .attr('offset', '1');\n\n    SVGInitialized = true;\n  };\n\n  const tokenNodeMouseover = (e) => {\n    let curNode = d3.select(e.target);\n    let nodeID = curNode.data()[0].id;\n    hoverTokenStore.set(nodeID);\n  };\n\n  const tokenNodeMouseleave = () => {\n    hoverTokenStore.set(null);\n  };\n\n  const tokenNodeMouseoverTree = (tokens, e) => {\n    let curNode = d3.select(e.target);\n    let nodeID = tokens[curNode.data()[0].id].id;\n    hoverTokenStore.set(nodeID);\n  };\n\n  const highLightNode = () => {\n    // Cannot directly select class because some weird special character selector bug on firefox\n    svg\n      .selectAll('.node')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .select('rect')\n      .style('stroke', linkHoverColor)\n      .style('stroke-width', 2);\n\n    svg\n      .selectAll('.arc-path')\n      // TODO\n      // .style('opacity', 0.2);\n      .style('opacity', 0.8);\n\n    svg\n      .selectAll('.arc-path')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', true)\n      .style('opacity', 1)\n      .raise();\n\n    svg\n      .selectAll('.node-clone')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .select('rect')\n      .style('stroke', linkHoverColor)\n      .style('opacity', 1)\n      .style('stroke-width', 2);\n\n    svg.selectAll('.matched-attention-path').classed('de-highlighted', true);\n\n    svg.selectAll('.attention-path').style('opacity', 0.2);\n\n    svg\n      .selectAll('.attention-path')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', true)\n      .style('opacity', 1)\n      .raise();\n\n    svg.selectAll('.attention-arc').style('opacity', 0.2);\n\n    svg\n      .selectAll('.attention-arc')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', true)\n      .style('opacity', 0.9)\n      .raise();\n  };\n\n  const deHighLightNode = () => {\n    // TODO\n    // return;\n\n    svg\n      .selectAll('.node')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .select('rect')\n      .style('stroke', 'hsl(180, 1%, 80%)')\n      .style('stroke-width', 1);\n\n    svg.selectAll('.arc-path').style('opacity', null);\n\n    svg\n      .selectAll('.arc-path')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', false);\n\n    svg\n      .selectAll('.node-clone')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .select('rect')\n      .style('opacity', null)\n      .style('stroke', 'none');\n\n    svg.selectAll('.matched-attention-path').classed('de-highlighted', false);\n\n    svg.selectAll('.attention-path').style('opacity', null);\n\n    svg\n      .selectAll('.attention-path')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', false)\n      .raise();\n\n    svg.selectAll('.attention-arc').style('opacity', 0.5);\n\n    svg\n      .selectAll('.attention-arc')\n      .filter((d, i, g) =>\n        d3.select(g[i]).attr('class').includes(`-${curHoverToken}`)\n      )\n      .classed('highlighted', false)\n      .raise();\n  };\n\n  const initWordToSubwordMap = (tokens, saliencies) => {\n    wordToSubwordMap = {};\n    let j = 0;\n    while (isSpecialToken(saliencies.tokens[j].token)) {\n      j += 1;\n    }\n\n    for (let i = 0; i < tokens.length; i++) {\n      if (j >= saliencies.tokens.length) break;\n\n      let curWord = tokens[i].token;\n      let curToken = saliencies.tokens[j].token;\n\n      if (curWord !== curToken) {\n        let nextWord = i + 1 < tokens.length ? tokens[i + 1].token : null;\n        wordToSubwordMap[curWord] = [];\n\n        while (saliencies.tokens[j].token !== nextWord) {\n          wordToSubwordMap[curWord].push(saliencies.tokens[j].id);\n          j += 1;\n\n          if (j >= saliencies.tokens.length) break;\n        }\n      } else {\n        j += 1;\n      }\n    }\n\n    // Update the store\n    wordToSubwordMapStore.set(wordToSubwordMap);\n\n    return wordToSubwordMap;\n  };\n\n  const comparisonButtonClicked = () => {\n    // Dispatch to parent if user clicks the button instead of arrow\n    if (inComparisonView) {\n      dispatch('close');\n    } else {\n      dispatch('open');\n    }\n  };\n\n  const comparisonButtonClickedHandler = () => {\n    svg.attr('height', SVGHeight);\n\n    let topHeadMap = getInterestingHeads();\n\n    if (inComparisonView) {\n      inComparisonView = false;\n      removeDependencyComparison(svg);\n    } else {\n      inComparisonView = true;\n      if (attentions == null) {\n        initAttentionData(\n          `PUBLIC_URL/data/sst2-attention-data/attention-${padZeroLeft(\n            instanceID,\n            4\n          )}.json`\n        ).then(() =>\n          drawDependencyComparison(\n            topHeadMap,\n            svg,\n            SVGPadding,\n            data,\n            attentions,\n            saliencies,\n            SVGHeight,\n            existingLinkSet,\n            tokenXs,\n            textTokenPadding,\n            textTokenWidths,\n            wordToSubwordMap,\n            initWordToSubwordMap\n          )\n        );\n      } else {\n        drawDependencyComparison(\n          topHeadMap,\n          svg,\n          SVGPadding,\n          data,\n          attentions,\n          saliencies,\n          SVGHeight,\n          existingLinkSet,\n          tokenXs,\n          textTokenPadding,\n          textTokenWidths,\n          wordToSubwordMap,\n          initWordToSubwordMap\n        );\n      }\n    }\n  };\n\n  const editButtonClicked = () => {\n    tableModalInfo.show = true;\n    tableModalStore.set(tableModalInfo);\n  };\n\n  const checkboxChanged = (e) => {\n    // Need to change the selectedRelations again because there is a race between\n    // svelte's bind:checked call back and this function (on:change)\n    let curRel = e.target.dataset.rel;\n    selectedRelations[curRel] = e.target.checked;\n\n    // Hide/show corresponding links\n    svg\n      .selectAll('.arc-path')\n      .filter((d) => d.relation === curRel)\n      .style('visibility', selectedRelations[curRel] ? 'visible' : 'hidden');\n\n    // Highlight/dehighlight corresponding attention predictions\n    svg\n      .selectAll(`.matched-attention-path-${curRel}`)\n      .classed('matched-attention-path', selectedRelations[curRel]);\n  };\n\n  /**\n   * Create a list of interesting heads based on their max accuracy on the selected\n   * syntactic dependencies.\n   */\n  const getInterestingHeads = () => {\n    let topHeadMap = {};\n\n    // Load the syntactic list\n    let potentialHeads = new Map();\n\n    let headOrder = headOrderMap.syntactic;\n    for (let key in selectedRelations) {\n      if (!selectedRelations[key] || headOrder[key] === undefined) {\n        continue;\n      }\n\n      let topHeads = headOrder[key]['top_heads'];\n\n      // Track the max accuracy\n      topHeads.forEach((d) => {\n        if (potentialHeads.has(d.head)) {\n          potentialHeads.set(\n            d.head,\n            Math.max(d.acc, potentialHeads.get(d.head))\n          );\n        } else {\n          potentialHeads.set(d.head, d.acc);\n        }\n      });\n    }\n\n    // Sort the heads\n    let sortedHeads = [...potentialHeads.entries()].sort((a, b) => b[1] - a[1]);\n    let sortedObjHeads = sortedHeads.map((d) => ({\n      id: {\n        layer: d[0][0],\n        head: d[0][1],\n      },\n      acc: d[1],\n    }));\n\n    topHeadMap.syntactic = sortedObjHeads;\n\n    // Load the semantic list\n    // Create a list of interesting heads based on the original order (semantic score\n    // or the importance score)\n    headOrder = headOrderMap.semantic;\n    sortedObjHeads = headOrder.map((d) => ({\n      id: {\n        layer: d[1][0],\n        head: d[1][1],\n      },\n      score: d[0],\n    }));\n\n    topHeadMap.semantic = sortedObjHeads;\n\n    // Load the important list\n    headOrder = headOrderMap.important;\n    sortedObjHeads = headOrder.map((d) => ({\n      id: {\n        layer: d[1][0],\n        head: d[1][1],\n      },\n      score: d[0],\n    }));\n\n    topHeadMap.important = sortedObjHeads;\n\n    return topHeadMap;\n  };\n\n  const initData = async (\n    dependencyFile,\n    saliencyFile,\n    syntacticOrderFile,\n    semanticOrderFile,\n    importantOrderFile\n  ) => {\n    // Init dependency data\n    data = await d3.json(dependencyFile);\n    data = data[instanceID];\n\n    let relationCounter = new Map();\n    selectedRelations = {};\n\n    // Create a set of existing [parent, child] pairs\n    existingLinkSet = new Map();\n\n    data.list.forEach((d) => {\n      existingLinkSet.set(String([d.parent, d.child]), d.relation);\n      if (relationCounter.has(d.relation)) {\n        relationCounter.set(d.relation, relationCounter.get(d.relation) + 1);\n      } else {\n        relationCounter.set(d.relation, 1);\n        // Select all relations in initialization\n        selectedRelations[d.relation] = true;\n      }\n    });\n    relationCounter = new Map(\n      [...relationCounter.entries()].sort((a, b) => b[1] - a[1])\n    );\n    relations = [...relationCounter.entries()];\n\n    // Init saliency data\n    saliencies = await d3.json(saliencyFile);\n    saliencies = saliencies[instanceID];\n\n    // Init the dependency layer/head accuracy list\n    headOrderMap.syntactic = await d3.json(syntacticOrderFile);\n\n    headOrderMap.semantic = await d3.json(semanticOrderFile);\n    headOrderMap.semantic = headOrderMap.semantic[instanceID];\n\n    headOrderMap.important = await d3.json(importantOrderFile);\n    headOrderMap.important = headOrderMap.important[instanceID];\n  };\n\n  const initAttentionData = async (attentionFile) => {\n    attentions = await d3.json(attentionFile);\n  };\n\n  onMount(async () => {\n    // Load the dependency and saliency data\n    if (data == null || saliencies == null) {\n      initData(\n        dependencyDataFilepath,\n        saliencyDataFilepath,\n        syntacticHeadDataFilepath,\n        semanticHeadDataFilepath,\n        importantHeadDataFilepath\n      );\n    }\n\n    bindSelect();\n  });\n\n  const createGraph = () => {\n    let results = null;\n    switch (currentLayout.value) {\n      case 'saliency':\n        if (!SVGInitialized) {\n          initSVG();\n        }\n        drawParagraph(\n          saliencies,\n          svg,\n          SVGWidth,\n          SVGPadding,\n          textTokenPadding,\n          wordToSubwordMap,\n          tokenNodeMouseover,\n          tokenNodeMouseleave\n        );\n        saliencyViewInitialized = true;\n        break;\n\n      case 'dependency':\n        if (!SVGInitialized) {\n          initSVG();\n        }\n        results = drawGraph(\n          data,\n          saliencies,\n          wordToSubwordMap,\n          svg,\n          tokenXs,\n          textTokenPadding,\n          SVGPadding,\n          SVGHeight,\n          tokenNodeMouseover,\n          tokenNodeMouseleave,\n          initWordToSubwordMap\n        );\n        tokenXs = results.tokenXs;\n        textTokenWidths = results.textTokenWidths;\n\n        dependencyViewInitialized = true;\n        break;\n\n      case 'tree':\n        if (!SVGInitialized) {\n          initSVG();\n        }\n        drawTree(\n          data,\n          saliencies,\n          svg,\n          SVGWidth,\n          SVGHeight,\n          SVGPadding,\n          tokenNodeMouseoverTree,\n          tokenNodeMouseleave,\n          textTokenPadding,\n          wordToSubwordMap,\n          initWordToSubwordMap\n        );\n        treeViewInitialized = true;\n        break;\n    }\n  };\n\n  instanceViewConfigStore.subscribe(async (value) => {\n    if (value.compHeight !== undefined && value.compWidth !== undefined) {\n      if (\n        instanceViewConfig === undefined ||\n        (instanceViewConfig.compHeight !== value.compHeight &&\n          instanceViewConfig.compWidth !== value.compWidth)\n      ) {\n        instanceViewConfig = value;\n\n        SVGWidth = instanceViewConfig.compWidth;\n        SVGHeight = instanceViewConfig.compHeight - 41;\n\n        // Load the dependency and saliency data\n        if (data == null || saliencies == null) {\n          initData(\n            dependencyDataFilepath,\n            saliencyDataFilepath,\n            syntacticHeadDataFilepath,\n            semanticHeadDataFilepath,\n            importantHeadDataFilepath\n          ).then(createGraph);\n        } else {\n          createGraph();\n        }\n      }\n    }\n  });\n\n  instanceIDStore.subscribe((value) => {\n    // console.log('Instance changed!!');\n    if (value !== instanceID) {\n      svg.selectAll('*').remove();\n      SVGInitialized = false;\n      attentions = null;\n\n      data = null;\n      existingLinkSet = null;\n      saliencies = null;\n      attentions = null;\n      headOrderMap = {};\n\n      wordToSubwordMap = null;\n      dependencyViewInitialized = false;\n      saliencyViewInitialized = false;\n      treeViewInitialized = false;\n      instanceID = value;\n      initData(\n        dependencyDataFilepath,\n        saliencyDataFilepath,\n        syntacticHeadDataFilepath,\n        semanticHeadDataFilepath,\n        importantHeadDataFilepath\n      ).then(createGraph);\n    }\n  });\n\n  hoverTokenStore.subscribe((value) => {\n    if (svg == null) {\n      return;\n    }\n\n    if (value != null) {\n      // Highlight the corresponding node\n      curHoverToken = value;\n      highLightNode();\n    } else {\n      // Dehighlight the old node\n      deHighLightNode();\n      curHoverToken = value;\n    }\n  });\n</script>\n\n<style lang=\"scss\">.svg-container {\n  width: 100%;\n  overflow-x: scroll;\n  position: absolute;\n  top: 41px;\n  cursor: default;\n}\n\n.graph-view {\n  display: flex;\n  flex-direction: row;\n}\n\n:global(.arc-text) {\n  dominant-baseline: middle;\n  font-family: \"Roboto Mono\", monospace;\n  font-size: 0.8em;\n  text-anchor: middle;\n  stroke-linejoin: round;\n  fill: #0088ff;\n}\n\n:global(.arc-path) {\n  stroke-width: 2;\n  fill: none;\n}\n\n:global(.arc-path--lr) {\n  stroke: url(#top-link-opacity-gradient-lr);\n}\n\n:global(.arc-path--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 3;\n}\n\n:global(.arc-path--rl) {\n  stroke: url(#top-link-opacity-gradient-rl);\n}\n\n:global(.arc-path--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 3;\n}\n\n:global(.node-circle) {\n  stroke: #fff;\n  stroke-width: 1.5;\n}\n\n:global(.text-token) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  cursor: default;\n  fill: black;\n}\n\n:global(.text-token-arc) {\n  dominant-baseline: middle;\n  text-anchor: middle;\n  cursor: default;\n  fill: black;\n  dominant-baseline: hanging;\n  text-anchor: start;\n}\n\n:global(.text-link) {\n  cursor: default;\n  fill: #3a76a6;\n}\n\n:global(.node-group) {\n  stroke-linejoin: round;\n}\n:global(.node-group) :global(rect) {\n  fill: #f9fafb;\n  stroke: #cbcdcd;\n}\n\n:global(.link-group) {\n  fill: none;\n  stroke-opacity: 0.5;\n  stroke-width: 1.5;\n  stroke: #555;\n}\n\n:global(.node-group-attention) :global(text) {\n  opacity: 0.3;\n}\n:global(.node-group-attention) :global(rect) {\n  opacity: 0.4;\n  stroke: none;\n}\n\n:global(.comparison-head-name-group) :global(.name) {\n  font-size: 12px;\n  dominant-baseline: hanging;\n}\n\n:global(.attention-path) {\n  stroke: rgba(0, 0, 0, 0.3);\n  fill: none;\n}\n\n:global(.attention-path--lr) {\n  stroke: url(#link-opacity-gradient-lr);\n}\n\n:global(.attention-path--rl) {\n  stroke: url(#link-opacity-gradient-rl);\n}\n\n:global(.attention-arc) {\n  stroke: #1a1a1a;\n  fill: none;\n}\n\n:global(.attention-arc--lr) {\n  stroke: url(#link-opacity-gradient-lr);\n}\n\n:global(.attention-arc--rl) {\n  stroke: url(#link-opacity-gradient-rl);\n}\n\n:global(.attention-arc--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.attention-arc--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path) {\n  stroke: #fd9744;\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--lr) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n}\n\n:global(.matched-attention-path.attention-path--rl) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n}\n\n:global(.matched-attention-path.attention-path--lr.de-highlighted) {\n  stroke: url(#link-opacity-gradient-lr);\n  stroke-width: 1;\n}\n\n:global(.matched-attention-path.attention-path--rl.de-highlighted) {\n  stroke: url(#link-opacity-gradient-rl);\n  stroke-width: 1;\n}\n\n:global(.attention-path--lr.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.attention-path--rl.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--lr.de-highlighted.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-lr);\n  stroke-width: 2;\n}\n\n:global(.matched-attention-path.attention-path--rl.de-highlighted.highlighted) {\n  stroke: url(#matched-link-opacity-gradient-rl);\n  stroke-width: 2;\n}\n\n:global(.comparison-svg-button) {\n  cursor: pointer;\n}\n\n:global(.disabled) {\n  cursor: not-allowed;\n}\n\n.panel-container, .comparison-panel-container {\n  position: absolute;\n  display: flex;\n  flex-direction: row;\n}\n\n.dependency-label, .comparison-label {\n  color: gray;\n  font-size: 1.3rem;\n  margin: 0 8px 0 20px;\n}\n\n.svg-control-panel, .comparison-control-panel {\n  position: sticky;\n  top: 0;\n  left: 0;\n  z-index: 5;\n  width: 98vw;\n  cursor: default;\n  padding-top: 5px;\n  max-height: 76px;\n  overflow: visible;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  font-size: 0.9rem;\n  background: rgba(255, 255, 255, 0.9);\n  user-select: none;\n}\n\nselect {\n  background: inherit;\n  border-color: rgba(0, 0, 0, 0);\n  padding: 0 1.6em 0 0.4em;\n  height: 1.8em;\n}\n\n.select select:not([multiple]) {\n  padding-right: 1.6em;\n}\n\n.select:not(.is-multiple) {\n  height: 1.8em;\n}\n\n.select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.8em;\n  border-color: #a77e62;\n}\n\n.comparison-panel-container {\n  width: 100%;\n  z-index: 5;\n  border-top: 3px solid #a77e62;\n}\n\n.comparison-label {\n  margin: 0 4px 0 20px;\n}\n\n.comparison-select {\n  font-size: 1.2em;\n  height: 2em;\n  border-bottom: 1px solid rgba(49, 32, 18, 0.2);\n}\n.comparison-select:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n.comparison-select select {\n  margin: 0;\n  padding: 0 1em 0 0;\n}\n.comparison-select select::after {\n  margin-top: -5px;\n}\n.comparison-select select:not([multiple]) {\n  padding-right: 1em;\n}\n.comparison-select:not(.is-multiple):not(.is-loading)::after {\n  right: 0.3em;\n  border-color: #a77e62;\n  margin-top: -0.3em;\n}\n\n.relation-checkboxes {\n  position: absolute;\n  top: -40px;\n  left: 700px;\n  width: 700px;\n  padding: 5px 10px;\n  cursor: default;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n  font-size: 0.9rem;\n  border-radius: 5px;\n  border: 1px solid #eeeeee;\n  box-shadow: 0 3px 3px rgba(0, 0, 0, 0.05);\n  background: rgba(255, 255, 255, 0.95);\n}\n\n.check-box-wrapper {\n  padding: 0 5px;\n}\n.check-box-wrapper input[type=checkbox] {\n  filter: hue-rotate(195deg) saturate(30%);\n}\n\n.select-row {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 5px;\n  border: 1px solid #f1e4da;\n  margin-right: 5px;\n}\n.select-row:hover {\n  background: rgba(49, 32, 18, 0.05);\n}\n.select-row--highlight {\n  border: 1px solid #d6af8f;\n  background: rgba(49, 32, 18, 0.1);\n}\n.select-row--highlight:hover {\n  background: rgba(49, 32, 18, 0.1);\n}\n.select-row--edit {\n  margin-right: 20px;\n}\n\n.relation-container {\n  position: relative;\n}\n\n.relation {\n  padding: 0 2em 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n.relation::after {\n  z-index: 0;\n  border: 3px solid transparent;\n  border-radius: 2px;\n  border-right: 0;\n  border-top: 0;\n  content: \" \";\n  display: block;\n  height: 0.625em;\n  margin-top: -0.3em;\n  pointer-events: none;\n  position: absolute;\n  top: 50%;\n  transform: rotate(225deg);\n  transform-origin: center;\n  width: 0.625em;\n  border-color: #a77e62;\n  right: 0.9em;\n}\n\n.comparison-button {\n  padding: 0 0.4em;\n  height: 1.8em;\n  font-size: 1em;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n\n.icon-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  opacity: 1;\n}\n.icon-wrapper img {\n  height: 19px;\n}\n\n.hide {\n  display: none;\n}\n\n.light-gray {\n  color: #afa59d;\n}\n\n.gradient-guide {\n  margin-left: auto;\n}\n.gradient-guide img {\n  height: 22px;\n}</style>\n\n<div class=\"graph-view\">\n  <div class=\"panel-container\">\n    <!-- Control panel on top of the SVG -->\n    <div class=\"svg-control-panel\">\n      <div class=\"dependency-label\">Current Sentence</div>\n\n      <div class=\"select-row select-row--edit\">\n        <div class=\"relation-container\" on:click={editButtonClicked}>\n          <div class=\"comparison-button\">\n            <div class=\"icon-wrapper\">\n              <img src=\"PUBLIC_URL/figures/edit.svg\" alt=\"editing icon\" />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"select-row\">\n        <div class=\"select\">\n          <select name=\"instance-layout\" id=\"instance-select\">\n            {#each Object.values(layoutOptions) as opt}\n              <option value={opt.value}>{opt.name}</option>\n            {/each}\n          </select>\n        </div>\n      </div>\n\n      <div class=\"select-row\" class:select-row--highlight={inComparisonView}>\n        <div class=\"relation-container\" on:click={comparisonButtonClicked}>\n          <div class=\"comparison-button\">Show Comparison</div>\n        </div>\n      </div>\n\n      <div\n        class=\"select-row\"\n        class:select-row--highlight={showRelationCheckboxes}\n      >\n        <div\n          class=\"relation-container\"\n          on:click={() => {\n            showRelationCheckboxes = !showRelationCheckboxes;\n          }}\n        >\n          <div class=\"relation\">Syntactic Relations</div>\n        </div>\n      </div>\n\n      <div class=\"gradient-guide\">\n        <img src=\"PUBLIC_URL/figures/gradient.png\" alt=\"gradient guide\" />\n      </div>\n\n      <!-- Control panel after syntactic relation item is selected -->\n      <div class=\"relation-checkboxes\" class:hide={!showRelationCheckboxes}>\n        {#each relations as entry}\n          <label class=\"checkbox check-box-wrapper\">\n            <input\n              type=\"checkbox\"\n              on:change={checkboxChanged}\n              bind:checked={selectedRelations[entry[0]]}\n              data-rel={entry[0]}\n            />\n            {entry[0]}\n            <span class=\"light-gray\">({entry[1]})</span>\n          </label>\n        {/each}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"comparison-panel-container hide\">\n    <div class=\"comparison-control-panel\">\n      <!-- <div class='comparison-name'>\n        Dependency predicted by 5 attentions heads having the highest score.\n      </div> -->\n\n      <div class=\"comparison-label\" id=\"comparison-label-top\">\n        Dependencies predicted by attention heads with top\n      </div>\n\n      <div class=\"select comparison-select\">\n        <select name=\"head-list\" id=\"head-select\">\n          {#each Object.values(headListOptions) as opt}\n            <option value={opt.value}>{opt.name}</option>\n          {/each}\n        </select>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"svg-container\">\n    <svg class=\"dependency-svg\" />\n  </div>\n</div>\n\n<RadialModal />\n",
    "<script>\n  import { onMount } from 'svelte';\n  import { modalStore, attentionHeadColorStore } from '../store';\n  import { getTokenWidth } from './utils';\n  import { resetRadialButtons } from './comparison-view';\n  import * as d3 from 'd3';\n\n  let modalComponent = null;\n  let svg = null;\n  let donut = null;\n  let svgVirtualLength = 500;\n  let svgLength = 480;\n\n  let modalInfo = {};\n  let markerDef = null;\n\n  let attentionHeadColor = new Map();\n  attentionHeadColorStore.subscribe((value) => {\n    attentionHeadColor = value;\n  });\n\n  modalStore.set(modalInfo);\n  modalStore.subscribe((value) => {\n    modalInfo = value;\n    if (modalInfo.attention != null) {\n      drawDonut(donut);\n    }\n  });\n\n  const crossClicked = () => {\n    modalInfo.show = false;\n    modalStore.set(modalInfo);\n\n    // Clean up the view\n    svg.select('.donut').selectAll('*').remove();\n\n    // Reset buttons\n    resetRadialButtons();\n  };\n\n  const dragElement = (element) => {\n    let pos1 = 0,\n      pos2 = 0,\n      pos3 = 0,\n      pos4 = 0;\n\n    const dragMouseDown = (e) => {\n      pos3 = e.clientX;\n      pos4 = e.clientY;\n\n      // Register events for mouse up and mouse move\n      document.onmouseup = closeDragElement;\n      document.onmousemove = elementDrag;\n    };\n\n    const elementDrag = (e) => {\n      // calculate the new cursor position:\n      pos1 = pos3 - e.clientX;\n      pos2 = pos4 - e.clientY;\n      pos3 = e.clientX;\n      pos4 = e.clientY;\n\n      // set the element's new position:\n      element.style.top = element.offsetTop - pos2 + 'px';\n      element.style.left = element.offsetLeft - pos1 + 'px';\n    };\n\n    const closeDragElement = () => {\n      // Restore the original mouse up and mouse move\n      document.onmouseup = null;\n      document.onmousemove = null;\n\n      // Remember the size and position\n      modalInfo.top = element.style.top;\n      modalInfo.left = element.style.left;\n      modalInfo.width = element.style.width;\n      modalInfo.height = element.style.height;\n    };\n\n    document.querySelector('.modal-card-head').onmousedown = dragMouseDown;\n  };\n\n  const drawDonut = (donut) => {\n    // Restore the size and pos of the modal window if possible\n    if (modalInfo.top !== undefined) {\n      d3.select(modalComponent)\n        .select('.modal-card')\n        .style('top', `${modalInfo.top}px`)\n        .style('left', `${modalInfo.top}px`)\n        .style('width', `${modalInfo.width}px`)\n        .style('height', `${modalInfo.height}px`);\n    } else {\n      let SVGHeight = +d3.select('.dependency-svg').attr('height');\n      let SVGWidth = window.innerWidth;\n\n      d3.select(modalComponent)\n        .select('.modal-card')\n        .style('top', `${(SVGHeight - 420) / 2}px`)\n        .style('left', `${(SVGWidth - 380) / 2}px`);\n    }\n\n    let color = attentionHeadColor.get(\n      [modalInfo.layer, modalInfo.head].toString()\n    );\n\n    svg\n      .select('#atlas-arrow')\n      .select('path')\n      .attr('fill', color)\n      .attr('stroke', color);\n\n    // Pre-draw the text\n    let tempSVG = d3\n      .select(document.body)\n      .append('svg')\n      .attr('height', 200)\n      .attr('width', 200)\n      .style('visibility', 'hidden');\n\n    const result = getTokenWidth(\n      modalInfo.tokens.map((d) => d.token),\n      tempSVG,\n      '0.9em'\n    );\n    const maxTextWidth = d3.max(\n      Object.entries(result.textTokenWidths).map((d) => d[1])\n    );\n    let inRadius = svgVirtualLength / 2 - maxTextWidth;\n\n    tempSVG.remove();\n\n    // Figure out the token positions\n    let tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle =\n        -Math.PI / 2 + i * ((Math.PI * 2) / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i,\n      });\n    }\n\n    // Create the links\n    let links = [];\n    let threshold = 0;\n\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      for (let j = 0; j < modalInfo.tokens.length; j++) {\n        let curAttention = modalInfo.attention[i][j];\n        if (curAttention > threshold) {\n          links.push({\n            source: i,\n            target: j,\n            attention: curAttention,\n            id: `${i}-${j}`,\n          });\n        }\n      }\n    }\n\n    links = links.sort((a, b) => b.attention - a.attention).slice(0, 150);\n\n    // Define link width scale\n    let linkWidthScale = d3\n      .scaleLinear()\n      .domain(d3.extent(links.map((d) => d.attention)))\n      .range([0.2, 0.7]);\n\n    let linkOpacityScale = d3\n      .scaleLinear()\n      // .domain(d3.extent(links.map(d => d.attention)))\n      .domain([0, 1])\n      .range([0.1, 1]);\n\n    // Draw the texts (will re-draw again later after getting the optimal circle size)\n    let textTokenGroup = donut\n      .append('g')\n      .attr('class', 'token-text-group')\n      .style('font-size', '0.9em')\n      .style('cursor', 'default');\n\n    textTokenGroup\n      .selectAll('text')\n      .data(tokenPos, (d) => d.id)\n      .join('text')\n      .attr('data-angle', (d) => d.angle)\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', (d) => (d.angle < Math.PI / 2 ? 6 : -6))\n      .attr('text-anchor', (d) => (d.angle < Math.PI / 2 ? 'start' : 'end'))\n      .text((d) => d.token);\n\n    // Optimize the circle size (maximize the inner bbox)\n    // Need to create a temp svg to work around the drawing delay\n    let textClone = donut.select('.token-text-group').clone(true).remove();\n\n    tempSVG = d3\n      .select(document.body)\n      .append('svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', svgLength)\n      .attr('height', svgLength)\n      .style('visibility', 'hidden');\n\n    tempSVG.append(() => textClone.node());\n    let innerBox = tempSVG.select('.token-text-group').node().getBBox();\n    tempSVG.remove();\n\n    let top = svgVirtualLength / 2 + innerBox.y;\n    let bottom = svgVirtualLength - top - innerBox.height;\n    let left = svgVirtualLength / 2 + innerBox.x;\n    let right = svgVirtualLength - left - innerBox.width;\n\n    let radiusGrow = Math.min(top, bottom, left, right);\n\n    // Grow the radius and redraw text, circles and paths\n    inRadius += Math.floor(radiusGrow);\n\n    // Figure out the token positions\n    tokenPos = [];\n    for (let i = 0; i < modalInfo.tokens.length; i++) {\n      let curAngle =\n        -Math.PI / 2 + i * ((Math.PI * 2) / modalInfo.tokens.length);\n      tokenPos.push({\n        x: Math.cos(curAngle) * inRadius,\n        y: Math.sin(curAngle) * inRadius,\n        angle: curAngle,\n        token: modalInfo.tokens[i].token,\n        id: i,\n      });\n    }\n\n    // Draw invisible background for interaction\n    textTokenGroup\n      .selectAll('rect')\n      .data(tokenPos, (d) => d.id)\n      .join('rect')\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n        `;\n      })\n      .attr('x', 0)\n      .attr('y', -5)\n      .attr('width', 50)\n      .attr('height', 15)\n      .style('fill', 'white')\n      .style('opacity', 0)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-arrow').select('path').attr('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.5);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .filter((dd) => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-arrow-hover)')\n          .style('stroke', 'hsl(36, 100%, 55%)')\n          .style('stroke-width', 3)\n          .style('opacity', 1)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-arrow').select('path').attr('opacity', null);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', (d) => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Update text position\n    textTokenGroup\n      .selectAll('text')\n      .data(tokenPos, (d) => d.id)\n      .join('text')\n      .attr('data-angle', (d) => d.angle)\n      .attr('transform', (d) => {\n        let degree = (d.angle * 180) / Math.PI;\n        return `rotate(${degree})\n          translate(${inRadius}, 0)\n          rotate(${d.angle >= Math.PI / 2 ? 180 : 0})\n        `;\n      })\n      .attr('dominant-baseline', 'middle')\n      .attr('x', (d) => (d.angle < Math.PI / 2 ? 6 : -6))\n      .attr('text-anchor', (d) => (d.angle < Math.PI / 2 ? 'start' : 'end'))\n      .text((d) => d.token)\n      .on('mouseover', (e, d) => {\n        svg.select('#atlas-arrow').select('path').style('opacity', 0.5);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .style('opacity', 0.1);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .filter((dd) => {\n            return dd.source === d.id || dd.target === d.id;\n          })\n          .attr('marker-end', 'url(#atlas-arrow-hover)')\n          .style('stroke', 'hsl(24, 95%, 59%)')\n          .style('opacity', 1)\n          .style('stroke-width', 3)\n          .raise();\n      })\n      .on('mouseleave', () => {\n        svg.select('#atlas-arrow').select('path').attr('opacity', null);\n\n        donut\n          .select('.path-group')\n          .selectAll('path.donut-link')\n          .attr('marker-end', 'url(#atlas-arrow)')\n          .style('stroke', color)\n          .style('stroke-width', (d) => linkWidthScale(d.attention))\n          .style('opacity', 1);\n      });\n\n    // Draw the links as bezier curves\n    donut\n      .append('g')\n      .attr('class', 'path-group')\n      .selectAll('path.donut-link')\n      .data(links, (d) => d.id)\n      .join('path')\n      .attr('class', 'donut-link')\n      .attr('marker-end', 'url(#atlas-arrow)')\n      .attr('d', (d) => {\n        let source = tokenPos[d.source];\n        let target = tokenPos[d.target];\n        const center = { x: 0, y: 0 };\n        const radialCurveAlpha = 2 / 5;\n\n        // Two control points symmetric regarding the center point\n        let controlP1 = {\n          x: center.x + (source.x - center.x) * radialCurveAlpha,\n          y: center.y + (source.y - center.x) * radialCurveAlpha,\n        };\n\n        let controlP2 = {\n          x: center.x + (target.x - center.x) * radialCurveAlpha,\n          y: center.y + (target.y - center.x) * radialCurveAlpha,\n        };\n\n        return `M ${source.x},${source.y} C${controlP1.x}, ${controlP1.y},\n          ${controlP2.x}, ${controlP2.y}, ${target.x},${target.y}`;\n      })\n      .style('fill', 'none')\n      .style('stroke', color)\n      .style('stroke-width', (d) => linkWidthScale(d.attention))\n      .style('opacity', (d) => linkOpacityScale(d.attention));\n\n    // Draw the circles\n    donut\n      .append('g')\n      .attr('class', 'token-dot-group')\n      .selectAll('circle.token-dot')\n      .data(tokenPos, (d) => d.id)\n      .join('circle')\n      .attr('class', 'token-dot')\n      .attr('cx', (d) => d.x)\n      .attr('cy', (d) => d.y)\n      .attr('r', 1);\n  };\n\n  const drawRadial = () => {\n    svg\n      .append('rect')\n      .attr('width', svgVirtualLength)\n      .attr('height', svgVirtualLength)\n      .style('fill', 'hsla(0, 0%, 100%, 0)');\n\n    donut = svg\n      .append('g')\n      .attr('class', 'donut')\n      .attr('transform', 'translate(250, 250)');\n\n    // drawDonut(donut);\n    markerDef = svg\n      .append('defs')\n      .attr('id', 'atlas-arrow-def')\n      .append('marker')\n      .attr('id', 'atlas-arrow')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'gray')\n      .attr('fill', 'gray');\n\n    markerDef = svg\n      .append('defs')\n      .attr('id', 'atlas-arrow-def-hover')\n      .append('marker')\n      .attr('id', 'atlas-arrow-hover')\n      .attr('viewBox', [0, 0, 10, 10])\n      .attr('refX', 10)\n      .attr('refY', 5)\n      .attr('markerWidth', 12)\n      .attr('markerHeight', 9)\n      .attr('orient', 'auto')\n      .attr('stroke-width', 1)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .append('path')\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z')\n      .attr('stroke', 'hsl(24, 95%, 59%)')\n      .attr('fill', 'hsl(24, 95%, 59%)');\n  };\n\n  onMount(() => {\n    // Bind drag event\n    let modalCard = d3.select(modalComponent).select('.modal-card');\n\n    dragElement(modalCard.node());\n\n    svg = modalCard\n      .select('svg.modal-svg')\n      .attr('viewBox', `0 0 ${svgVirtualLength} ${svgVirtualLength}`)\n      .attr('width', '100%')\n      .attr('height', '100%');\n\n    drawRadial();\n  });\n\n  const getColor = (layer, head) => {\n    if (\n      attentionHeadColor == null ||\n      attentionHeadColor.has === undefined ||\n      !attentionHeadColor.has([layer, head].toString())\n    ) {\n      return 'black';\n    } else {\n      return attentionHeadColor.get([layer, head].toString());\n    }\n  };\n</script>\n\n<style lang=\"scss\">.modal {\n  pointer-events: none;\n}\n\n.modal-card {\n  width: 380px;\n  height: 420px;\n  max-width: 800px;\n  min-width: 340px;\n  min-height: 380px;\n  resize: both;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n  animation: modal-card-appear 200ms;\n  /* Make it draggable */\n  position: absolute;\n  pointer-events: all;\n}\n.modal-card-title {\n  font-size: 1em;\n  cursor: default;\n  pointer-events: none;\n}\n.modal-card-head {\n  padding: 10px 15px;\n  cursor: move;\n}\n.modal-card-body {\n  padding: 5px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n@keyframes modal-card-appear {\n  0% {\n    opacity: 0;\n  }\n  50% {\n    opacity: 1;\n  }\n}</style>\n\n<div class=\"modal-component\" bind:this={modalComponent}>\n  <div class=\"modal\" class:is-active={modalInfo.show}>\n    <div class=\"modal-card\">\n      <header class=\"modal-card-head\">\n        <div\n          class=\"modal-card-title\"\n          style={`color: ${getColor(modalInfo.layer, modalInfo.head)}`}\n        >\n          Layer {modalInfo.layer} Head {modalInfo.head} Attention Wights\n        </div>\n        <button class=\"delete\" aria-label=\"close\" on:click={crossClicked} />\n      </header>\n\n      <section class=\"modal-card-body\">\n        <svg class=\"modal-svg\" />\n      </section>\n    </div>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}